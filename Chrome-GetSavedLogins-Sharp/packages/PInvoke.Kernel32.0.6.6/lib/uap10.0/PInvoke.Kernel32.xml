<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PInvoke.Kernel32</name>
    </assembly>
    <members>
        <member name="T:PInvoke.Kernel32">
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.CreateFileFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.CreationDisposition"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FileAccess"/> nested type.
            </content>
            <content>
            Contains the nested <see cref="T:PInvoke.Kernel32.FileAttribute"/> type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FileShare"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FILETIME"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FINDEX_INFO_LEVELS"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FINDEX_SEARCH_OPS"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FindFirstFileExFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FormatMessageFlags"/> nested type.
            </content>
            <summary>
            Contains the <see cref="T:PInvoke.Kernel32.OSVERSIONINFOEX"/> nested type.
            </summary>
            <summary>
            Contains the <see cref="T:PInvoke.Kernel32.OS_TYPE"/> nested type.
            </summary>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.OVERLAPPED"/> nested type.
            </content>
            <summary>
            Contains the <see cref="T:PInvoke.Kernel32.PRODUCT_SUITE"/> nested type
            </summary>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SafeFindFilesHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SafeObjectHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SafeObjectHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SECURITY_DESCRIPTOR"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SYSTEMTIME"/> nested type.
            </content>
            <summary>
            Contains the nested type <see cref="T:PInvoke.Kernel32.VER_CONDITION"/>
            </summary>
            <summary>
            Contains the <see cref="T:PInvoke.Kernel32.VER_MASK"/> nested type.
            </summary>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.WaitForSingleObjectResult"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.WIN32_FIND_DATA"/> nested type.
            </content>
            <summary>
            Exported functions from the Kernel32.dll Windows library.
            </summary>
            <content>
            Methods and nested types that are not strictly P/Invokes but provide
            a slightly higher level of functionality to ease calling into native code.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.ACCESS_MASK"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.CreateFileFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.CreationDisposition"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FileAccess"/> nested type.
            </content>
            <content>
            Contains the nested <see cref = "T:PInvoke.Kernel32.FileAttribute"/> type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FileShare"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FILETIME"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FINDEX_INFO_LEVELS"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FINDEX_SEARCH_OPS"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FindFirstFileExFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FormatMessageFlags"/> nested type.
            </content>
            <summary>
            Contains the <see cref = "T:PInvoke.Kernel32.OSVERSIONINFOEX"/> nested type.
            </summary>
            <summary>
            Contains the <see cref = "T:PInvoke.Kernel32.OS_TYPE"/> nested type.
            </summary>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> nested type.
            </content>
            <summary>
            Contains the <see cref = "T:PInvoke.Kernel32.PRODUCT_SUITE"/> nested type
            </summary>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SafeFindFilesHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SafeObjectHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SafeObjectHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SECURITY_DESCRIPTOR"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SYSTEMTIME"/> nested type.
            </content>
            <summary>
            Contains the nested type <see cref = "T:PInvoke.Kernel32.VER_CONDITION"/>
            </summary>
            <summary>
            Contains the <see cref = "T:PInvoke.Kernel32.VER_MASK"/> nested type.
            </summary>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.WaitForSingleObjectResult"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.WIN32_FIND_DATA"/> nested type.
            </content>
            <summary>
            Exported functions from the Kernel32.dll Windows library.
            </summary>
            <content>
            Methods and nested types that are not strictly P/Invokes but provide
            a slightly higher level of functionality to ease calling into native code.
            </content>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            The ACCESS_MASK type is a bitmask that specifies a set of access rights in the access mask of an access control entry.
            </summary>
            <remarks>
            Quite well described here: http://blogs.msdn.com/b/openspecification/archive/2010/04/01/about-the-access-mask-structure.aspx
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.GenericRightsMask">
            <summary>
            Bits 28-31
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecialRightsMask">
            <summary>
            Bits 24-27
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRightsMask">
            <summary>
            Bits 16-23
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecificRightsMask">
            <summary>
            Bits 0-15
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.#ctor(System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/> struct.
            </summary>
            <param name="value">The value for the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.</param>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecialRight.ACCESS_SYSTEM_SECURITY">
            <summary>
            It is used to indicate access to a system access control list (SACL). This type of access requires the calling process to have the SE_SECURITY_NAME (Manage auditing and security log) privilege. If this flag is set in the access mask of an audit access ACE (successful or unsuccessful access), the SACL access will be audited.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecialRight.MAXIMUM_ALLOWED">
            <summary>
            Maximum allowed.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.StandardRight">
            <summary>
            Contains the object's standard access rights.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.DELETE">
            <summary>
            Delete access.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL">
            <summary>
            Read access to the owner, group, and discretionary access control list (DACL) of the security descriptor.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.WRITE_DAC">
            <summary>
            Write access to the DACL.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.WRITE_OWNER">
            <summary>
            Write access to owner.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.SYNCHRONIZE">
            <summary>
            Synchronize access.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.STANDARD_RIGHTS_READ">
            <summary>
            See also <see cref="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL"/>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.STANDARD_RIGHTS_WRITE">
            <summary>
            See also <see cref="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL"/>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.STANDARD_RIGHTS_EXECUTE">
            <summary>
            See also <see cref="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL"/>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.SpecificRight">
            <summary>
            Contains the access mask specific to the object type associated with the mask.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecificRight.SPECIFIC_RIGHTS_ALL">
            <summary>
            The bit mask that covers specific rights.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.DesktopGenericRight">
            <summary>
            The following are the generic access rights for a desktop object contained in the interactive window station of the user's logon session
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight">
            <summary>
            Contains the access mask specific to the Desktop associated with the mask.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_ALL_ACCESS">
            <summary>
            The bit mask that covers all possible access rights for the desktop.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_CREATEMENU">
            <summary>
            Required to create a menu on the desktop.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_ENUMERATE">
            <summary>
            Required for the desktop to be enumerated.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_HOOKCONTROL">
            <summary>
            Required to establish any of the window hooks.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_JOURNALPLAYBACK">
            <summary>
            Required to perform journal playback on a desktop.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_JOURNALRECORD">
            <summary>
            Required to perform journal recording on a desktop.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_READOBJECTS">
            <summary>
            Required to read objects on the desktop.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_CREATEWINDOW">
            <summary>
            Required to create a window on the desktop.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_SWITCHDESKTOP">
            <summary>
            Required to activate the desktop using the SwitchDesktop function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_WRITEOBJECTS">
            <summary>
            Required to write objects on the desktop.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.InteractiveWindowStationGenericRight">
            <summary>
            Generic access rights for the interactive window station object, which is the window station assigned to the logon session of the interactive user.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.NonInteractiveWindowStationGenericRight">
            <summary>
            Generic access rights for a noninteractive window station object.
            The system assigns noninteractive window stations to all logon sessions other than that of the interactive user.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight">
            <summary>
            Contains the access mask specific to the Window Station associated with the mask.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_ALL_ACCESS">
            <summary>
            The bit mask that covers all possible access rights for the window station.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_ACCESSCLIPBOARD">
            <summary>
            Required to use the clipboard.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_ACCESSGLOBALATOMS">
            <summary>
            Required to manipulate global atoms.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_CREATEDESKTOP">
            <summary>
            Required to create new desktop objects on the window station.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_ENUMDESKTOPS">
            <summary>
            Required to enumerate existing desktop objects.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_ENUMERATE">
            <summary>
            Required for the window station to be enumerated.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_EXITWINDOWS">
            <summary>
            Required to successfully call the ExitWindows or ExitWindowsEx function
            Window stations can be shared by users and this access type can prevent other users of a window station from logging off the window station owner.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_READATTRIBUTES">
            <summary>
            Required to read the attributes of a window station object. This attribute includes color settings and other global window station properties.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_READSCREEN">
            <summary>
            Required to access screen contents.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_WRITEATTRIBUTES">
            <summary>
            Required to modify the attributes of a window station object. The attributes include color settings and other global window station properties.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.Value">
            <summary>
            Gets the ACCESS_MASK as a 32-bit unsigned integer.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.AsInt32">
            <summary>
            Gets the ACCESS_MASK as a 32-bit signed integer.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.GenericRights">
            <summary>
            Gets the generic rights of this value.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.SpecialRights">
            <summary>
            Gets the special rights of this value.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.StandardRights">
            <summary>
            Gets the standard rights of this value.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.SpecificRights">
            <summary>
            Gets the specific rights of this value.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRights">
            <summary>
            Gets the specific rights of this value for desktops.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.InteractiveWindowStationGenericRights">
            <summary>
            Gets the generic rights of this value for interactive window stations.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.NonInteractiveWindowStationGenericRights">
            <summary>
            Gets the generic rights of this value for noninteractive window stations.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRights">
            <summary>
            Gets the specific rights of this value for window stations.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(System.Int32)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts an <see cref="T:System.Int32"/> into an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value of the ACCESS_MASK.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Explicit(PInvoke.Kernel32.ACCESS_MASK)~System.Int32">
            <summary>
            Converts an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/> into an <see cref="T:System.Int32"/>.
            </summary>
            <param name="value">The value of the ACCESS_MASK.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(System.UInt32)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts an <see cref="T:System.UInt32"/> into an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value of the ACCESS_MASK.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(PInvoke.Kernel32.ACCESS_MASK)~System.UInt32">
            <summary>
            Converts an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/> into an <see cref="T:System.UInt32"/>.
            </summary>
            <param name="value">The value of the ACCESS_MASK.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(PInvoke.Kernel32.ACCESS_MASK.StandardRight)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts a <see cref="T:PInvoke.Kernel32.ACCESS_MASK.StandardRight"/> to an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value for the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/></param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(PInvoke.Kernel32.ACCESS_MASK.GenericRight)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts a <see cref="T:PInvoke.Kernel32.ACCESS_MASK.GenericRight"/> to an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value for the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/></param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(PInvoke.Kernel32.ACCESS_MASK.SpecificRight)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts a <see cref="T:PInvoke.Kernel32.ACCESS_MASK.SpecificRight"/> to an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value for the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/></param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.Equals(PInvoke.Kernel32.ACCESS_MASK)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.CompareTo(PInvoke.Kernel32.ACCESS_MASK)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.ToString">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="T:PInvoke.Kernel32.CreateFileFlags">
            <summary>
            File attributes, flags, and security settings that are passed to the CreateFile method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_ARCHIVE">
            <summary>
                A file or directory that is an archive file or directory. Applications typically use this attribute to mark
                files for backup or removal.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_ENCRYPTED">
            <summary>
                A file or directory that is encrypted. For a file, all data streams in the file are encrypted. For a
                directory, encryption is the default for newly created files and subdirectories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_HIDDEN">
            <summary>The file or directory is hidden. It is not included in an ordinary directory listing.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_NORMAL">
            <summary>A file that does not have other attributes set. This attribute is valid only when used alone.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_OFFLINE">
            <summary>
                The data of a file is not available immediately. This attribute indicates that the file data is physically
                moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical storage management
                software. Applications should not arbitrarily change this attribute.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_READONLY">
            <summary>
                A file that is read-only. Applications can read the file, but cannot write to it or delete it. This attribute
                is not honored on directories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_SYSTEM">
            <summary>A file or directory that the operating system uses a part of, or uses exclusively.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_TEMPORARY">
            <summary>
                A file that is being used for temporary storage. File systems avoid writing data back to mass storage if
                sufficient cache memory is available, because typically, an application deletes a temporary file after the handle
                is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is written after
                the handle is closed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_BACKUP_SEMANTICS">
            <summary>
                The file is being opened or created for a backup or restore operation. The system ensures that the calling
                process overrides file security checks when the process has SE_BACKUP_NAME and SE_RESTORE_NAME privileges. For more
                information, see Changing Privileges in a Token. You must set this flag to obtain a handle to a directory. A
                directory handle can be passed to some functions instead of a file handle. For more information, see the Remarks
                section.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_DELETE_ON_CLOSE">
            <summary>
                The file is to be deleted immediately after all of its handles are closed, which includes the specified handle
                and any other open or duplicated handles. If there are existing open handles to a file, the call fails unless they
                were all opened with the <see cref="F:PInvoke.Kernel32.FileShare.FILE_SHARE_DELETE" /> share mode. Subsequent open requests for the
                file fail, unless the <see cref="F:PInvoke.Kernel32.FileShare.FILE_SHARE_DELETE" /> share mode is specified.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_NO_BUFFERING">
            <summary>
                The file or device is being opened with no system caching for data reads and writes. This flag does not affect
                hard disk caching or memory mapped files. There are strict requirements for successfully working with files opened
                with CreateFile using the <see cref="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_NO_BUFFERING" /> flag.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_OPEN_NO_RECALL">
            <summary>
                The file data is requested, but it should continue to be located in remote storage. It should not be
                transported back to local storage. This flag is for use by remote storage systems.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_OPEN_REPARSE_POINT">
            <summary>
                Normal reparse point processing will not occur; CreateFile will attempt to open the reparse point. When a file
                is opened, a file handle is returned, whether or not the filter that controls the reparse point is operational.
                This flag cannot be used with the <see cref="F:PInvoke.Kernel32.CreationDisposition.CREATE_ALWAYS" /> flag. If the file is not a
                reparse point, then this flag is ignored. For more information, see the Remarks section.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_OVERLAPPED">
            <summary>
                The file or device is being opened or created for asynchronous I/O. When subsequent I/O operations are
                completed on this handle, the event specified in the OVERLAPPED structure will be set to the signaled state. If
                this flag is specified, the file can be used for simultaneous read and write operations. If this flag is not
                specified, then I/O operations are serialized, even if the calls to the read and write functions specify an
                OVERLAPPED structure.For information about considerations when using a file handle created with this flag, see the
                Synchronous and Asynchronous I/O Handles section of this topic.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_POSIX_SEMANTICS">
            <summary>
                Access will occur according to POSIX rules. This includes allowing multiple files with names, differing only
                in case, for file systems that support that naming. Use care when using this option, because files created with
                this flag may not be accessible by applications that are written for MS-DOS or 16-bit Windows.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_RANDOM_ACCESS">
            <summary>
                Access is intended to be random. The system can use this as a hint to optimize file caching. This flag has no
                effect if the file system does not support cached I/O and <see cref="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_NO_BUFFERING" />. For more
                information, see the Caching Behavior section of this topic.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_SESSION_AWARE">
            <summary>
                The file or device is being opened with session awareness. If this flag is not specified, then per-session
                devices (such as a redirected USB device) cannot be opened by processes running in session 0. This flag has no
                effect for callers not in session 0. This flag is supported only on server editions of Windows.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_SEQUENTIAL_SCAN">
            <summary>
                Access is intended to be sequential from beginning to end. The system can use this as a hint to optimize file
                caching. This flag should not be used if read-behind (that is, reverse scans) will be used. This flag has no effect
                if the file system does not support cached I/O and <see cref="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_NO_BUFFERING" />. For more information, see
                the Caching Behavior section of this topic.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_WRITE_THROUGH">
            <summary>
                Write operations will not go through any intermediate cache, they will go directly to disk. For additional
                information, see the Caching Behavior section of this topic.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_SQOS_PRESENT">
            <summary>When this flag is present, one or more other flags ending with Security may also be specified.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_ANONYMOUS">
            <summary>Impersonates a client at the Anonymous impersonation level.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_CONTEXT_TRACKING">
            <summary>The security tracking mode is dynamic. If this flag is not specified, the security tracking mode is static.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_DELEGATION">
            <summary>Impersonates a client at the Delegation impersonation level.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_EFFECTIVE_ONLY">
            <summary>
                Only the enabled aspects of the client's security context are available to the server. If you do not specify
                this flag, all aspects of the client's security context are available. This allows the client to limit the groups
                and privileges that a server can use while impersonating the client.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_IDENTIFICATION">
            <summary>Impersonates a client at the Identification impersonation level.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_IMPERSONATION">
            <summary>
                Impersonate a client at the impersonation level. This is the default behavior if no other flags are specified
                along with the <see cref="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_SQOS_PRESENT" /> flag.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.CreationDisposition">
            <summary>
            Describes an action to take on a file or device that exists or does not exist.
            </summary>
            <remarks>
            These are flags to pass to the CreateFile method's dwCreationDisposition parameter.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.CreationDisposition.CREATE_NEW">
            <summary>
            Creates a new file. The function fails if a specified file exists.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreationDisposition.CREATE_ALWAYS">
            <summary>
            Creates a new file, always.
            If a file exists, the function overwrites the file, clears the existing attributes, combines the specified file attributes,
            and flags with FILE_ATTRIBUTE_ARCHIVE, but does not set the security descriptor that the SECURITY_ATTRIBUTES structure specifies.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreationDisposition.OPEN_EXISTING">
            <summary>
            Opens a file. The function fails if the file does not exist.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreationDisposition.OPEN_ALWAYS">
            <summary>
            Opens a file, always.
            If a file does not exist, the function creates a file as if dwCreationDisposition is CREATE_NEW.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreationDisposition.TRUNCATE_EXISTING">
            <summary>
            Opens a file and truncates it so that its size is 0 (zero) bytes. The function fails if the file does not exist.
            The calling process must open the file with the GENERIC_WRITE access right.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.FileAccess">
            <summary>
            Enumerates the <see cref="P:PInvoke.Kernel32.ACCESS_MASK.SpecificRights"/> that may apply to files.
            </summary>
            <remarks>
            These flags may be passed to CreateFile.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_READ_DATA">
            <summary>
                For a file object, the right to read the corresponding file data. For a directory object, the right to read
                the corresponding directory data.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_LIST_DIRECTORY">
            <summary>For a directory, the right to list the contents of the directory.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_WRITE_DATA">
            <summary>
                For a file object, the right to write data to the file. For a directory object, the right to create a file in
                the directory (<see cref="F:PInvoke.Kernel32.FileAccess.FILE_ADD_FILE" />).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_ADD_FILE">
            <summary>For a directory, the right to create a file in the directory.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_APPEND_DATA">
            <summary>
                For a file object, the right to append data to the file. (For local files, write operations will not overwrite
                existing data if this flag is specified without <see cref="F:PInvoke.Kernel32.FileAccess.FILE_WRITE_DATA" />.) For a directory object, the right
                to create a subdirectory (<see cref="F:PInvoke.Kernel32.FileAccess.FILE_ADD_SUBDIRECTORY" />).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_ADD_SUBDIRECTORY">
            <summary>For a directory, the right to create a subdirectory.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_CREATE_PIPE_INSTANCE">
            <summary>For a named pipe, the right to create a pipe.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_READ_EA">
            <summary>The right to read extended file attributes.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_WRITE_EA">
            <summary>The right to write extended file attributes.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_EXECUTE">
            <summary>
                For a native code file, the right to execute the file. This access right given to scripts may cause the script
                to be executable, depending on the script interpreter.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_TRAVERSE">
            <summary>
                For a directory, the right to traverse the directory. By default, users are assigned the
                BYPASS_TRAVERSE_CHECKING privilege, which ignores the FILE_TRAVERSE access right.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_DELETE_CHILD">
            <summary>For a directory, the right to delete a directory and all the files it contains, including read-only files.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_READ_ATTRIBUTES">
            <summary>The right to read file attributes.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_WRITE_ATTRIBUTES">
            <summary>The right to write file attributes.</summary>
        </member>
        <member name="T:PInvoke.Kernel32.FileAttribute">
            <summary>Defines the Win32 FileAttributes enum.</summary>
            <remarks>
                This is similar to the System.IO.FileAttributes enum, but that enum is not available in the portable profile,
                although it is allowed to call certain file methods via P/Invoke in Windows Store apps, per MSDN docs. A value
                typed as this enum may be safely cast to the System.IO.FileAttributes enum, as all the value names have equal
                ordinal values.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_ARCHIVE">
            <summary>
                A file or directory that is an archive file or directory. Applications typically use this attribute to mark
                files for backup or removal.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_COMPRESSED">
            <summary>
                A file or directory that is compressed. For a file, all of the data in the file is compressed. For a
                directory, compression is the default for newly created files and subdirectories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_DEVICE">
            <summary>This value is reserved for system use.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_DIRECTORY">
            <summary>The handle that identifies a directory.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_ENCRYPTED">
            <summary>
                A file or directory that is encrypted. For a file, all data streams in the file are encrypted. For a
                directory, encryption is the default for newly created files and subdirectories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_HIDDEN">
            <summary>The file or directory is hidden. It is not included in an ordinary directory listing.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_INTEGRITY_STREAM">
            <summary>
                The directory or user data stream is configured with integrity (only supported on ReFS volumes). It is not
                included in an ordinary directory listing. The integrity setting persists with the file if it's renamed. If a file
                is copied the destination file will have integrity set if either the source file or destination directory have
                integrity set.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_NORMAL">
            <summary>A file that does not have other attributes set. This attribute is valid only when used alone.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_NOT_CONTENT_INDEXED">
            <summary>The file or directory is not to be indexed by the content indexing service.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_NO_SCRUB_DATA">
            <summary>
                The user data stream not to be read by the background data integrity scanner (AKA scrubber). When set on a
                directory it only provides inheritance. This flag is only supported on Storage Spaces and ReFS volumes. It is not
                included in an ordinary directory listing.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_OFFLINE">
            <summary>
                The data of a file is not available immediately. This attribute indicates that the file data is physically
                moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical storage management
                software. Applications should not arbitrarily change this attribute.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_READONLY">
            <summary>
                A file that is read-only. Applications can read the file, but cannot write to it or delete it. This attribute
                is not honored on directories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_REPARSE_POINT">
            <summary>A file or directory that has an associated reparse point, or a file that is a symbolic link.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_SPARSE_FILE">
            <summary>A file that is a sparse file.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_SYSTEM">
            <summary>A file or directory that the operating system uses a part of, or uses exclusively.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_TEMPORARY">
            <summary>
                A file that is being used for temporary storage. File systems avoid writing data back to mass storage if
                sufficient cache memory is available, because typically, an application deletes a temporary file after the handle
                is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is written after
                the handle is closed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_VIRTUAL">
            <summary>This value is reserved for system use.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileShare.None">
            <summary>
            Prevents other processes from opening a file or device if they request delete, read, or write access.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileShare.FILE_SHARE_READ">
            <summary>
            Enables subsequent open operations on an object to request read access.
            Otherwise, other processes cannot open the object if they request read access.
            If this flag is not specified, but the object has been opened for read access, the function fails.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileShare.FILE_SHARE_WRITE">
            <summary>
            Enables subsequent open operations on an object to request write access.
            Otherwise, other processes cannot open the object if they request write access.
            If this flag is not specified, but the object has been opened for write access, the function fails.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileShare.FILE_SHARE_DELETE">
            <summary>
            Enables subsequent open operations on an object to request delete access.
            Otherwise, other processes cannot open the object if they request delete access.
            If this flag is not specified, but the object has been opened for delete access, the function fails.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.FILETIME">
            <summary>
            A 64-bit representation of a file timestamp.
            </summary>
            <remarks>
            This type is equivalent to <see cref="T:System.Runtime.InteropServices.ComTypes.FILETIME"/>.
            We couldn't use that type directly even though it's in the portable profile because
            Xamarin.Android and Xamarin.iOS omit the type and it causes link failures.
            See https://github.com/AArnott/pinvoke/issues/232
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.FILETIME.dwLowDateTime">
            <summary>
            Specifies the low 32 bits of the FILETIME.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FILETIME.dwHighDateTime">
            <summary>
            Specifies the high 32 bits of the FILETIME.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.FILETIME.op_Implicit(PInvoke.Kernel32.FILETIME)~System.Int64">
            <summary>
            Convert to <see cref="T:System.Int64"/> to ease interop with <see cref="T:System.TimeSpan"/> or <see cref="T:System.DateTime"/>
            </summary>
            <param name="fileTime"> The fileTime structure to be converted to long.</param>
        </member>
        <member name="T:PInvoke.Kernel32.FindFirstFileExFlags">
            <summary>
            Optional flags to pass to the <see cref="M:PInvoke.Kernel32.FindFirstFileEx(System.String,PInvoke.Kernel32.FINDEX_INFO_LEVELS,PInvoke.Kernel32.WIN32_FIND_DATA@,PInvoke.Kernel32.FINDEX_SEARCH_OPS,System.Void*,PInvoke.Kernel32.FindFirstFileExFlags)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FindFirstFileExFlags.None">
            <summary>
            No flags.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FindFirstFileExFlags.FIND_FIRST_EX_CASE_SENSITIVE">
            <summary>
            Searches are case-sensitive.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FindFirstFileExFlags.FIND_FIRST_EX_LARGE_FETCH">
            <summary>
            Uses a larger buffer for directory queries, which can increase performance of the find operation.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.FormatMessageFlags">
            <summary>
            Flags passed to the <see cref="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.IntPtr[],System.Int32)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER">
            <summary>
                The function allocates a buffer large enough to hold the formatted message, and places a pointer to the allocated
                buffer at the address specified by lpBuffer. The nSize parameter specifies the minimum number of TCHARs to allocate
                for an output message buffer. The caller should use the LocalFree function to free the buffer when it is no longer
                needed.
                <para>
                    If the length of the formatted message exceeds 128K bytes, then FormatMessage will fail and a subsequent call
                    to <see cref="M:PInvoke.Kernel32.GetLastError" /> will return <see cref="F:PInvoke.Win32ErrorCode.ERROR_MORE_DATA" />.
                </para>
                <para>
                    In previous versions of Windows, this value was not available for use when compiling Windows Store apps. As
                    of Windows 10 this value can be used.
                </para>
                <para>
                    Windows Server 2003 and Windows XP: If the length of the formatted message exceeds 128K bytes, then
                    FormatMessage will not automatically fail with an error of <see cref="F:PInvoke.Win32ErrorCode.ERROR_MORE_DATA" />.
                </para>
                <para>
                    Windows 10: LocalFree is not in the modern SDK, so it cannot be used to free the result buffer. Instead, use
                    HeapFree (GetProcessHeap(), allocatedMessage). In this case, this is the same as calling LocalFree on memory.
                </para>
                <para>
                    Important: LocalAlloc() has different options: LMEM_FIXED, and LMEM_MOVABLE. FormatMessage() uses LMEM_FIXED,
                    so HeapFree can be used. If LMEM_MOVABLE is used, HeapFree cannot be used.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ARGUMENT_ARRAY">
            <summary>
                The Arguments parameter is not a va_list structure, but is a pointer to an array of values that represent the
                arguments. This flag cannot be used with 64-bit integer values. If you are using a 64-bit integer, you must use the
                va_list structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE">
            <summary>
                The lpSource parameter is a module handle containing the message-table resource(s) to search. If this lpSource
                handle is NULL, the current process's application image file will be searched. This flag cannot be used with
                <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
                <para>
                    If the module has no message table resource, the function fails with
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_RESOURCE_TYPE_NOT_FOUND" />.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING">
            <summary>
                The lpSource parameter is a pointer to a null-terminated string that contains a message definition. The
                message definition may contain insert sequences, just as the message text in a message table resource may. This
                flag cannot be used with <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE" /> or <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_SYSTEM" />.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_SYSTEM">
            <summary>
                The function should search the system message-table resource(s) for the requested message. If this flag is
                specified with <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE" />, the function searches the system message table if the
                message is not found in the module specified by lpSource. This flag cannot be used with
                <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
                <para>
                    If this flag is specified, an application can pass the result of the <see cref="M:PInvoke.Kernel32.GetLastError" /> function to
                    retrieve the message text for a system-defined error.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_IGNORE_INSERTS">
            <summary>
                Insert sequences in the message definition are to be ignored and passed through to the output buffer
                unchanged. This flag is useful for fetching a message for later formatting. If this flag is set, the Arguments
                parameter is ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_MAX_WIDTH_MASK">
            <summary>
                The function ignores regular line breaks in the message definition text. The function stores hard-coded line breaks
                in the message definition text into the output buffer. The function generates no new line breaks.
                <para>
                    Without this flag set: There are no output line width restrictions. The function stores line breaks that are
                    in the message definition text into the output buffer. It specifies the maximum number of characters in an
                    output line. The function ignores regular line breaks in the message definition text. The function never splits
                    a string delimited by white space across a line break. The function stores hard-coded line breaks in the
                    message definition text into the output buffer. Hard-coded line breaks are coded with the %n escape sequence.
                </para>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.OSVERSIONINFOEX">
            <summary>
            The RTL_OSVERSIONINFOEXW structure contains operating system version information.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.dwOSVersionInfoSize">
            <summary>
            The size, in bytes, of an RTL_OSVERSIONINFOEXW structure.
            This member must be set before the structure is used with RtlGetVersion.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.dwMajorVersion">
            <summary>
            The major version number of the operating system. For example, for Windows 2000, the major version number is five.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.dwMinorVersion">
            <summary>
            The minor version number of the operating system. For example, for Windows 2000, the minor version number is zero
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.dwBuildNumber">
            <summary>
            The build number of the operating system.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.dwPlatformId">
            <summary>
            The operating system platform. For Win32 on NT-based operating systems, RtlGetVersion returns the value
            VER_PLATFORM_WIN32_NT.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.szCSDVersion">
            <summary>
            The service-pack version string. This member contains a null-terminated string, such as "Service Pack 3", which
            indicates the latest service pack installed on the system. If no service pack is installed, RtlGetVersion might not
            initialize this string. Initialize szCSDVersion to zero (empty string) before the call to RtlGetVersion.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.wServicePackMajor">
            <summary>
            The major version number of the latest service pack installed on the system. For example, for Service Pack 3,
            the major version number is three. If no service pack has been installed, the value is zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.wServicePackMinor">
            <summary>
            The minor version number of the latest service pack installed on the system. For example, for Service Pack 3,
            the minor version number is zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.wSuiteMask">
            <summary>
            The product suites available on the system. This member is set to zero or to the bitwise OR of one or more of
            the <see cref="T:PInvoke.Kernel32.PRODUCT_SUITE"/> values.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.wProductType">
            <summary>
            The product type. This member contains additional information about the system.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.wReserved">
            <summary>
            Reserved for future use.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.OSVERSIONINFOEX.Create">
            <summary>
            Helper method to create <see cref="T:PInvoke.Kernel32.OSVERSIONINFOEX"/> with
            the right pre-initialization for <see cref="F:PInvoke.Kernel32.OSVERSIONINFOEX.dwOSVersionInfoSize"/>
            </summary>
            <returns>A newly initialzed instance of <see cref="T:PInvoke.Kernel32.OSVERSIONINFOEX"/></returns>
        </member>
        <member name="T:PInvoke.Kernel32.OS_TYPE">
            <summary>
            The product type enumeration
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.OVERLAPPED">
            <summary>Contains information used in asynchronous (or overlapped) input and output (I/O).</summary>
            <remarks>
            Any unused members of this structure should always be initialized to zero before the structure is used in a function
            call. Otherwise, the function may fail and return <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_PARAMETER"/>.
            <para>
            The Offset and OffsetHigh members together represent a 64-bit file position.It is a byte offset from the start of
            the file or file-like device, and it is specified by the user; the system will not modify these values.The calling
            process must set this member before passing the OVERLAPPED structure to functions that use an offset, such as the
            ReadFile or WriteFile (and related) functions.
            </para>
            <para>
            You can use the HasOverlappedIoCompleted macro to check whether an asynchronous I/O operation has completed if
            GetOverlappedResult is too cumbersome for your application.
            </para>
            <para>You can use the CancelIo function to cancel an asynchronous I/O operation.</para>
            <para>
            A common mistake is to reuse an OVERLAPPED structure before the previous asynchronous operation has been
            completed. You should use a separate structure for each request. You should also create an event object for each thread
            that processes data. If you store the event handles in an array, you could easily wait for all events to be signaled
            using the WaitForMultipleObjects function.
            </para>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.Internal">
            <summary>
            The status code for the I/O request. When the request is issued, the system sets this member to STATUS_PENDING to indicate that the operation has not yet started. When the request is completed, the system sets this member to the status code for the completed request.
            <para>The Internal member was originally reserved for system use and its behavior may change.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.InternalHigh">
            <summary>
            The number of bytes transferred for the I/O request. The system sets this member if the request is completed without errors.
            <para>The InternalHigh member was originally reserved for system use and its behavior may change.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.Offset">
            <summary>
            The low-order portion of the file position at which to start the I/O request, as specified by the user.
            <para>This member is nonzero only when performing I/O requests on a seeking device that supports the concept of an offset(also referred to as a file pointer mechanism), such as a file.Otherwise, this member must be zero.</para>
            <para>For additional information, see Remarks.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.OffsetHigh">
            <summary>
            The high-order portion of the file position at which to start the I/O request, as specified by the user.
            <para>This member is nonzero only when performing I/O requests on a seeking device that supports the concept of an offset(also referred to as a file pointer mechanism), such as a file.Otherwise, this member must be zero.</para>
            <para>For additional information, see Remarks.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.hEvent">
            <summary>
            A handle to the event that will be set to a signaled state by the system when the operation has completed. The user must initialize this member either to zero or a valid event handle using the CreateEvent function before passing this structure to any overlapped functions. This event can then be used to synchronize simultaneous I/O requests for a device. For additional information, see Remarks.
            <para>Functions such as ReadFile and WriteFile set this handle to the nonsignaled state before they begin an I/O operation.When the operation has completed, the handle is set to the signaled state.</para>
            <para>Functions such as GetOverlappedResult and the synchronization wait functions reset auto-reset events to the nonsignaled state. Therefore, you should use a manual reset event; if you use an auto-reset event, your application can stop responding if you wait for the operation to complete and then call GetOverlappedResult with the bWait parameter set to TRUE.</para>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.PRODUCT_SUITE">
            <summary>
            The product suites available on the system.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_BACKOFFICE">
            <summary>
            Microsoft BackOffice components are installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_BLADE">
            <summary>
            Windows Server 2003, Web Edition is installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_COMPUTE_SERVER">
            <summary>
            Windows Server 2003, Compute Cluster Edition is installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_DATACENTER">
            <summary>
            Windows Server 2008 Datacenter, Windows Server 2003, Datacenter Edition, or Windows 2000 Datacenter Server is installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_ENTERPRISE">
            <summary>
            Windows Server 2008 Enterprise, Windows Server 2003, Enterprise Edition, or Windows 2000 Advanced Server is installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_EMBEDDEDNT">
            <summary>
            Windows XP Embedded is installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_PERSONAL">
            <summary>
            Windows Vista Home Premium, Windows Vista Home Basic, or Windows XP Home Edition is installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SINGLEUSERTS">
            <summary>
            Remote Desktop is supported, but only one interactive session is supported.
            This value is set unless the system is running in application server mode.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS">
            <summary>
            Microsoft Small Business Server was once installed on the system, but may have been upgraded to another version of Windows.
            </summary>
            <remarks>
             You should not rely solely on the <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS"/> flag to determine whether Small Business Server is currently installed.
             Both this flag and the <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS_RESTRICTED"/> flag are set when this product suite is installed. If you upgrade this
             installation to Windows Server, Standard Edition, the <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS_RESTRICTED"/> flag is cleared, but the
             <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS"/> flag remains set, which, in this case, indicates that Small Business Server was previously installed on
             this system. If this installation is further upgraded to Windows Server, Enterprise Edition, the <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS"/> flag
             remains set.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS_RESTRICTED">
            <summary>
            Microsoft Small Business Server is installed with the restrictive client license in force.
            For more information about this flag bit, see the remarks for <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS"/> flag.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_STORAGE_SERVER">
            <summary>
            Windows Storage Server 2003 R2 or Windows Storage Server 2003 is installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_TERMINAL">
            <summary>
            Terminal Services is installed. This value is always set. If <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_TERMINAL"/> is set but <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SINGLEUSERTS"/> is not set,
            the operating system is running in application server mode.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_WH_SERVER">
            <summary>
            Windows Home Server is installed.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.SafeFindFilesHandle">
            <summary>
            Represents a Win32 handle that can be closed with <see cref="M:PInvoke.Kernel32.FindClose(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeFindFilesHandle.Invalid">
            <summary>
            An invalid handle that may be used in place of <see cref="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE"/>.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeFindFilesHandle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeFindFilesHandle"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeFindFilesHandle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeFindFilesHandle"/> class.
            </summary>
            <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
                <see langword="true" /> to have the native handle released when this safe handle is disposed or finalized;
                <see langword="false" /> otherwise.
            </param>
        </member>
        <member name="P:PInvoke.Kernel32.SafeFindFilesHandle.IsInvalid">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.SafeFindFilesHandle.ReleaseHandle">
            <inheritdoc />
        </member>
        <member name="T:PInvoke.Kernel32.SafeLibraryHandle">
            <summary>
            Represents a library handle that can be closed with <see cref="M:PInvoke.Kernel32.FreeLibrary(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeLibraryHandle.Null">
            <summary>
            A handle that may be used in place of <see cref="F:System.IntPtr.Zero"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeLibraryHandle.Invalid">
            <summary>
            An invalid handle that may be used in place of <see cref="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE"/>.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeLibraryHandle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeLibraryHandle"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeLibraryHandle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeLibraryHandle"/> class.
            </summary>
            <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
                <see langword="true" /> to have the native handle released when this safe handle is disposed or finalized;
                <see langword="false" /> otherwise.
            </param>
        </member>
        <member name="P:PInvoke.Kernel32.SafeLibraryHandle.IsInvalid">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.SafeLibraryHandle.ReleaseHandle">
            <inheritdoc />
        </member>
        <member name="T:PInvoke.Kernel32.SafeObjectHandle">
            <summary>
            Represents a Win32 handle that can be closed with <see cref="M:PInvoke.Kernel32.CloseHandle(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeObjectHandle.Invalid">
            <summary>
            An invalid handle that may be used in place of <see cref="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeObjectHandle.Null">
            <summary>
            A handle that may be used in place of <see cref="F:System.IntPtr.Zero"/>.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeObjectHandle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeObjectHandle"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeObjectHandle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeObjectHandle"/> class.
            </summary>
            <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
                <see langword="true" /> to have the native handle released when this safe handle is disposed or finalized;
                <see langword="false" /> otherwise.
            </param>
        </member>
        <member name="P:PInvoke.Kernel32.SafeObjectHandle.IsInvalid">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.SafeObjectHandle.ReleaseHandle">
            <inheritdoc />
        </member>
        <member name="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES">
            <summary>
            The SECURITY_ATTRIBUTES structure contains the security descriptor for an object and specifies whether the handle retrieved by specifying this structure is inheritable. This structure provides security settings for objects created by various functions, such as CreateFile, CreatePipe, CreateProcess, RegCreateKeyEx, or RegSaveKeyEx.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.nLength">
            <summary>
            The size, in bytes, of this structure.
            This value is set by the constructor to the size of the <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor">
            <summary>
            A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_DESCRIPTOR"/> structure that controls access to the object. If the value of this member is NULL, the object is assigned the default security descriptor associated with the access token of the calling process. This is not the same as granting access to everyone by assigning a NULL discretionary access control list (DACL). By default, the default DACL in the access token of a process allows access only to the user represented by the access token.
            For information about creating a security descriptor, see Creating a Security Descriptor.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.bInheritHandle">
            <summary>
            A Boolean value that specifies whether the returned handle is inherited when a new process is created. If this member is TRUE, the new process inherits the handle.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.SECURITY_ATTRIBUTES.InheritHandle">
            <summary>
            Gets a value indicating whether the returned handle is inherited when a new process is created. If this member is TRUE, the new process inherits the handle.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SECURITY_ATTRIBUTES.Create">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> struct.
            </summary>
            <returns>A new instance of <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/>.</returns>
        </member>
        <member name="T:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL">
            <summary>
            Contains values that specify security impersonation levels. Security impersonation levels govern the degree to which a server process can act on behalf of a client process.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL.SecurityAnonymous">
            <summary>
            The server process cannot obtain identification information about the client, and it cannot impersonate the client. It is defined with no value given, and thus, by ANSI C rules, defaults to a value of zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL.SecurityIdentification">
            <summary>
            The server process can obtain information about the client, such as security identifiers and privileges, but it cannot impersonate the client. This is useful for servers that export their own objects, for example, database products that export tables and views. Using the retrieved client-security information, the server can make access-validation decisions without being able to use other services that are using the client's security context.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation">
            <summary>
            The server process can impersonate the client's security context on its local system. The server cannot impersonate the client on remote systems.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL.SecurityDelegation">
            <summary>
            The server process can impersonate the client's security context on remote systems.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.SYSTEMTIME">
            <summary>
            Specifies a date and time, using individual members for the month, day, year, weekday, hour, minute, second, and millisecond.
            The time is either in coordinated universal time (UTC) or local time, depending on the function that is being called.
            </summary>
            <remarks>
            It is not recommended that you add and subtract values from the <see cref="T:PInvoke.Kernel32.SYSTEMTIME"/> structure to obtain relative times.
            Instead, you should
            Convert the <see cref="T:PInvoke.Kernel32.SYSTEMTIME"/> structure to a <see cref="T:PInvoke.Kernel32.FILETIME"/> structure.
            <list type="bullet">
            <item>
            <desccription>Copy the resulting <see cref="T:PInvoke.Kernel32.FILETIME"/> structure to a ULARGE_INTEGER structure.</desccription>
            </item>
            <item>
            <desccription>Use normal 64-bit arithmetic on the ULARGE_INTEGER value.</desccription>
            </item>
            <item>
            <description>The system can periodically refresh the time by synchronizing with a time source.</description>
            </item>
            </list>
            Because the system time can be adjusted either forward or backward, do not compare system time readings to determine elapsed time.
            Instead, use one of the methods described in Windows Time.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wYear">
            <summary>
            The year. The valid values for this member are 1601 through 30827.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wMonth">
            <summary>
            The month. This member can be one of the following values.
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>1</term>
            <term>January</term>
            </item>
            <item>
            <term>2</term>
            <term>February</term>
            </item>
            <item>
            <term>3</term>
            <term>March</term>
            </item>
            <item>
            <term>4</term>
            <term>April</term>
            </item>
            <item>
            <term>5</term>
            <term>May</term>
            </item>
            <item>
            <term>6</term>
            <term>June</term>
            </item>
            <item>
            <term>7</term>
            <term>July</term>
            </item>
            <item>
            <term>8</term>
            <term>August</term>
            </item>
            <item>
            <term>9</term>
            <term>September</term>
            </item>
            <item>
            <term>10</term>
            <term>October</term>
            </item>
            <item>
            <term>11</term>
            <term>November</term>
            </item>
            <item>
            <term>12</term>
            <term>December</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wDayOfWeek">
            <summary>
            The day of the week. This member can be one of the following values.
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>Sunday</term>
            </item>
            <item>
            <term>1</term>
            <term>Monday</term>
            </item>
            <item>
            <term>2</term>
            <term>Tuesday</term>
            </item>
            <item>
            <term>3</term>
            <term>Wednesday</term>
            </item>
            <item>
            <term>4</term>
            <term>Thursday</term>
            </item>
            <item>
            <term>5</term>
            <term>Friday</term>
            </item>
            <item>
            <term>6</term>
            <term>Saturday</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wDay">
            <summary>
            The day of the month. The valid values for this member are 1 through 31.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wHour">
            <summary>
            The hour. The valid values for this member are 0 through 23.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wMinute">
            <summary>
            The minute. The valid values for this member are 0 through 59.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wSecond">
            <summary>
            The second. The valid values for this member are 0 through 59.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wMilliseconds">
            <summary>
            The millisecond. The valid values for this member are 0 through 999.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.VER_CONDITION">
            <summary>
            The operator to be used for the comparison. The <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function uses this operator to compare a specified
            attribute value to the corresponding value for the currently running system.
            </summary>
            <remarks>
            For all values of dwTypeBitMask other than VER_SUITENAME, this parameter can be one of the following values:
                - <see cref="F:PInvoke.Kernel32.VER_CONDITION.VER_EQUAL"/>
                - <see cref="F:PInvoke.Kernel32.VER_CONDITION.VER_GREATER"/>
                - <see cref="F:PInvoke.Kernel32.VER_CONDITION.VER_GREATER_EQUAL"/>
                - <see cref="F:PInvoke.Kernel32.VER_CONDITION.VER_LESS"/>
                - <see cref="F:PInvoke.Kernel32.VER_CONDITION.VER_LESS_EQUAL"/>
            If dwTypeBitMask is VER_SUITENAME, this parameter can be one of the following values:
                - <see cref="F:PInvoke.Kernel32.VER_CONDITION.VER_AND"/>
                - <see cref="F:PInvoke.Kernel32.VER_CONDITION.VER_OR"/>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.VER_CONDITION.VER_EQUAL">
            <summary>
            The current value must be equal to the specified value.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_CONDITION.VER_GREATER">
            <summary>
            The current value must be greater than the specified value.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_CONDITION.VER_GREATER_EQUAL">
            <summary>
            The current value must be greater than or equal to the specified value.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_CONDITION.VER_LESS">
            <summary>
            The current value must be less than the specified value.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_CONDITION.VER_LESS_EQUAL">
            <summary>
            The current value must be less than or equal to the specified value.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_CONDITION.VER_AND">
            <summary>
            All product suites specified in the wSuiteMask member must be present in the current system.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_CONDITION.VER_OR">
            <summary>
            At least one of the specified product suites must be present in the current system.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.VER_MASK">
            <summary>
            A mask that indicates the member of the <see cref="T:PInvoke.Kernel32.OSVERSIONINFOEX"/> structure whose comparison operator is being set.
            This value corresponds to one of the bits specified in the dwTypeMask parameter for the <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_BUILDNUMBER">
            <summary>
            dwBuildNumber
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_MAJORVERSION">
            <summary>
            dwBuildNumber
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_MINORVERSION">
            <summary>
            dwMinorVersion
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_PLATFORMID">
            <summary>
            dwPlatformId
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_PRODUCT_TYPE">
            <summary>
            wProductType
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_SERVICEPACKMAJOR">
            <summary>
            wServicePackMajor
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_SERVICEPACKMINOR">
            <summary>
            wServicePackMinor
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_SUITENAME">
            <summary>
            wSuiteMask
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.WaitForSingleObjectResult">
            <summary>
            Values that may be returned from the <see cref="M:PInvoke.Kernel32.WaitForSingleObject(System.Runtime.InteropServices.SafeHandle,System.Int32)"/> function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WaitForSingleObjectResult.WAIT_ABANDONED">
            <summary>
            The specified object is a mutex object that was not released by the thread that owned the mutex object before the owning thread terminated. Ownership of the mutex object is granted to the calling thread and the mutex state is set to nonsignaled.
            If the mutex was protecting persistent state information, you should check it for consistency.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WaitForSingleObjectResult.WAIT_OBJECT_0">
            <summary>
            The state of the specified object is signaled.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WaitForSingleObjectResult.WAIT_TIMEOUT">
            <summary>
            The time-out interval elapsed, and the object's state is nonsignaled.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WaitForSingleObjectResult.WAIT_FAILED">
            <summary>
            The function has failed. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.dwFileAttributes">
            <summary>
            The file attributes of a file.
            </summary>
            <remarks>
            Although the enum we bind to here exists in the .NET Framework
            as System.IO.FileAttributes, it is not reliably present.
            Portable profiles don't include it, for example. So we have to define our own.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.ftCreationTime">
            <summary>
            A FILETIME structure that specifies when a file or directory was created.
            If the underlying file system does not support creation time, this member is zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.ftLastAccessTime">
            <summary>
            A FILETIME structure.
            For a file, the structure specifies when the file was last read from, written to, or for executable files, run.
            For a directory, the structure specifies when the directory is created.If the underlying file system does not support last access time, this member is zero.
            On the FAT file system, the specified date for both files and directories is correct, but the time of day is always set to midnight.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.ftLastWriteTime">
            <summary>
            A FILETIME structure.
            For a file, the structure specifies when the file was last written to, truncated, or overwritten, for example, when WriteFile or SetEndOfFile are used.The date and time are not updated when file attributes or security descriptors are changed.
            For a directory, the structure specifies when the directory is created.If the underlying file system does not support last write time, this member is zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.nFileSizeHigh">
            <summary>
            The high-order DWORD value of the file size, in bytes.
            This value is zero unless the file size is greater than MAXDWORD.
            The size of the file is equal to(nFileSizeHigh* (MAXDWORD+1)) + nFileSizeLow.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.nFileSizeLow">
            <summary>
            The low-order DWORD value of the file size, in bytes.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.dwReserved0">
            <summary>
            If the dwFileAttributes member includes the FILE_ATTRIBUTE_REPARSE_POINT attribute, this member specifies the reparse point tag.
            Otherwise, this value is undefined and should not be used.
            For more information see Reparse Point Tags.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.dwReserved1">
            <summary>
            Reserved for future use.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.cFileName">
            <summary>
            The name of the file.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.cAlternateFileName">
            <summary>
            An alternative name for the file.
            This name is in the classic 8.3 file name format.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MAX_MODULE_NAME32">
            <summary>
            The maximum length of a name for a process module.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MAX_PATH">
            <summary>
            The maximum length of file paths for most Win32 functions.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE">
            <summary>
            Constant for invalid handle value
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.FindFirstFileEx(System.String,PInvoke.Kernel32.FINDEX_INFO_LEVELS,PInvoke.Kernel32.WIN32_FIND_DATA@,PInvoke.Kernel32.FINDEX_SEARCH_OPS,System.Void*,PInvoke.Kernel32.FindFirstFileExFlags)">
            <summary>
            Searches a directory for a file or subdirectory with a name and attributes that match those specified.
            For the most basic version of this function, see FindFirstFile.
            To perform this operation as a transacted operation, use the FindFirstFileTransacted function.
            </summary>
            <param name="lpFileName">
            The directory or path, and the file name, which can include wildcard characters, for example, an asterisk (*) or a question mark (?).
            This parameter should not be NULL, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\).
            If the string ends with a wildcard, period, or directory name, the user must have access to the root and all subdirectories on the path.
            In the ANSI version of this function, the name is limited to MAX_PATH characters. To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming a File.
            </param>
            <param name="fInfoLevelId">
            The information level of the returned data.
            This parameter is one of the <see cref="T:PInvoke.Kernel32.FINDEX_INFO_LEVELS"/> enumeration values.
            </param>
            <param name="lpFindFileData">
            A pointer to the buffer that receives the file data.
            The pointer type is determined by the level of information that is specified in the <paramref name="fInfoLevelId"/> parameter.
            </param>
            <param name="fSearchOp">
            The type of filtering to perform that is different from wildcard matching.
            This parameter is one of the <see cref="T:PInvoke.Kernel32.FINDEX_SEARCH_OPS"/> enumeration values.
            </param>
            <param name="lpSearchFilter">
            A pointer to the search criteria if the specified <paramref name="fSearchOp"/> needs structured search information.
            At this time, none of the supported fSearchOp values require extended search information. Therefore, this pointer must be NULL.
            </param>
            <param name="dwAdditionalFlags">Specifies additional flags that control the search.</param>
            <returns>
            If the function succeeds, the return value is a search handle used in a subsequent call to FindNextFile or FindClose, and the lpFindFileData parameter contains information about the first file or directory found.
            If the function fails or fails to locate files from the search string in the lpFileName parameter, the return value is INVALID_HANDLE_VALUE and the contents of lpFindFileData are indeterminate.To get extended error information, call the <see cref="M:PInvoke.Kernel32.GetLastError"/> function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.Text.StringBuilder,System.Int32,System.IntPtr[])">
            <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested.
            </summary>
            <param name="dwFlags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
            <param name="lpSource">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name="dwFlags"/> parameter.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name="dwMessageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
            </param>
            <param name="dwLanguageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name="lpBuffer">
            A pointer to a buffer that receives the null-terminated string that specifies the formatted message. If dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER" />, the function allocates a buffer using the LocalAlloc function, and places the pointer to the buffer at the address specified in lpBuffer.
            This buffer cannot be larger than 64K bytes.
            </param>
            <param name="nSize">
            If the <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> flag is not set, this parameter specifies the size of the output buffer, in TCHARs. If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> is set,
            this parameter specifies the minimum number of TCHARs to allocate for an output buffer.
            The output buffer cannot be larger than 64K bytes.
            </param>
            <param name="Arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <returns>
            If the function succeeds, the return value is the number of TCHARs stored in the output buffer, excluding the terminating null character.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetCurrentThreadId">
            <summary>
            Retrieves the thread identifier of the calling thread.
            </summary>
            <returns>The thread identifier of the calling thread.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetCurrentProcessId">
            <summary>Retrieves the process identifier of the calling process.</summary>
            <returns>The process identifier of the calling process.</returns>
            <remarks>Until the process terminates, the process identifier uniquely identifies the process throughout the system.</remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetProcessId(System.IntPtr)">
            <summary>
            Retrieves the process identifier of the specified process.
            </summary>
            <param name="Process">A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see Process Security and Access Rights.</param>
            <returns>The process identifier of the specified process.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetCurrentProcess">
            <summary>Retrieves a pseudo handle for the current process.</summary>
            <returns>The return value is a pseudo handle to the current process.</returns>
            <remarks>
                A pseudo handle is a special constant, currently (HANDLE)-1, that is interpreted as the current process handle. For
                compatibility with future operating systems, it is best to call GetCurrentProcess instead of hard-coding this
                constant value. The calling process can use a pseudo handle to specify its own process whenever a process handle is
                required. Pseudo handles are not inherited by child processes.
                <para>This handle has the PROCESS_ALL_ACCESS access right to the process object.</para>
                <para>
                    Windows Server 2003 and Windows XP:  This handle has the maximum access allowed by the security descriptor of
                    the process to the primary token of the process.
                </para>
                <para>
                    A process can create a "real" handle to itself that is valid in the context of other processes, or that can
                    be inherited by other processes, by specifying the pseudo handle as the source handle in a call to the
                    DuplicateHandle function. A process can also use the OpenProcess function to open a real handle to itself.
                </para>
                <para>
                    The pseudo handle need not be closed when it is no longer needed. Calling the <see cref="M:PInvoke.Kernel32.CloseHandle(System.IntPtr)" />
                    function with a pseudo handle has no effect.If the pseudo handle is duplicated by DuplicateHandle, the
                    duplicate handle must be closed.
                </para>
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.CancelIoEx(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Marks any outstanding I/O operations for the specified file handle. The function only cancels I/O operations
                in the current process, regardless of which thread created the I/O operation.
            </summary>
            <param name="hFile">A handle to the file.</param>
            <param name="lpOverlapped">
                A pointer to an <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> data structure that contains the data used for asynchronous I/O.
                <para>If this parameter is NULL, all I/O requests for the hFile parameter are canceled.</para>
                <para>
                    If this parameter is not NULL, only those specific I/O requests that were issued for the file with the
                    specified
                    <paramref name="lpOverlapped" /> overlapped structure are marked as canceled, meaning that you can cancel one
                    or more requests, while the CancelIo function cancels all outstanding requests on a file handle.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is nonzero. The cancel operation for all pending I/O operations issued
                by the calling process for the specified file handle was successfully requested. The application must not free or
                reuse the <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure associated with the canceled I/O operations until they have
                completed. The thread can use the GetOverlappedResult function to determine when the I/O operations themselves have
                been completed.
                <para>
                    If the function fails, the return value is 0 (zero). To get extended error information, call the
                    <see cref="M:PInvoke.Kernel32.GetLastError" /> function.
                </para>
                <para>
                    If this function cannot find a request to cancel, the return value is 0 (zero), and
                    <see cref="M:PInvoke.Kernel32.GetLastError" />
                    returns <see cref="F:PInvoke.Win32ErrorCode.ERROR_NOT_FOUND" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file
                pointer if supported by the device.
                <para>
                    This function is designed for both synchronous and asynchronous operations. For a similar function designed
                    solely for asynchronous operation, see ReadFileEx.
                </para>
            </summary>
            <param name="hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive,
                socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
                <para>
                    For asynchronous read operations, hFile can be any handle that is opened with the FILE_FLAG_OVERLAPPED flag
                    by the CreateFile function, or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name="lpBuffer">
                A pointer to the buffer that receives the data read from a file or device.
                <para>
                    This buffer must remain valid for the duration of the read operation. The caller must not use this buffer
                    until the read operation is completed.
                </para>
            </param>
            <param name="nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <param name="lpNumberOfBytesRead">
                A pointer to the variable that receives the number of bytes read when using a synchronous hFile parameter. ReadFile
                sets this value to zero before doing any work or error checking. Use <see langword="null" /> for this parameter if
                this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be <see langword="null" /> only when the <paramref name="lpOverlapped" /> parameter is not
                    <see langword="null" />.
                </para>
            </param>
            <param name="lpOverlapped">
                A pointer to an <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise it can be <see langword="null" />.
                <para>
                    If hFile is opened with FILE_FLAG_OVERLAPPED, the <paramref name="lpOverlapped" /> parameter must point to a
                    valid and unique <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure, otherwise the function can incorrectly report that the
                    read operation is complete.
                </para>
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start reading from the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword="true" />.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword="false" />. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref="M:PInvoke.Kernel32.GetLastError" /> code <see cref="F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING" /> is not a failure;
                    it designates the read operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Writes data to the specified file or input/output (I/O) device.
                <para>
                    This function is designed for both synchronous and asynchronous operation. For a similar function designed
                    solely for asynchronous operation, see WriteFileEx.
                </para>
            </summary>
            <param name="hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
                <para>
                    For asynchronous write operations, hFile can be any handle opened with the CreateFile function using the
                    FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name="lpBuffer">
                A pointer to the buffer containing the data to be written to the file or device.
                <para>
                    This buffer must remain valid for the duration of the write operation. The caller must not use this buffer
                    until the write operation is completed.
                </para>
            </param>
            <param name="nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <param name="lpNumberOfBytesWritten">
                A pointer to the variable that receives the number of bytes written when using a synchronous hFile parameter.
                WriteFile sets this value to zero before doing any work or error checking. Use <see langword="null" />
                for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be NULL only when the <paramref name="lpOverlapped" /> parameter is not
                    <see langword="null" />.
                </para>
            </param>
            <param name="lpOverlapped">
                A pointer to an <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise this parameter can be NULL.
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start writing to the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
                <para>
                    To write to the end of file, specify both the Offset and OffsetHigh members of the <see cref="T:PInvoke.Kernel32.OVERLAPPED" />
                    structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function to open
                    hFile using FILE_APPEND_DATA access.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword="true" />.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword="false" />. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref="M:PInvoke.Kernel32.GetLastError" /> code <see cref="F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING" /> is not a failure;
                    it designates the write operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SuspendThread(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Suspends the specified thread.
            A 64-bit application can suspend a WOW64 thread using the Wow64SuspendThread function (desktop only).
            </summary>
            <param name="hThread">
            A handle to the thread that is to be suspended.
            The handle must have the THREAD_SUSPEND_RESUME access right. For more information, see Thread Security and Access Rights.
            </param>
            <returns>
            If the function succeeds, the return value is the thread's previous suspend count; otherwise, it is (DWORD) -1. To get extended error information, use the <see cref="M:PInvoke.Kernel32.GetLastError"/> function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ResumeThread(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Decrements a thread's suspend count. When the suspend count is decremented to zero, the execution of the thread is resumed.
            </summary>
            <param name="hThread">
            A handle to the thread to be restarted.
            This handle must have the THREAD_SUSPEND_RESUME access right. For more information, see Thread Security and Access Rights.
            </param>
            <returns>
            If the function succeeds, the return value is the thread's previous suspend count.
            If the function fails, the return value is (DWORD) -1. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WaitForSingleObject(System.Runtime.InteropServices.SafeHandle,System.Int32)">
            <summary>
            Waits until the specified object is in the signaled state or the time-out interval elapses.
            To enter an alertable wait state, use the WaitForSingleObjectEx function. To wait for multiple objects, use WaitForMultipleObjects.
            </summary>
            <param name="hHandle">
            A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section.
            If this handle is closed while the wait is still pending, the function's behavior is undefined.
            The handle must have the SYNCHRONIZE access right. For more information, see Standard Access Rights.
            </param>
            <param name="dwMilliseconds">
            The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is signaled or the interval elapses. If dwMilliseconds is zero, the function does not enter a wait state if the object is not signaled; it always returns immediately. If dwMilliseconds is INFINITE, the function will return only when the object is signaled.
            See MSDN docs for more information.
            </param>
            <returns>
            If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CloseHandle(System.IntPtr)">
            <summary>
            Closes an open object handle.
            </summary>
            <param name="hObject">A valid handle to an open object.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero.To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FlushFileBuffers(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>Flushes the buffers of a specified file and causes all buffered data to be written to a file.</summary>
            <param name="hFile">
                A handle to the open file.
                <para>
                    The file handle must have the GENERIC_WRITE access right. For more information, see File Security and Access
                    Rights.
                </para>
                <para>If hFile is a handle to a communications device, the function only flushes the transmit buffer.</para>
                <para>
                    If hFile is a handle to the server end of a named pipe, the function does not return until the client has
                    read all buffered data from the pipe.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
                <para>
                    The function fails if hFile is a handle to the console output. That is because the console output is not
                    buffered. The function returns FALSE, and <see cref="M:PInvoke.Kernel32.GetLastError" /> returns
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_HANDLE" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateMutex(PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,System.String)">
            <summary>
            Creates or opens a named or unnamed mutex object.
            </summary>
            <param name="lpMutexAttributes">
            A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure. If this parameter is NULL, the handle cannot be inherited by child processes.
            The <see cref="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a security descriptor for the new mutex. If <paramref name="lpMutexAttributes"/> is NULL, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see Synchronization Object Security and Access Rights.
            </param>
            <param name="bInitialOwner">
            If this value is TRUE and the caller created the mutex, the calling thread obtains initial ownership of the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the caller created the mutex, see the Return Values section.
            </param>
            <param name="lpName">
            The name of the mutex object. The name is limited to MAX_PATH characters. Name comparison is case sensitive.
            If lpName matches the name of an existing named mutex object, this function requests the MUTEX_ALL_ACCESS access right. In this case, the bInitialOwner parameter is ignored because it has already been set by the creating process. If the lpMutexAttributes parameter is not NULL, it determines whether the handle can be inherited, but its security-descriptor member is ignored.
            If lpName is NULL, the mutex object is created without a name.
            If lpName matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the GetLastError function returns ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace.
            The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see Kernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.
            The object can be created in a private namespace. For more information, see Object Namespaces.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the newly created mutex object.
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, GetLastError returns ERROR_ALREADY_EXISTS, bInitialOwner is ignored, and the calling thread is not granted ownership. However, if the caller has limited access rights, the function will fail with ERROR_ACCESS_DENIED and the caller should use the OpenMutex function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetProcAddress(PInvoke.Kernel32.SafeLibraryHandle,System.String)">
            <summary>
            Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).
            </summary>
            <param name="hModule">A handle to the DLL module that contains the function or variable. The LoadLibrary, LoadLibraryEx, or GetModuleHandle function returns this handle.</param>
            <param name="procName">The function or variable name, or the function's ordinal value. If this parameter is an ordinal value, it must be in the low-order word; the high-order word must be zero.</param>
            <returns>
            If the function succeeds, the return value is the address of the exported function or variable.
            If the function fails, the return value is NULL.To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>This function does not retrieve handles for modules that were loaded using the LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE flag.</remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetTickCount">
            <summary>
            Retrieves the number of milliseconds that have elapsed since the system was started, up to 49.7 days.
            </summary>
            <returns>The return value is the number of milliseconds that have elapsed since the system was started.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetTickCount64">
            <summary>
            Retrieves the number of milliseconds that have elapsed since the system was started.
            </summary>
            <returns>The number of milliseconds.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetSystemTime(PInvoke.Kernel32.SYSTEMTIME*)">
            <summary>
            Retrieves the current system date and time. The system time is expressed in Coordinated Universal Time (UTC).
            To retrieve the current system date and time in local time, use the GetLocalTime function.
            </summary>
            <param name="lpSystemTime">
            A pointer to a SYSTEMTIME structure to receive the current system date and time.
            The lpSystemTime parameter must not be NULL. Using NULL will result in an access violation.
            </param>
        </member>
        <member name="M:PInvoke.Kernel32.SetLastError(System.UInt32)">
            <summary>
            Sets the last-error code for the calling thread.
            </summary>
            <param name="dwErrCode">The last-error code for the thread.</param>
        </member>
        <member name="M:PInvoke.Kernel32.VerSetConditionMask(System.Int64,PInvoke.Kernel32.VER_MASK,PInvoke.Kernel32.VER_CONDITION)">
            <summary>
            Sets the bits of a 64-bit value to indicate the comparison operator to use for a specified operating system version
            attribute. This function is used to build the dwlConditionMask parameter of the <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function.
            </summary>
            <param name="ConditionMask">A value to be passed as the dwlConditionMask parameter of the <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function.
            The function stores the comparison information in the bits of this variable. Before the first call to <see cref="M:PInvoke.Kernel32.VerSetConditionMask(System.Int64,PInvoke.Kernel32.VER_MASK,PInvoke.Kernel32.VER_CONDITION)"/>,
            initialize this variable to zero. For subsequent calls, pass in the variable used in the previous call.</param>
            <param name="TypeMask">A mask that indicates the member of the <see cref="T:PInvoke.Kernel32.OSVERSIONINFOEX"/> structure whose comparison operator
            is being set. This value corresponds to one of the bits specified in the dwTypeMask parameter for the
            <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function</param>
            <param name="Condition">The operator to be used for the comparison. The <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function uses this
            operator to compare a specified attribute value to the corresponding value for the currently running system.</param>
            <returns>The function returns the condition mask value.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)">
             <summary>
             Compares a set of operating system version requirements to the corresponding values for the currently
             running version of the system.This function is subject to manifest-based behavior.
             </summary>
             <param name="lpVersionInformation">
             A pointer to an OSVERSIONINFOEX structure containing the operating system version requirements to compare. The <paramref name="dwTypeMask"/>
             parameter indicates the members of this structure that contain information to compare.You must set the
             <see cref="F:PInvoke.Kernel32.OSVERSIONINFOEX.dwOSVersionInfoSize"/> member of this structure to <code>Marshal.SizeOf(typeof(OSVERSIONINFOEX))</code>. You must
             also specify valid data for the members indicated by <paramref name="dwTypeMask"/>. The function ignores structure members for which the
             corresponding <paramref name="dwTypeMask"/> bit is not set
             </param>
             <param name="dwTypeMask">A mask that indicates the members of the <see cref="T:PInvoke.Kernel32.OSVERSIONINFOEX"/> structure to be tested.</param>
             <param name="dwlConditionMask">The type of comparison to be used for each <paramref name="lpVersionInformation"/> member being compared. To build this value,
             call the <see cref="M:PInvoke.Kernel32.VerSetConditionMask(System.Int64,PInvoke.Kernel32.VER_MASK,PInvoke.Kernel32.VER_CONDITION)"/> function once for each <see cref="T:PInvoke.Kernel32.OSVERSIONINFOEX"/> member being compared.</param>
             <returns>
             <para>
             If the currently running operating system satisfies the specified requirements, the return value is a nonzero value.
             </para>
             <para>
             If the current system does not satisfy the requirements, the return value is zero and <see cref="M:PInvoke.Kernel32.GetLastError"/> returns <see cref="F:PInvoke.Win32ErrorCode.ERROR_OLD_WIN_VERSION"/>.
             </para>
             <para>
             If the function fails, the return value is zero and <see cref="M:PInvoke.Kernel32.GetLastError"/> returns an error code other than <see cref="F:PInvoke.Win32ErrorCode.ERROR_OLD_WIN_VERSION"/>.
             </para>
             </returns>
             <remarks>
             <para>
             The <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function retrieves version information about the currently running operating system and compares it to the valid
             members of the <paramref name="lpVersionInformation"/> structure. This enables you to easily determine the presence of a required set of
             operating system version conditions. It is preferable to use <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> rather than
             calling the GetVersionEx function to perform your own comparisons.
             </para>
             <para>
             Typically, <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> returns a nonzero value only if all specified tests succeed.
             However, major, minor, and service pack versions are tested in a hierarchical manner because the operating system version is a combination of
             these values. If a condition exists for the major version, it supersedes the conditions specified for minor version and service pack version.
             (You cannot test for major version greater than 5 and minor version less than or equal to 1. If you specify such a test, the function will
             change the request to test for a minor version greater than 1 because it is performing a greater than operation on the major version.)
             </para>
             <para>
             The function tests these values in this order: major version, minor version, and service pack version.The function continues testing values while
             they are equal, and stops when one of the values does not meet the specified condition.For example, if you test for a system greater than or
             equal to version 5.1 service pack 1, the test succeeds if the current version is 6.0. (The major version is greater than the specified version,
             so the testing stops.) In the same way, if you test for a system greater than or equal to version 5.1 service pack 1, the test succeeds if the
             current version is 5.2. (The minor version is greater than the specified versions, so the testing stops.) However, if you test for a system greater
             than or equal to version 5.1 service pack 1, the test fails if the current version is 5.0 service pack 2. (The minor version is not greater than
             the specified version, so the testing stops.)
             </para>
             <para>
             To verify a range of system versions, you must call <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> twice.For example, to verify
             that the system version is greater than 5.0 but less than or equal to 5.1, first call <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> to
             test that the major version is 5 and the minor version is greater than 0, then call <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
             again to test that the major version is 5 and the minor version is less than or equal to 1.
             </para>
             <para>
             Identifying the current operating system is usually not the best way to determine whether a particular operating system feature is present.
             This is because the operating system may have had new features added in a redistributable DLL. Rather than using GetVersionEx to determine the operating
             system platform or version number, test for the presence of the feature itself.
             </para>
             <para>
             To verify whether the current operating system is either the Media Center or Tablet PC version of Windows, call GetSystemMetrics.
             </para>
             <para>
             Windows 10:
                 <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> returns false when called by applications that do not have a
                 compatibility manifest for Windows 8.1 or Windows 10 if the <paramref name="lpVersionInformation"/> parameter is set so that it specifies
                 Windows 8.1 or Windows 10, even when the current operating system version is Windows 8.1 or Windows 10. Specifically,
                 <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> has the following behavior:
            
                 If the application has no manifest, <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> behaves as
                     if the operation system version is Windows 8 (6.2).
                 If the application has a manifest that contains the GUID that corresponds to Windows 8.1, <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
                     behaves as if the operation system version is Windows 8.1 (6.3).
                 If the application has a manifest that contains the GUID that corresponds to Windows 10, <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
                     behaves as if the operation system version is Windows 10 (10.0).
             </para>
             </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.FindClose(System.IntPtr)">
            <summary>
                Closes a file search handle opened by the FindFirstFile, FindFirstFileEx, FindFirstFileNameW,
                FindFirstFileNameTransactedW, FindFirstFileTransacted, FindFirstStreamTransactedW, or FindFirstStreamW functions.
            </summary>
            <param name="hFindFile">The file search handle.</param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FreeLibrary(System.IntPtr)">
            <summary>
                Frees the loaded dynamic-link library (DLL) module and, if necessary, decrements its reference count. When the
                reference count reaches zero, the module is unloaded from the address space of the calling process and the handle
                is no longer valid.
            </summary>
            <param name="hModule">
                A handle to the loaded library module. The LoadLibrary, LoadLibraryEx, GetModuleHandle, or
                GetModuleHandleEx function returns this handle.
            </param>
            <returns>
                If the function succeeds, the return value is a nonzero value.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.IntPtr[],System.Int32)">
            <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested.
            </summary>
            <param name="dwFlags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            The <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ARGUMENT_ARRAY"/> flag is always added
            and the <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> flag is always suppressed by this helper method
            </param>
            <param name="lpSource">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name="dwFlags"/> parameter.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name="dwMessageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
            </param>
            <param name="dwLanguageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name="Arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <param name="maxAllowedBufferSize">The maximum size of the returned string. If exceeded, <c>null</c> is returned.</param>
            <returns>
            If the function succeeds, the return value is the number of TCHARs stored in the output buffer, excluding the terminating null character.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetLastError">
            <summary>
                Returns the error code returned by the last unmanaged function that was called using platform invoke that has
                the <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> flag set.
            </summary>
            <returns>
                The last error code set by a call to the Win32 SetLastError function.
                <para>
                    The Return Value section of the documentation for each function that sets the last-error code notes the
                    conditions under which the function sets the last-error code. Most functions that set the thread's last-error
                    code set it when they fail. However, some functions also set the last-error code when they succeed. If the
                    function is not documented to set the last-error code, the value returned by this function is simply the most
                    recent last-error code to have been set; some functions set the last-error code to
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_SUCCESS" /> on success and others do not.
                </para>
            </returns>
            <remarks>
                This method exists because it is not safe to make a direct platform invoke call to GetLastError to obtain this
                information. If you want to access this error code, you must call <see cref="M:PInvoke.Kernel32.GetLastError" /> instead of writing
                your own platform invoke definition for GetLastError and calling it. The common language runtime can make internal
                calls to APIs that overwrite the GetLastError maintained by the operating system.
                <para>
                    You can use this method to obtain error codes only if you apply the <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> to the
                    method signature and set the <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> field to true. The process for this
                    varies depending upon the source language used: C# and C++ are false by default, but the Declare statement in
                    Visual Basic is true.
                </para>
            </remarks>
            <devremarks>
                See
                https://stackoverflow.com/questions/17918266/winapi-getlasterror-vs-marshal-getlastwin32error/17918729#17918729 for
                more details.
            </devremarks>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)">
            <summary>Writes data synchronously to the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
            </param>
            <param name="lpBuffer">A pointer to the buffer containing the data to be written to the file or device.</param>
            <param name="nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <returns>The number of bytes written.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Write failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.ArraySegment{System.Byte})">
            <summary>Writes data synchronously to the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
            </param>
            <param name="lpBuffer">The buffer containing the data to be written to the file or device.</param>
            <returns>The number of bytes written.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Write failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)">
            <summary>Reads data synchronously from the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer,
                tape drive, socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
            </param>
            <param name="lpBuffer">A pointer to the buffer that receives the data read from a file or device.</param>
            <param name="nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <returns>The number of bytes read.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Read failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.ArraySegment{System.Byte})">
            <summary>Reads data synchronously from the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer,
                tape drive, socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
            </param>
            <param name="lpBuffer">A buffer that receives the data read from a file or device.</param>
            <returns>The number of bytes read.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Read failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Int32)">
            <summary>Reads data synchronously from the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer,
                tape drive, socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
            </param>
            <param name="nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <returns>
                The data that has been read. The segment returned might have a size smaller than
                <paramref name="nNumberOfBytesToRead" /> if less bytes than requested have been read.
            </returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Read failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.TryGetErrorMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.Text.StringBuilder,System.IntPtr[],System.String@)">
            <summary>
            Tries to get the error message text using the supplied buffer.
            </summary>
            <param name="flags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
            <param name="source">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name="flags"/> parameter.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name="messageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
            </param>
            <param name="languageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name="sb">The buffer to use for acquiring the message.</param>
            <param name="arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <param name="errorMsg">Receives the resulting error message.</param>
            <returns><c>true</c> if the attempt is successful; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.FindFirstFileEx(System.String,PInvoke.Kernel32.FINDEX_INFO_LEVELS,PInvoke.Kernel32.WIN32_FIND_DATA@,PInvoke.Kernel32.FINDEX_SEARCH_OPS,System.IntPtr,PInvoke.Kernel32.FindFirstFileExFlags)">
            <summary>
            Searches a directory for a file or subdirectory with a name and attributes that match those specified.
            For the most basic version of this function, see FindFirstFile.
            To perform this operation as a transacted operation, use the FindFirstFileTransacted function.
            </summary>
            <param name = "lpFileName">
            The directory or path, and the file name, which can include wildcard characters, for example, an asterisk (*) or a question mark (?).
            This parameter should not be NULL, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\).
            If the string ends with a wildcard, period, or directory name, the user must have access to the root and all subdirectories on the path.
            In the ANSI version of this function, the name is limited to MAX_PATH characters. To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming a File.
            </param>
            <param name = "fInfoLevelId">
            The information level of the returned data.
            This parameter is one of the <see cref = "T:PInvoke.Kernel32.FINDEX_INFO_LEVELS"/> enumeration values.
            </param>
            <param name = "lpFindFileData">
            A pointer to the buffer that receives the file data.
            The pointer type is determined by the level of information that is specified in the <paramref name = "fInfoLevelId"/> parameter.
            </param>
            <param name = "fSearchOp">
            The type of filtering to perform that is different from wildcard matching.
            This parameter is one of the <see cref = "T:PInvoke.Kernel32.FINDEX_SEARCH_OPS"/> enumeration values.
            </param>
            <param name = "lpSearchFilter">
            A pointer to the search criteria if the specified <paramref name = "fSearchOp"/> needs structured search information.
            At this time, none of the supported fSearchOp values require extended search information. Therefore, this pointer must be NULL.
            </param>
            <param name = "dwAdditionalFlags">Specifies additional flags that control the search.</param>
            <returns>
            If the function succeeds, the return value is a search handle used in a subsequent call to FindNextFile or FindClose, and the lpFindFileData parameter contains information about the first file or directory found.
            If the function fails or fails to locate files from the search string in the lpFileName parameter, the return value is INVALID_HANDLE_VALUE and the contents of lpFindFileData are indeterminate.To get extended error information, call the <see cref = "M:PInvoke.Kernel32.GetLastError"/> function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.IntPtr,System.Int32,System.Int32,System.Text.StringBuilder,System.Int32,System.IntPtr[])">
            <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested.
            </summary>
            <param name = "dwFlags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
            <param name = "lpSource">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name = "dwFlags"/> parameter.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name = "dwMessageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            </param>
            <param name = "dwLanguageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name = "lpBuffer">
            A pointer to a buffer that receives the null-terminated string that specifies the formatted message. If dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/>, the function allocates a buffer using the LocalAlloc function, and places the pointer to the buffer at the address specified in lpBuffer.
            This buffer cannot be larger than 64K bytes.
            </param>
            <param name = "nSize">
            If the <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> flag is not set, this parameter specifies the size of the output buffer, in TCHARs. If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> is set,
            this parameter specifies the minimum number of TCHARs to allocate for an output buffer.
            The output buffer cannot be larger than 64K bytes.
            </param>
            <param name = "Arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <returns>
            If the function succeeds, the return value is the number of TCHARs stored in the output buffer, excluding the terminating null character.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CancelIoEx(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr)">
            <summary>
                Marks any outstanding I/O operations for the specified file handle. The function only cancels I/O operations
                in the current process, regardless of which thread created the I/O operation.
            </summary>
            <param name = "hFile">A handle to the file.</param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> data structure that contains the data used for asynchronous I/O.
                <para>If this parameter is NULL, all I/O requests for the hFile parameter are canceled.</para>
                <para>
                    If this parameter is not NULL, only those specific I/O requests that were issued for the file with the
                    specified
                    <paramref name = "lpOverlapped"/> overlapped structure are marked as canceled, meaning that you can cancel one
                    or more requests, while the CancelIo function cancels all outstanding requests on a file handle.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is nonzero. The cancel operation for all pending I/O operations issued
                by the calling process for the specified file handle was successfully requested. The application must not free or
                reuse the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure associated with the canceled I/O operations until they have
                completed. The thread can use the GetOverlappedResult function to determine when the I/O operations themselves have
                been completed.
                <para>
                    If the function fails, the return value is 0 (zero). To get extended error information, call the
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/> function.
                </para>
                <para>
                    If this function cannot find a request to cancel, the return value is 0 (zero), and
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>
                    returns <see cref = "F:PInvoke.Win32ErrorCode.ERROR_NOT_FOUND"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
                Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file
                pointer if supported by the device.
                <para>
                    This function is designed for both synchronous and asynchronous operations. For a similar function designed
                    solely for asynchronous operation, see ReadFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive,
                socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
                <para>
                    For asynchronous read operations, hFile can be any handle that is opened with the FILE_FLAG_OVERLAPPED flag
                    by the CreateFile function, or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer that receives the data read from a file or device.
                <para>
                    This buffer must remain valid for the duration of the read operation. The caller must not use this buffer
                    until the read operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <param name = "lpNumberOfBytesRead">
                A pointer to the variable that receives the number of bytes read when using a synchronous hFile parameter. ReadFile
                sets this value to zero before doing any work or error checking. Use <see langword = "null"/> for this parameter if
                this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be <see langword = "null"/> only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise it can be <see langword = "null"/>.
                <para>
                    If hFile is opened with FILE_FLAG_OVERLAPPED, the <paramref name = "lpOverlapped"/> parameter must point to a
                    valid and unique <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure, otherwise the function can incorrectly report that the
                    read operation is complete.
                </para>
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start reading from the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the read operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.Nullable{System.Int32}@,System.IntPtr)">
            <summary>
                Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file
                pointer if supported by the device.
                <para>
                    This function is designed for both synchronous and asynchronous operations. For a similar function designed
                    solely for asynchronous operation, see ReadFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive,
                socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
                <para>
                    For asynchronous read operations, hFile can be any handle that is opened with the FILE_FLAG_OVERLAPPED flag
                    by the CreateFile function, or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer that receives the data read from a file or device.
                <para>
                    This buffer must remain valid for the duration of the read operation. The caller must not use this buffer
                    until the read operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <param name = "lpNumberOfBytesRead">
                A pointer to the variable that receives the number of bytes read when using a synchronous hFile parameter. ReadFile
                sets this value to zero before doing any work or error checking. Use <see langword = "null"/> for this parameter if
                this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be <see langword = "null"/> only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise it can be <see langword = "null"/>.
                <para>
                    If hFile is opened with FILE_FLAG_OVERLAPPED, the <paramref name = "lpOverlapped"/> parameter must point to a
                    valid and unique <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure, otherwise the function can incorrectly report that the
                    read operation is complete.
                </para>
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start reading from the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the read operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Nullable{System.Int32}@,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file
                pointer if supported by the device.
                <para>
                    This function is designed for both synchronous and asynchronous operations. For a similar function designed
                    solely for asynchronous operation, see ReadFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive,
                socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
                <para>
                    For asynchronous read operations, hFile can be any handle that is opened with the FILE_FLAG_OVERLAPPED flag
                    by the CreateFile function, or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer that receives the data read from a file or device.
                <para>
                    This buffer must remain valid for the duration of the read operation. The caller must not use this buffer
                    until the read operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <param name = "lpNumberOfBytesRead">
                A pointer to the variable that receives the number of bytes read when using a synchronous hFile parameter. ReadFile
                sets this value to zero before doing any work or error checking. Use <see langword = "null"/> for this parameter if
                this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be <see langword = "null"/> only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise it can be <see langword = "null"/>.
                <para>
                    If hFile is opened with FILE_FLAG_OVERLAPPED, the <paramref name = "lpOverlapped"/> parameter must point to a
                    valid and unique <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure, otherwise the function can incorrectly report that the
                    read operation is complete.
                </para>
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start reading from the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the read operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
                Writes data to the specified file or input/output (I/O) device.
                <para>
                    This function is designed for both synchronous and asynchronous operation. For a similar function designed
                    solely for asynchronous operation, see WriteFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
                <para>
                    For asynchronous write operations, hFile can be any handle opened with the CreateFile function using the
                    FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer containing the data to be written to the file or device.
                <para>
                    This buffer must remain valid for the duration of the write operation. The caller must not use this buffer
                    until the write operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <param name = "lpNumberOfBytesWritten">
                A pointer to the variable that receives the number of bytes written when using a synchronous hFile parameter.
                WriteFile sets this value to zero before doing any work or error checking. Use <see langword = "null"/>
                for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be NULL only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise this parameter can be NULL.
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start writing to the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
                <para>
                    To write to the end of file, specify both the Offset and OffsetHigh members of the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/>
                    structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function to open
                    hFile using FILE_APPEND_DATA access.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the write operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.Nullable{System.Int32}@,System.IntPtr)">
            <summary>
                Writes data to the specified file or input/output (I/O) device.
                <para>
                    This function is designed for both synchronous and asynchronous operation. For a similar function designed
                    solely for asynchronous operation, see WriteFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
                <para>
                    For asynchronous write operations, hFile can be any handle opened with the CreateFile function using the
                    FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer containing the data to be written to the file or device.
                <para>
                    This buffer must remain valid for the duration of the write operation. The caller must not use this buffer
                    until the write operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <param name = "lpNumberOfBytesWritten">
                A pointer to the variable that receives the number of bytes written when using a synchronous hFile parameter.
                WriteFile sets this value to zero before doing any work or error checking. Use <see langword = "null"/>
                for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be NULL only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise this parameter can be NULL.
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start writing to the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
                <para>
                    To write to the end of file, specify both the Offset and OffsetHigh members of the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/>
                    structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function to open
                    hFile using FILE_APPEND_DATA access.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the write operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Nullable{System.Int32}@,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Writes data to the specified file or input/output (I/O) device.
                <para>
                    This function is designed for both synchronous and asynchronous operation. For a similar function designed
                    solely for asynchronous operation, see WriteFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
                <para>
                    For asynchronous write operations, hFile can be any handle opened with the CreateFile function using the
                    FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer containing the data to be written to the file or device.
                <para>
                    This buffer must remain valid for the duration of the write operation. The caller must not use this buffer
                    until the write operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <param name = "lpNumberOfBytesWritten">
                A pointer to the variable that receives the number of bytes written when using a synchronous hFile parameter.
                WriteFile sets this value to zero before doing any work or error checking. Use <see langword = "null"/>
                for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be NULL only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise this parameter can be NULL.
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start writing to the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
                <para>
                    To write to the end of file, specify both the Offset and OffsetHigh members of the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/>
                    structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function to open
                    hFile using FILE_APPEND_DATA access.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the write operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateMutex(System.IntPtr,System.Boolean,System.String)">
            <summary>
            Creates or opens a named or unnamed mutex object.
            </summary>
            <param name = "lpMutexAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure. If this parameter is NULL, the handle cannot be inherited by child processes.
            The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a security descriptor for the new mutex. If <paramref name = "lpMutexAttributes"/> is NULL, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see Synchronization Object Security and Access Rights.
            </param>
            <param name = "bInitialOwner">
            If this value is TRUE and the caller created the mutex, the calling thread obtains initial ownership of the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the caller created the mutex, see the Return Values section.
            </param>
            <param name = "lpName">
            The name of the mutex object. The name is limited to MAX_PATH characters. Name comparison is case sensitive.
            If lpName matches the name of an existing named mutex object, this function requests the MUTEX_ALL_ACCESS access right. In this case, the bInitialOwner parameter is ignored because it has already been set by the creating process. If the lpMutexAttributes parameter is not NULL, it determines whether the handle can be inherited, but its security-descriptor member is ignored.
            If lpName is NULL, the mutex object is created without a name.
            If lpName matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the GetLastError function returns ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace.
            The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see Kernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.
            The object can be created in a private namespace. For more information, see Object Namespaces.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the newly created mutex object.
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, GetLastError returns ERROR_ALREADY_EXISTS, bInitialOwner is ignored, and the calling thread is not granted ownership. However, if the caller has limited access rights, the function will fail with ERROR_ACCESS_DENIED and the caller should use the OpenMutex function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateMutex(System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.Boolean,System.String)">
            <summary>
            Creates or opens a named or unnamed mutex object.
            </summary>
            <param name = "lpMutexAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure. If this parameter is NULL, the handle cannot be inherited by child processes.
            The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a security descriptor for the new mutex. If <paramref name = "lpMutexAttributes"/> is NULL, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see Synchronization Object Security and Access Rights.
            </param>
            <param name = "bInitialOwner">
            If this value is TRUE and the caller created the mutex, the calling thread obtains initial ownership of the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the caller created the mutex, see the Return Values section.
            </param>
            <param name = "lpName">
            The name of the mutex object. The name is limited to MAX_PATH characters. Name comparison is case sensitive.
            If lpName matches the name of an existing named mutex object, this function requests the MUTEX_ALL_ACCESS access right. In this case, the bInitialOwner parameter is ignored because it has already been set by the creating process. If the lpMutexAttributes parameter is not NULL, it determines whether the handle can be inherited, but its security-descriptor member is ignored.
            If lpName is NULL, the mutex object is created without a name.
            If lpName matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the GetLastError function returns ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace.
            The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see Kernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.
            The object can be created in a private namespace. For more information, see Object Namespaces.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the newly created mutex object.
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, GetLastError returns ERROR_ALREADY_EXISTS, bInitialOwner is ignored, and the calling thread is not granted ownership. However, if the caller has limited access rights, the function will fail with ERROR_ACCESS_DENIED and the caller should use the OpenMutex function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetSystemTime(System.IntPtr)">
            <summary>
            Retrieves the current system date and time. The system time is expressed in Coordinated Universal Time (UTC).
            To retrieve the current system date and time in local time, use the GetLocalTime function.
            </summary>
            <param name = "lpSystemTime">
            A pointer to a SYSTEMTIME structure to receive the current system date and time.
            The lpSystemTime parameter must not be NULL. Using NULL will result in an access violation.
            </param>
        </member>
        <member name="M:PInvoke.Kernel32.GetSystemTime(PInvoke.Kernel32.SYSTEMTIME@)">
            <summary>
            Retrieves the current system date and time. The system time is expressed in Coordinated Universal Time (UTC).
            To retrieve the current system date and time in local time, use the GetLocalTime function.
            </summary>
            <param name = "lpSystemTime">
            A pointer to a SYSTEMTIME structure to receive the current system date and time.
            The lpSystemTime parameter must not be NULL. Using NULL will result in an access violation.
            </param>
        </member>
        <member name="M:PInvoke.Kernel32.VerifyVersionInfo(System.IntPtr,PInvoke.Kernel32.VER_MASK,System.Int64)">
             <summary>
             Compares a set of operating system version requirements to the corresponding values for the currently
             running version of the system.This function is subject to manifest-based behavior.
             </summary>
             <param name = "lpVersionInformation">
             A pointer to an OSVERSIONINFOEX structure containing the operating system version requirements to compare. The <paramref name = "dwTypeMask"/>
             parameter indicates the members of this structure that contain information to compare.You must set the
             <see cref = "F:PInvoke.Kernel32.OSVERSIONINFOEX.dwOSVersionInfoSize"/> member of this structure to <code>Marshal.SizeOf(typeof(OSVERSIONINFOEX))</code>. You must
             also specify valid data for the members indicated by <paramref name = "dwTypeMask"/>. The function ignores structure members for which the
             corresponding <paramref name = "dwTypeMask"/> bit is not set
             </param>
             <param name = "dwTypeMask">A mask that indicates the members of the <see cref = "T:PInvoke.Kernel32.OSVERSIONINFOEX"/> structure to be tested.</param>
             <param name = "dwlConditionMask">The type of comparison to be used for each <paramref name = "lpVersionInformation"/> member being compared. To build this value,
             call the <see cref = "M:PInvoke.Kernel32.VerSetConditionMask(System.Int64,PInvoke.Kernel32.VER_MASK,PInvoke.Kernel32.VER_CONDITION)"/> function once for each <see cref = "T:PInvoke.Kernel32.OSVERSIONINFOEX"/> member being compared.</param>
             <returns>
             <para>
             If the currently running operating system satisfies the specified requirements, the return value is a nonzero value.
             </para>
             <para>
             If the current system does not satisfy the requirements, the return value is zero and <see cref = "M:PInvoke.Kernel32.GetLastError"/> returns <see cref = "F:PInvoke.Win32ErrorCode.ERROR_OLD_WIN_VERSION"/>.
             </para>
             <para>
             If the function fails, the return value is zero and <see cref = "M:PInvoke.Kernel32.GetLastError"/> returns an error code other than <see cref = "F:PInvoke.Win32ErrorCode.ERROR_OLD_WIN_VERSION"/>.
             </para>
             </returns>
             <remarks>
             <para>
             The <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function retrieves version information about the currently running operating system and compares it to the valid
             members of the <paramref name = "lpVersionInformation"/> structure. This enables you to easily determine the presence of a required set of
             operating system version conditions. It is preferable to use <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> rather than
             calling the GetVersionEx function to perform your own comparisons.
             </para>
             <para>
             Typically, <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> returns a nonzero value only if all specified tests succeed.
             However, major, minor, and service pack versions are tested in a hierarchical manner because the operating system version is a combination of
             these values. If a condition exists for the major version, it supersedes the conditions specified for minor version and service pack version.
             (You cannot test for major version greater than 5 and minor version less than or equal to 1. If you specify such a test, the function will
             change the request to test for a minor version greater than 1 because it is performing a greater than operation on the major version.)
             </para>
             <para>
             The function tests these values in this order: major version, minor version, and service pack version.The function continues testing values while
             they are equal, and stops when one of the values does not meet the specified condition.For example, if you test for a system greater than or
             equal to version 5.1 service pack 1, the test succeeds if the current version is 6.0. (The major version is greater than the specified version,
             so the testing stops.) In the same way, if you test for a system greater than or equal to version 5.1 service pack 1, the test succeeds if the
             current version is 5.2. (The minor version is greater than the specified versions, so the testing stops.) However, if you test for a system greater
             than or equal to version 5.1 service pack 1, the test fails if the current version is 5.0 service pack 2. (The minor version is not greater than
             the specified version, so the testing stops.)
             </para>
             <para>
             To verify a range of system versions, you must call <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> twice.For example, to verify
             that the system version is greater than 5.0 but less than or equal to 5.1, first call <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> to
             test that the major version is 5 and the minor version is greater than 0, then call <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
             again to test that the major version is 5 and the minor version is less than or equal to 1.
             </para>
             <para>
             Identifying the current operating system is usually not the best way to determine whether a particular operating system feature is present.
             This is because the operating system may have had new features added in a redistributable DLL. Rather than using GetVersionEx to determine the operating
             system platform or version number, test for the presence of the feature itself.
             </para>
             <para>
             To verify whether the current operating system is either the Media Center or Tablet PC version of Windows, call GetSystemMetrics.
             </para>
             <para>
             Windows 10:
                 <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> returns false when called by applications that do not have a
                 compatibility manifest for Windows 8.1 or Windows 10 if the <paramref name = "lpVersionInformation"/> parameter is set so that it specifies
                 Windows 8.1 or Windows 10, even when the current operating system version is Windows 8.1 or Windows 10. Specifically,
                 <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> has the following behavior:
            
                 If the application has no manifest, <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> behaves as
                     if the operation system version is Windows 8 (6.2).
                 If the application has a manifest that contains the GUID that corresponds to Windows 8.1, <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
                     behaves as if the operation system version is Windows 8.1 (6.3).
                 If the application has a manifest that contains the GUID that corresponds to Windows 10, <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
                     behaves as if the operation system version is Windows 10 (10.0).
             </para>
             </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX@,PInvoke.Kernel32.VER_MASK,System.Int64)">
             <summary>
             Compares a set of operating system version requirements to the corresponding values for the currently
             running version of the system.This function is subject to manifest-based behavior.
             </summary>
             <param name = "lpVersionInformation">
             A pointer to an OSVERSIONINFOEX structure containing the operating system version requirements to compare. The <paramref name = "dwTypeMask"/>
             parameter indicates the members of this structure that contain information to compare.You must set the
             <see cref = "F:PInvoke.Kernel32.OSVERSIONINFOEX.dwOSVersionInfoSize"/> member of this structure to <code>Marshal.SizeOf(typeof(OSVERSIONINFOEX))</code>. You must
             also specify valid data for the members indicated by <paramref name = "dwTypeMask"/>. The function ignores structure members for which the
             corresponding <paramref name = "dwTypeMask"/> bit is not set
             </param>
             <param name = "dwTypeMask">A mask that indicates the members of the <see cref = "T:PInvoke.Kernel32.OSVERSIONINFOEX"/> structure to be tested.</param>
             <param name = "dwlConditionMask">The type of comparison to be used for each <paramref name = "lpVersionInformation"/> member being compared. To build this value,
             call the <see cref = "M:PInvoke.Kernel32.VerSetConditionMask(System.Int64,PInvoke.Kernel32.VER_MASK,PInvoke.Kernel32.VER_CONDITION)"/> function once for each <see cref = "T:PInvoke.Kernel32.OSVERSIONINFOEX"/> member being compared.</param>
             <returns>
             <para>
             If the currently running operating system satisfies the specified requirements, the return value is a nonzero value.
             </para>
             <para>
             If the current system does not satisfy the requirements, the return value is zero and <see cref = "M:PInvoke.Kernel32.GetLastError"/> returns <see cref = "F:PInvoke.Win32ErrorCode.ERROR_OLD_WIN_VERSION"/>.
             </para>
             <para>
             If the function fails, the return value is zero and <see cref = "M:PInvoke.Kernel32.GetLastError"/> returns an error code other than <see cref = "F:PInvoke.Win32ErrorCode.ERROR_OLD_WIN_VERSION"/>.
             </para>
             </returns>
             <remarks>
             <para>
             The <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function retrieves version information about the currently running operating system and compares it to the valid
             members of the <paramref name = "lpVersionInformation"/> structure. This enables you to easily determine the presence of a required set of
             operating system version conditions. It is preferable to use <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> rather than
             calling the GetVersionEx function to perform your own comparisons.
             </para>
             <para>
             Typically, <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> returns a nonzero value only if all specified tests succeed.
             However, major, minor, and service pack versions are tested in a hierarchical manner because the operating system version is a combination of
             these values. If a condition exists for the major version, it supersedes the conditions specified for minor version and service pack version.
             (You cannot test for major version greater than 5 and minor version less than or equal to 1. If you specify such a test, the function will
             change the request to test for a minor version greater than 1 because it is performing a greater than operation on the major version.)
             </para>
             <para>
             The function tests these values in this order: major version, minor version, and service pack version.The function continues testing values while
             they are equal, and stops when one of the values does not meet the specified condition.For example, if you test for a system greater than or
             equal to version 5.1 service pack 1, the test succeeds if the current version is 6.0. (The major version is greater than the specified version,
             so the testing stops.) In the same way, if you test for a system greater than or equal to version 5.1 service pack 1, the test succeeds if the
             current version is 5.2. (The minor version is greater than the specified versions, so the testing stops.) However, if you test for a system greater
             than or equal to version 5.1 service pack 1, the test fails if the current version is 5.0 service pack 2. (The minor version is not greater than
             the specified version, so the testing stops.)
             </para>
             <para>
             To verify a range of system versions, you must call <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> twice.For example, to verify
             that the system version is greater than 5.0 but less than or equal to 5.1, first call <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> to
             test that the major version is 5 and the minor version is greater than 0, then call <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
             again to test that the major version is 5 and the minor version is less than or equal to 1.
             </para>
             <para>
             Identifying the current operating system is usually not the best way to determine whether a particular operating system feature is present.
             This is because the operating system may have had new features added in a redistributable DLL. Rather than using GetVersionEx to determine the operating
             system platform or version number, test for the presence of the feature itself.
             </para>
             <para>
             To verify whether the current operating system is either the Media Center or Tablet PC version of Windows, call GetSystemMetrics.
             </para>
             <para>
             Windows 10:
                 <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> returns false when called by applications that do not have a
                 compatibility manifest for Windows 8.1 or Windows 10 if the <paramref name = "lpVersionInformation"/> parameter is set so that it specifies
                 Windows 8.1 or Windows 10, even when the current operating system version is Windows 8.1 or Windows 10. Specifically,
                 <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> has the following behavior:
            
                 If the application has no manifest, <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> behaves as
                     if the operation system version is Windows 8 (6.2).
                 If the application has a manifest that contains the GUID that corresponds to Windows 8.1, <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
                     behaves as if the operation system version is Windows 8.1 (6.3).
                 If the application has a manifest that contains the GUID that corresponds to Windows 10, <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
                     behaves as if the operation system version is Windows 10 (10.0).
             </para>
             </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.IntPtr,System.Int32,System.Int32,System.IntPtr[],System.Int32)">
            <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested.
            </summary>
            <param name = "dwFlags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            The <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ARGUMENT_ARRAY"/> flag is always added
            and the <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> flag is always suppressed by this helper method
            </param>
            <param name = "lpSource">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name = "dwFlags"/> parameter.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name = "dwMessageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            </param>
            <param name = "dwLanguageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name = "Arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <param name = "maxAllowedBufferSize">The maximum size of the returned string. If exceeded, <c>null</c> is returned.</param>
            <returns>
            If the function succeeds, the return value is the number of TCHARs stored in the output buffer, excluding the terminating null character.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32)">
            <summary>Writes data synchronously to the specified file or input/output (I/O) device.</summary>
            <param name = "hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
            </param>
            <param name = "lpBuffer">A pointer to the buffer containing the data to be written to the file or device.</param>
            <param name = "nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <returns>The number of bytes written.</returns>
            <exception cref = "T:PInvoke.Win32Exception">Thrown if the native method return false (Write failed).</exception>
            <exception cref = "T:System.ArgumentNullException">If <paramref name = "hFile"/> is <see langword = "null"/>.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32)">
            <summary>Reads data synchronously from the specified file or input/output (I/O) device.</summary>
            <param name = "hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer,
                tape drive, socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
            </param>
            <param name = "lpBuffer">A pointer to the buffer that receives the data read from a file or device.</param>
            <param name = "nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <returns>The number of bytes read.</returns>
            <exception cref = "T:PInvoke.Win32Exception">Thrown if the native method return false (Read failed).</exception>
            <exception cref = "T:System.ArgumentNullException">If <paramref name = "hFile"/> is <see langword = "null"/>.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.TryGetErrorMessage(PInvoke.Kernel32.FormatMessageFlags,System.IntPtr,System.Int32,System.Int32,System.Text.StringBuilder,System.IntPtr[],System.String@)">
            <summary>
            Tries to get the error message text using the supplied buffer.
            </summary>
            <param name = "flags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
            <param name = "source">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name = "flags"/> parameter.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name = "messageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            </param>
            <param name = "languageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name = "sb">The buffer to use for acquiring the message.</param>
            <param name = "arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <param name = "errorMsg">Receives the resulting error message.</param>
            <returns><c>true</c> if the attempt is successful; <c>false</c> otherwise.</returns>
        </member>
        <member name="T:PInvoke.Kernel32Extensions">
            <summary>
            Extension methods available for and from the Kernel32 library.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32Extensions.MaxAllowedBufferSize">
            <summary>
            The maximum memory we are willing to allocate for the exception message.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32Extensions.GetMessage(PInvoke.Win32ErrorCode)">
            <summary>
            Gets the text associated with a <see cref="T:PInvoke.Win32ErrorCode"/>.
            </summary>
            <param name="error">The error code.</param>
            <returns>The error message. Or <c>null</c> if no message could be found.</returns>
        </member>
        <member name="M:PInvoke.Kernel32Extensions.ThrowOnError(PInvoke.Win32ErrorCode)">
            <summary>
            Throws an exception when an error occurs.
            </summary>
            <param name="errorCode">The result of the P/Invoke call.</param>
            <exception cref="T:PInvoke.Win32Exception">If <paramref name="errorCode"/> is not <see cref="F:PInvoke.Win32ErrorCode.ERROR_SUCCESS"/></exception>
        </member>
        <member name="M:PInvoke.Kernel32Extensions.ThrowOnError(PInvoke.NTSTATUS)">
            <summary>
            Throws an exception if a P/Invoke failed.
            </summary>
            <param name="status">The result of the P/Invoke call.</param>
        </member>
        <member name="T:PInvoke.NTStatusException">
            <summary>
            An exception thrown for a failure described by a <see cref="T:PInvoke.NTSTATUS"/>.
            </summary>
        </member>
        <member name="M:PInvoke.NTStatusException.#ctor(PInvoke.NTSTATUS)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.NTStatusException"/> class.
            </summary>
            <param name="statusCode">The status code identifying the error.</param>
        </member>
        <member name="M:PInvoke.NTStatusException.#ctor(PInvoke.NTSTATUS,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.NTStatusException"/> class.
            </summary>
            <param name="statusCode">The status code identifying the error.</param>
            <param name="message">The exception message (which may be null to use the default).</param>
        </member>
        <member name="M:PInvoke.NTStatusException.#ctor(PInvoke.NTSTATUS,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.NTStatusException"/> class.
            </summary>
            <param name="statusCode">The status code identifying the error.</param>
            <param name="message">The exception message (which may be null to use the default).</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="P:PInvoke.NTStatusException.NativeErrorCode">
            <summary>
            Gets the <see cref="T:PInvoke.NTSTATUS"/> code that identifies the error condition.
            </summary>
        </member>
        <member name="M:PInvoke.NTStatusException.GetMessage(PInvoke.NTSTATUS)">
            <summary>
            Gets the message associated with the given <see cref="T:PInvoke.NTSTATUS"/>.
            </summary>
            <param name="status">The <see cref="T:PInvoke.NTSTATUS"/> for the error.</param>
            <returns>The description of the error.</returns>
        </member>
        <member name="T:PInvoke.Win32Exception">
            <summary>
            An exception thrown for a failure described by a <see cref="T:PInvoke.Win32ErrorCode"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Win32Exception.nativeErrorCode">
            <summary>
            The original Win32 error code that resulted in this exception.
            </summary>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor(PInvoke.Win32ErrorCode)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class.
            </summary>
            <param name="error">The Win32 error code associated with this exception.</param>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class.
            </summary>
            <param name="error">The Win32 error code associated with this exception.</param>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor(PInvoke.Win32ErrorCode,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class.
            </summary>
            <param name="error">The Win32 error code associated with this exception.</param>
            <param name="message">The message for this exception.</param>
        </member>
        <member name="P:PInvoke.Win32Exception.NativeErrorCode">
            <summary>
            Gets the Win32 error code associated with this exception.
            </summary>
            <devremarks>
            We must define this so that our own assembly on desktop is not a subset
            of what portable offers (lest runtime errors in our users occur).
            </devremarks>
        </member>
    </members>
</doc>
