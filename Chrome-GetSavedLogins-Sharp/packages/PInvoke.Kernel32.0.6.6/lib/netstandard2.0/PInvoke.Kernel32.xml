<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PInvoke.Kernel32</name>
    </assembly>
    <members>
        <member name="T:PInvoke.Kernel32">
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.CreateFileFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.CreationDisposition"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FileAccess"/> nested type.
            </content>
            <content>
            Contains the nested <see cref="T:PInvoke.Kernel32.FileAttribute"/> type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FileShare"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FILETIME"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FINDEX_INFO_LEVELS"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FINDEX_SEARCH_OPS"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FindFirstFileExFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FormatMessageFlags"/> nested type.
            </content>
            <summary>
            Contains the <see cref="T:PInvoke.Kernel32.OSVERSIONINFOEX"/> nested type.
            </summary>
            <summary>
            Contains the <see cref="T:PInvoke.Kernel32.OS_TYPE"/> nested type.
            </summary>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.OVERLAPPED"/> nested type.
            </content>
            <summary>
            Contains the <see cref="T:PInvoke.Kernel32.PRODUCT_SUITE"/> nested type
            </summary>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SafeFindFilesHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SafeObjectHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SafeObjectHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SECURITY_DESCRIPTOR"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SYSTEMTIME"/> nested type.
            </content>
            <summary>
            Contains the nested type <see cref="T:PInvoke.Kernel32.VER_CONDITION"/>
            </summary>
            <summary>
            Contains the <see cref="T:PInvoke.Kernel32.VER_MASK"/> nested type.
            </summary>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.WaitForSingleObjectResult"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.WIN32_FIND_DATA"/> nested type.
            </content>
            <summary>
            Exported functions from the Kernel32.dll Windows library.
            </summary>
            <content>
            Methods and nested types that are not strictly P/Invokes but provide
            a slightly higher level of functionality to ease calling into native code.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ACL"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.CharacterAttributesFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.CHAR_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.CHAR_INFO_ENCODING"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ConsoleBufferModes"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ConsoleDisplayMode"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ConsoleScreenBufferFlag"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ConsoleSelectionFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.CONSOLE_SCREEN_BUFFER_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.CONSOLE_SELECTION_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ControlKeyStates"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ControlType"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.CreateProcessFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.EXECUTION_STATE"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FOCUS_EVENT_RECORD"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.GetModuleHandleExFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.GlobalAllocFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.GlobalReAllocFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.GRPICONDIR"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.GRPICONDIRENTRY"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.HeapAllocFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.HeapFreeFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.HeapReAllocFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ICONDIR"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ICONDIRENTRY"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.InputEventTypeFlag"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.INPUT_EVENT_RECORD"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.INPUT_RECORD"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.IO_COUNTERS"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.JOBOBJECTINFOCLASS"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.JOBOBJECT_BASIC_LIMIT_INFORMATION"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.JOBOBJECT_CPU_RATE_CONTROL_FLAGS"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.JOBOBJECT_CPU_RATE_CONTROL_INFORMATION"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.JOBOBJECT_EXTENDED_LIMIT_INFORMATION"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.JOB_OBJECT_LIMIT_FLAGS"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.KEY_EVENT_RECORD"/> nested type.
            </content>
            <content>
            Contains the language ID (LANGID) constants.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.LoadLibraryExFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.LocalAllocFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.LocalReAllocFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.MENU_EVENT_RECORD"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.MODULEENTRY32" /> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.MouseButtonStates"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.MouseEvents"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.MOUSE_EVENT_RECORD"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.NamedPipeInfoFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.PipeAccessMode"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.PipeMode"/> nested type.
            </content>
            <content>Contains the <see cref="T:PInvoke.Kernel32.ProcessAccess" /> nested type.</content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.PROCESSENTRY32" /> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ProcessShutdownFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.PROCESS_INFORMATION"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.QueryFullProcessImageNameFlags" /> nested type.
            </content>
            <content>
            Contains all the "RT_" constants that represent resource types.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.STARTUPINFOEX"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.StartupInfoFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.StdHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.WINDOW_BUFFER_SIZE_RECORD"/> nested type.
            </content>
            <summary>
            Exported functions from the Kernel32.dll Windows library.
            </summary>
            <content>
            Methods and nested types that are not strictly P/Invokes but provide
            a slightly higher level of functionality to ease calling into native code.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.ACCESS_MASK"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.CreateFileFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.CreationDisposition"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FileAccess"/> nested type.
            </content>
            <content>
            Contains the nested <see cref = "T:PInvoke.Kernel32.FileAttribute"/> type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FileShare"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FILETIME"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FINDEX_INFO_LEVELS"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FINDEX_SEARCH_OPS"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FindFirstFileExFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FormatMessageFlags"/> nested type.
            </content>
            <summary>
            Contains the <see cref = "T:PInvoke.Kernel32.OSVERSIONINFOEX"/> nested type.
            </summary>
            <summary>
            Contains the <see cref = "T:PInvoke.Kernel32.OS_TYPE"/> nested type.
            </summary>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> nested type.
            </content>
            <summary>
            Contains the <see cref = "T:PInvoke.Kernel32.PRODUCT_SUITE"/> nested type
            </summary>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SafeFindFilesHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SafeObjectHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SafeObjectHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SECURITY_DESCRIPTOR"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SYSTEMTIME"/> nested type.
            </content>
            <summary>
            Contains the nested type <see cref = "T:PInvoke.Kernel32.VER_CONDITION"/>
            </summary>
            <summary>
            Contains the <see cref = "T:PInvoke.Kernel32.VER_MASK"/> nested type.
            </summary>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.WaitForSingleObjectResult"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.WIN32_FIND_DATA"/> nested type.
            </content>
            <summary>
            Exported functions from the Kernel32.dll Windows library.
            </summary>
            <content>
            Methods and nested types that are not strictly P/Invokes but provide
            a slightly higher level of functionality to ease calling into native code.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.ACL"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.CharacterAttributesFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.CHAR_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.CHAR_INFO_ENCODING"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.ConsoleBufferModes"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.ConsoleDisplayMode"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.ConsoleScreenBufferFlag"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.ConsoleSelectionFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.CONSOLE_SCREEN_BUFFER_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.CONSOLE_SELECTION_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.ControlKeyStates"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.ControlType"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.CreateProcessFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.EXECUTION_STATE"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FOCUS_EVENT_RECORD"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.GetModuleHandleExFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.GlobalAllocFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.GlobalReAllocFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.GRPICONDIR"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.GRPICONDIRENTRY"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.HeapAllocFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.HeapFreeFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.HeapReAllocFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.ICONDIR"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.ICONDIRENTRY"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.InputEventTypeFlag"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.INPUT_EVENT_RECORD"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.INPUT_RECORD"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.IO_COUNTERS"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.JOBOBJECTINFOCLASS"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.JOBOBJECT_BASIC_LIMIT_INFORMATION"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.JOBOBJECT_CPU_RATE_CONTROL_FLAGS"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.JOBOBJECT_CPU_RATE_CONTROL_INFORMATION"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.JOBOBJECT_EXTENDED_LIMIT_INFORMATION"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.JOB_OBJECT_LIMIT_FLAGS"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.KEY_EVENT_RECORD"/> nested type.
            </content>
            <content>
            Contains the language ID (LANGID) constants.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.LoadLibraryExFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.LocalAllocFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.LocalReAllocFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.MENU_EVENT_RECORD"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.MODULEENTRY32"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.MouseButtonStates"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.MouseEvents"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.MOUSE_EVENT_RECORD"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.NamedPipeInfoFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.PipeAccessMode"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.PipeMode"/> nested type.
            </content>
            <content>Contains the <see cref = "T:PInvoke.Kernel32.ProcessAccess"/> nested type.</content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.PROCESSENTRY32"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.ProcessShutdownFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.QueryFullProcessImageNameFlags"/> nested type.
            </content>
            <content>
            Contains all the "RT_" constants that represent resource types.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.StartupInfoFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.StdHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.WINDOW_BUFFER_SIZE_RECORD"/> nested type.
            </content>
            <summary>
            Exported functions from the Kernel32.dll Windows library.
            </summary>
            <content>
            Methods and nested types that are not strictly P/Invokes but provide
            a slightly higher level of functionality to ease calling into native code.
            </content>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            The ACCESS_MASK type is a bitmask that specifies a set of access rights in the access mask of an access control entry.
            </summary>
            <remarks>
            Quite well described here: http://blogs.msdn.com/b/openspecification/archive/2010/04/01/about-the-access-mask-structure.aspx
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.GenericRightsMask">
            <summary>
            Bits 28-31
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecialRightsMask">
            <summary>
            Bits 24-27
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRightsMask">
            <summary>
            Bits 16-23
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecificRightsMask">
            <summary>
            Bits 0-15
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.#ctor(System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/> struct.
            </summary>
            <param name="value">The value for the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.</param>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecialRight.ACCESS_SYSTEM_SECURITY">
            <summary>
            It is used to indicate access to a system access control list (SACL). This type of access requires the calling process to have the SE_SECURITY_NAME (Manage auditing and security log) privilege. If this flag is set in the access mask of an audit access ACE (successful or unsuccessful access), the SACL access will be audited.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecialRight.MAXIMUM_ALLOWED">
            <summary>
            Maximum allowed.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.StandardRight">
            <summary>
            Contains the object's standard access rights.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.DELETE">
            <summary>
            Delete access.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL">
            <summary>
            Read access to the owner, group, and discretionary access control list (DACL) of the security descriptor.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.WRITE_DAC">
            <summary>
            Write access to the DACL.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.WRITE_OWNER">
            <summary>
            Write access to owner.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.SYNCHRONIZE">
            <summary>
            Synchronize access.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.STANDARD_RIGHTS_READ">
            <summary>
            See also <see cref="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL"/>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.STANDARD_RIGHTS_WRITE">
            <summary>
            See also <see cref="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL"/>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.STANDARD_RIGHTS_EXECUTE">
            <summary>
            See also <see cref="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL"/>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.SpecificRight">
            <summary>
            Contains the access mask specific to the object type associated with the mask.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecificRight.SPECIFIC_RIGHTS_ALL">
            <summary>
            The bit mask that covers specific rights.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.DesktopGenericRight">
            <summary>
            The following are the generic access rights for a desktop object contained in the interactive window station of the user's logon session
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight">
            <summary>
            Contains the access mask specific to the Desktop associated with the mask.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_ALL_ACCESS">
            <summary>
            The bit mask that covers all possible access rights for the desktop.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_CREATEMENU">
            <summary>
            Required to create a menu on the desktop.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_ENUMERATE">
            <summary>
            Required for the desktop to be enumerated.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_HOOKCONTROL">
            <summary>
            Required to establish any of the window hooks.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_JOURNALPLAYBACK">
            <summary>
            Required to perform journal playback on a desktop.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_JOURNALRECORD">
            <summary>
            Required to perform journal recording on a desktop.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_READOBJECTS">
            <summary>
            Required to read objects on the desktop.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_CREATEWINDOW">
            <summary>
            Required to create a window on the desktop.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_SWITCHDESKTOP">
            <summary>
            Required to activate the desktop using the SwitchDesktop function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_WRITEOBJECTS">
            <summary>
            Required to write objects on the desktop.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.InteractiveWindowStationGenericRight">
            <summary>
            Generic access rights for the interactive window station object, which is the window station assigned to the logon session of the interactive user.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.NonInteractiveWindowStationGenericRight">
            <summary>
            Generic access rights for a noninteractive window station object.
            The system assigns noninteractive window stations to all logon sessions other than that of the interactive user.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight">
            <summary>
            Contains the access mask specific to the Window Station associated with the mask.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_ALL_ACCESS">
            <summary>
            The bit mask that covers all possible access rights for the window station.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_ACCESSCLIPBOARD">
            <summary>
            Required to use the clipboard.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_ACCESSGLOBALATOMS">
            <summary>
            Required to manipulate global atoms.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_CREATEDESKTOP">
            <summary>
            Required to create new desktop objects on the window station.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_ENUMDESKTOPS">
            <summary>
            Required to enumerate existing desktop objects.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_ENUMERATE">
            <summary>
            Required for the window station to be enumerated.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_EXITWINDOWS">
            <summary>
            Required to successfully call the ExitWindows or ExitWindowsEx function
            Window stations can be shared by users and this access type can prevent other users of a window station from logging off the window station owner.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_READATTRIBUTES">
            <summary>
            Required to read the attributes of a window station object. This attribute includes color settings and other global window station properties.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_READSCREEN">
            <summary>
            Required to access screen contents.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_WRITEATTRIBUTES">
            <summary>
            Required to modify the attributes of a window station object. The attributes include color settings and other global window station properties.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.Value">
            <summary>
            Gets the ACCESS_MASK as a 32-bit unsigned integer.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.AsInt32">
            <summary>
            Gets the ACCESS_MASK as a 32-bit signed integer.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.GenericRights">
            <summary>
            Gets the generic rights of this value.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.SpecialRights">
            <summary>
            Gets the special rights of this value.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.StandardRights">
            <summary>
            Gets the standard rights of this value.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.SpecificRights">
            <summary>
            Gets the specific rights of this value.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRights">
            <summary>
            Gets the specific rights of this value for desktops.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.InteractiveWindowStationGenericRights">
            <summary>
            Gets the generic rights of this value for interactive window stations.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.NonInteractiveWindowStationGenericRights">
            <summary>
            Gets the generic rights of this value for noninteractive window stations.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRights">
            <summary>
            Gets the specific rights of this value for window stations.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(System.Int32)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts an <see cref="T:System.Int32"/> into an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value of the ACCESS_MASK.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Explicit(PInvoke.Kernel32.ACCESS_MASK)~System.Int32">
            <summary>
            Converts an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/> into an <see cref="T:System.Int32"/>.
            </summary>
            <param name="value">The value of the ACCESS_MASK.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(System.UInt32)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts an <see cref="T:System.UInt32"/> into an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value of the ACCESS_MASK.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(PInvoke.Kernel32.ACCESS_MASK)~System.UInt32">
            <summary>
            Converts an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/> into an <see cref="T:System.UInt32"/>.
            </summary>
            <param name="value">The value of the ACCESS_MASK.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(PInvoke.Kernel32.ACCESS_MASK.StandardRight)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts a <see cref="T:PInvoke.Kernel32.ACCESS_MASK.StandardRight"/> to an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value for the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/></param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(PInvoke.Kernel32.ACCESS_MASK.GenericRight)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts a <see cref="T:PInvoke.Kernel32.ACCESS_MASK.GenericRight"/> to an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value for the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/></param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(PInvoke.Kernel32.ACCESS_MASK.SpecificRight)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts a <see cref="T:PInvoke.Kernel32.ACCESS_MASK.SpecificRight"/> to an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value for the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/></param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.Equals(PInvoke.Kernel32.ACCESS_MASK)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.CompareTo(PInvoke.Kernel32.ACCESS_MASK)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.ToString">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="T:PInvoke.Kernel32.CreateFileFlags">
            <summary>
            File attributes, flags, and security settings that are passed to the CreateFile method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_ARCHIVE">
            <summary>
                A file or directory that is an archive file or directory. Applications typically use this attribute to mark
                files for backup or removal.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_ENCRYPTED">
            <summary>
                A file or directory that is encrypted. For a file, all data streams in the file are encrypted. For a
                directory, encryption is the default for newly created files and subdirectories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_HIDDEN">
            <summary>The file or directory is hidden. It is not included in an ordinary directory listing.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_NORMAL">
            <summary>A file that does not have other attributes set. This attribute is valid only when used alone.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_OFFLINE">
            <summary>
                The data of a file is not available immediately. This attribute indicates that the file data is physically
                moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical storage management
                software. Applications should not arbitrarily change this attribute.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_READONLY">
            <summary>
                A file that is read-only. Applications can read the file, but cannot write to it or delete it. This attribute
                is not honored on directories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_SYSTEM">
            <summary>A file or directory that the operating system uses a part of, or uses exclusively.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_TEMPORARY">
            <summary>
                A file that is being used for temporary storage. File systems avoid writing data back to mass storage if
                sufficient cache memory is available, because typically, an application deletes a temporary file after the handle
                is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is written after
                the handle is closed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_BACKUP_SEMANTICS">
            <summary>
                The file is being opened or created for a backup or restore operation. The system ensures that the calling
                process overrides file security checks when the process has SE_BACKUP_NAME and SE_RESTORE_NAME privileges. For more
                information, see Changing Privileges in a Token. You must set this flag to obtain a handle to a directory. A
                directory handle can be passed to some functions instead of a file handle. For more information, see the Remarks
                section.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_DELETE_ON_CLOSE">
            <summary>
                The file is to be deleted immediately after all of its handles are closed, which includes the specified handle
                and any other open or duplicated handles. If there are existing open handles to a file, the call fails unless they
                were all opened with the <see cref="F:PInvoke.Kernel32.FileShare.FILE_SHARE_DELETE" /> share mode. Subsequent open requests for the
                file fail, unless the <see cref="F:PInvoke.Kernel32.FileShare.FILE_SHARE_DELETE" /> share mode is specified.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_NO_BUFFERING">
            <summary>
                The file or device is being opened with no system caching for data reads and writes. This flag does not affect
                hard disk caching or memory mapped files. There are strict requirements for successfully working with files opened
                with CreateFile using the <see cref="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_NO_BUFFERING" /> flag.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_OPEN_NO_RECALL">
            <summary>
                The file data is requested, but it should continue to be located in remote storage. It should not be
                transported back to local storage. This flag is for use by remote storage systems.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_OPEN_REPARSE_POINT">
            <summary>
                Normal reparse point processing will not occur; CreateFile will attempt to open the reparse point. When a file
                is opened, a file handle is returned, whether or not the filter that controls the reparse point is operational.
                This flag cannot be used with the <see cref="F:PInvoke.Kernel32.CreationDisposition.CREATE_ALWAYS" /> flag. If the file is not a
                reparse point, then this flag is ignored. For more information, see the Remarks section.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_OVERLAPPED">
            <summary>
                The file or device is being opened or created for asynchronous I/O. When subsequent I/O operations are
                completed on this handle, the event specified in the OVERLAPPED structure will be set to the signaled state. If
                this flag is specified, the file can be used for simultaneous read and write operations. If this flag is not
                specified, then I/O operations are serialized, even if the calls to the read and write functions specify an
                OVERLAPPED structure.For information about considerations when using a file handle created with this flag, see the
                Synchronous and Asynchronous I/O Handles section of this topic.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_POSIX_SEMANTICS">
            <summary>
                Access will occur according to POSIX rules. This includes allowing multiple files with names, differing only
                in case, for file systems that support that naming. Use care when using this option, because files created with
                this flag may not be accessible by applications that are written for MS-DOS or 16-bit Windows.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_RANDOM_ACCESS">
            <summary>
                Access is intended to be random. The system can use this as a hint to optimize file caching. This flag has no
                effect if the file system does not support cached I/O and <see cref="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_NO_BUFFERING" />. For more
                information, see the Caching Behavior section of this topic.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_SESSION_AWARE">
            <summary>
                The file or device is being opened with session awareness. If this flag is not specified, then per-session
                devices (such as a redirected USB device) cannot be opened by processes running in session 0. This flag has no
                effect for callers not in session 0. This flag is supported only on server editions of Windows.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_SEQUENTIAL_SCAN">
            <summary>
                Access is intended to be sequential from beginning to end. The system can use this as a hint to optimize file
                caching. This flag should not be used if read-behind (that is, reverse scans) will be used. This flag has no effect
                if the file system does not support cached I/O and <see cref="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_NO_BUFFERING" />. For more information, see
                the Caching Behavior section of this topic.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_WRITE_THROUGH">
            <summary>
                Write operations will not go through any intermediate cache, they will go directly to disk. For additional
                information, see the Caching Behavior section of this topic.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_SQOS_PRESENT">
            <summary>When this flag is present, one or more other flags ending with Security may also be specified.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_ANONYMOUS">
            <summary>Impersonates a client at the Anonymous impersonation level.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_CONTEXT_TRACKING">
            <summary>The security tracking mode is dynamic. If this flag is not specified, the security tracking mode is static.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_DELEGATION">
            <summary>Impersonates a client at the Delegation impersonation level.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_EFFECTIVE_ONLY">
            <summary>
                Only the enabled aspects of the client's security context are available to the server. If you do not specify
                this flag, all aspects of the client's security context are available. This allows the client to limit the groups
                and privileges that a server can use while impersonating the client.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_IDENTIFICATION">
            <summary>Impersonates a client at the Identification impersonation level.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_IMPERSONATION">
            <summary>
                Impersonate a client at the impersonation level. This is the default behavior if no other flags are specified
                along with the <see cref="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_SQOS_PRESENT" /> flag.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.CreationDisposition">
            <summary>
            Describes an action to take on a file or device that exists or does not exist.
            </summary>
            <remarks>
            These are flags to pass to the CreateFile method's dwCreationDisposition parameter.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.CreationDisposition.CREATE_NEW">
            <summary>
            Creates a new file. The function fails if a specified file exists.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreationDisposition.CREATE_ALWAYS">
            <summary>
            Creates a new file, always.
            If a file exists, the function overwrites the file, clears the existing attributes, combines the specified file attributes,
            and flags with FILE_ATTRIBUTE_ARCHIVE, but does not set the security descriptor that the SECURITY_ATTRIBUTES structure specifies.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreationDisposition.OPEN_EXISTING">
            <summary>
            Opens a file. The function fails if the file does not exist.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreationDisposition.OPEN_ALWAYS">
            <summary>
            Opens a file, always.
            If a file does not exist, the function creates a file as if dwCreationDisposition is CREATE_NEW.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreationDisposition.TRUNCATE_EXISTING">
            <summary>
            Opens a file and truncates it so that its size is 0 (zero) bytes. The function fails if the file does not exist.
            The calling process must open the file with the GENERIC_WRITE access right.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.FileAccess">
            <summary>
            Enumerates the <see cref="P:PInvoke.Kernel32.ACCESS_MASK.SpecificRights"/> that may apply to files.
            </summary>
            <remarks>
            These flags may be passed to CreateFile.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_READ_DATA">
            <summary>
                For a file object, the right to read the corresponding file data. For a directory object, the right to read
                the corresponding directory data.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_LIST_DIRECTORY">
            <summary>For a directory, the right to list the contents of the directory.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_WRITE_DATA">
            <summary>
                For a file object, the right to write data to the file. For a directory object, the right to create a file in
                the directory (<see cref="F:PInvoke.Kernel32.FileAccess.FILE_ADD_FILE" />).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_ADD_FILE">
            <summary>For a directory, the right to create a file in the directory.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_APPEND_DATA">
            <summary>
                For a file object, the right to append data to the file. (For local files, write operations will not overwrite
                existing data if this flag is specified without <see cref="F:PInvoke.Kernel32.FileAccess.FILE_WRITE_DATA" />.) For a directory object, the right
                to create a subdirectory (<see cref="F:PInvoke.Kernel32.FileAccess.FILE_ADD_SUBDIRECTORY" />).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_ADD_SUBDIRECTORY">
            <summary>For a directory, the right to create a subdirectory.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_CREATE_PIPE_INSTANCE">
            <summary>For a named pipe, the right to create a pipe.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_READ_EA">
            <summary>The right to read extended file attributes.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_WRITE_EA">
            <summary>The right to write extended file attributes.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_EXECUTE">
            <summary>
                For a native code file, the right to execute the file. This access right given to scripts may cause the script
                to be executable, depending on the script interpreter.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_TRAVERSE">
            <summary>
                For a directory, the right to traverse the directory. By default, users are assigned the
                BYPASS_TRAVERSE_CHECKING privilege, which ignores the FILE_TRAVERSE access right.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_DELETE_CHILD">
            <summary>For a directory, the right to delete a directory and all the files it contains, including read-only files.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_READ_ATTRIBUTES">
            <summary>The right to read file attributes.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_WRITE_ATTRIBUTES">
            <summary>The right to write file attributes.</summary>
        </member>
        <member name="T:PInvoke.Kernel32.FileAttribute">
            <summary>Defines the Win32 FileAttributes enum.</summary>
            <remarks>
                This is similar to the System.IO.FileAttributes enum, but that enum is not available in the portable profile,
                although it is allowed to call certain file methods via P/Invoke in Windows Store apps, per MSDN docs. A value
                typed as this enum may be safely cast to the System.IO.FileAttributes enum, as all the value names have equal
                ordinal values.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_ARCHIVE">
            <summary>
                A file or directory that is an archive file or directory. Applications typically use this attribute to mark
                files for backup or removal.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_COMPRESSED">
            <summary>
                A file or directory that is compressed. For a file, all of the data in the file is compressed. For a
                directory, compression is the default for newly created files and subdirectories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_DEVICE">
            <summary>This value is reserved for system use.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_DIRECTORY">
            <summary>The handle that identifies a directory.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_ENCRYPTED">
            <summary>
                A file or directory that is encrypted. For a file, all data streams in the file are encrypted. For a
                directory, encryption is the default for newly created files and subdirectories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_HIDDEN">
            <summary>The file or directory is hidden. It is not included in an ordinary directory listing.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_INTEGRITY_STREAM">
            <summary>
                The directory or user data stream is configured with integrity (only supported on ReFS volumes). It is not
                included in an ordinary directory listing. The integrity setting persists with the file if it's renamed. If a file
                is copied the destination file will have integrity set if either the source file or destination directory have
                integrity set.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_NORMAL">
            <summary>A file that does not have other attributes set. This attribute is valid only when used alone.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_NOT_CONTENT_INDEXED">
            <summary>The file or directory is not to be indexed by the content indexing service.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_NO_SCRUB_DATA">
            <summary>
                The user data stream not to be read by the background data integrity scanner (AKA scrubber). When set on a
                directory it only provides inheritance. This flag is only supported on Storage Spaces and ReFS volumes. It is not
                included in an ordinary directory listing.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_OFFLINE">
            <summary>
                The data of a file is not available immediately. This attribute indicates that the file data is physically
                moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical storage management
                software. Applications should not arbitrarily change this attribute.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_READONLY">
            <summary>
                A file that is read-only. Applications can read the file, but cannot write to it or delete it. This attribute
                is not honored on directories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_REPARSE_POINT">
            <summary>A file or directory that has an associated reparse point, or a file that is a symbolic link.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_SPARSE_FILE">
            <summary>A file that is a sparse file.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_SYSTEM">
            <summary>A file or directory that the operating system uses a part of, or uses exclusively.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_TEMPORARY">
            <summary>
                A file that is being used for temporary storage. File systems avoid writing data back to mass storage if
                sufficient cache memory is available, because typically, an application deletes a temporary file after the handle
                is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is written after
                the handle is closed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_VIRTUAL">
            <summary>This value is reserved for system use.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileShare.None">
            <summary>
            Prevents other processes from opening a file or device if they request delete, read, or write access.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileShare.FILE_SHARE_READ">
            <summary>
            Enables subsequent open operations on an object to request read access.
            Otherwise, other processes cannot open the object if they request read access.
            If this flag is not specified, but the object has been opened for read access, the function fails.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileShare.FILE_SHARE_WRITE">
            <summary>
            Enables subsequent open operations on an object to request write access.
            Otherwise, other processes cannot open the object if they request write access.
            If this flag is not specified, but the object has been opened for write access, the function fails.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileShare.FILE_SHARE_DELETE">
            <summary>
            Enables subsequent open operations on an object to request delete access.
            Otherwise, other processes cannot open the object if they request delete access.
            If this flag is not specified, but the object has been opened for delete access, the function fails.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.FILETIME">
            <summary>
            A 64-bit representation of a file timestamp.
            </summary>
            <remarks>
            This type is equivalent to <see cref="T:System.Runtime.InteropServices.ComTypes.FILETIME"/>.
            We couldn't use that type directly even though it's in the portable profile because
            Xamarin.Android and Xamarin.iOS omit the type and it causes link failures.
            See https://github.com/AArnott/pinvoke/issues/232
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.FILETIME.dwLowDateTime">
            <summary>
            Specifies the low 32 bits of the FILETIME.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FILETIME.dwHighDateTime">
            <summary>
            Specifies the high 32 bits of the FILETIME.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.FILETIME.op_Implicit(PInvoke.Kernel32.FILETIME)~System.Int64">
            <summary>
            Convert to <see cref="T:System.Int64"/> to ease interop with <see cref="T:System.TimeSpan"/> or <see cref="T:System.DateTime"/>
            </summary>
            <param name="fileTime"> The fileTime structure to be converted to long.</param>
        </member>
        <member name="T:PInvoke.Kernel32.FindFirstFileExFlags">
            <summary>
            Optional flags to pass to the <see cref="M:PInvoke.Kernel32.FindFirstFileEx(System.String,PInvoke.Kernel32.FINDEX_INFO_LEVELS,PInvoke.Kernel32.WIN32_FIND_DATA@,PInvoke.Kernel32.FINDEX_SEARCH_OPS,System.Void*,PInvoke.Kernel32.FindFirstFileExFlags)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FindFirstFileExFlags.None">
            <summary>
            No flags.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FindFirstFileExFlags.FIND_FIRST_EX_CASE_SENSITIVE">
            <summary>
            Searches are case-sensitive.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FindFirstFileExFlags.FIND_FIRST_EX_LARGE_FETCH">
            <summary>
            Uses a larger buffer for directory queries, which can increase performance of the find operation.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.FormatMessageFlags">
            <summary>
            Flags passed to the <see cref="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.IntPtr[],System.Int32)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER">
            <summary>
                The function allocates a buffer large enough to hold the formatted message, and places a pointer to the allocated
                buffer at the address specified by lpBuffer. The nSize parameter specifies the minimum number of TCHARs to allocate
                for an output message buffer. The caller should use the LocalFree function to free the buffer when it is no longer
                needed.
                <para>
                    If the length of the formatted message exceeds 128K bytes, then FormatMessage will fail and a subsequent call
                    to <see cref="M:PInvoke.Kernel32.GetLastError" /> will return <see cref="F:PInvoke.Win32ErrorCode.ERROR_MORE_DATA" />.
                </para>
                <para>
                    In previous versions of Windows, this value was not available for use when compiling Windows Store apps. As
                    of Windows 10 this value can be used.
                </para>
                <para>
                    Windows Server 2003 and Windows XP: If the length of the formatted message exceeds 128K bytes, then
                    FormatMessage will not automatically fail with an error of <see cref="F:PInvoke.Win32ErrorCode.ERROR_MORE_DATA" />.
                </para>
                <para>
                    Windows 10: LocalFree is not in the modern SDK, so it cannot be used to free the result buffer. Instead, use
                    HeapFree (GetProcessHeap(), allocatedMessage). In this case, this is the same as calling LocalFree on memory.
                </para>
                <para>
                    Important: LocalAlloc() has different options: LMEM_FIXED, and LMEM_MOVABLE. FormatMessage() uses LMEM_FIXED,
                    so HeapFree can be used. If LMEM_MOVABLE is used, HeapFree cannot be used.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ARGUMENT_ARRAY">
            <summary>
                The Arguments parameter is not a va_list structure, but is a pointer to an array of values that represent the
                arguments. This flag cannot be used with 64-bit integer values. If you are using a 64-bit integer, you must use the
                va_list structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE">
            <summary>
                The lpSource parameter is a module handle containing the message-table resource(s) to search. If this lpSource
                handle is NULL, the current process's application image file will be searched. This flag cannot be used with
                <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
                <para>
                    If the module has no message table resource, the function fails with
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_RESOURCE_TYPE_NOT_FOUND" />.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING">
            <summary>
                The lpSource parameter is a pointer to a null-terminated string that contains a message definition. The
                message definition may contain insert sequences, just as the message text in a message table resource may. This
                flag cannot be used with <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE" /> or <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_SYSTEM" />.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_SYSTEM">
            <summary>
                The function should search the system message-table resource(s) for the requested message. If this flag is
                specified with <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE" />, the function searches the system message table if the
                message is not found in the module specified by lpSource. This flag cannot be used with
                <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
                <para>
                    If this flag is specified, an application can pass the result of the <see cref="M:PInvoke.Kernel32.GetLastError" /> function to
                    retrieve the message text for a system-defined error.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_IGNORE_INSERTS">
            <summary>
                Insert sequences in the message definition are to be ignored and passed through to the output buffer
                unchanged. This flag is useful for fetching a message for later formatting. If this flag is set, the Arguments
                parameter is ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_MAX_WIDTH_MASK">
            <summary>
                The function ignores regular line breaks in the message definition text. The function stores hard-coded line breaks
                in the message definition text into the output buffer. The function generates no new line breaks.
                <para>
                    Without this flag set: There are no output line width restrictions. The function stores line breaks that are
                    in the message definition text into the output buffer. It specifies the maximum number of characters in an
                    output line. The function ignores regular line breaks in the message definition text. The function never splits
                    a string delimited by white space across a line break. The function stores hard-coded line breaks in the
                    message definition text into the output buffer. Hard-coded line breaks are coded with the %n escape sequence.
                </para>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.OSVERSIONINFOEX">
            <summary>
            The RTL_OSVERSIONINFOEXW structure contains operating system version information.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.dwOSVersionInfoSize">
            <summary>
            The size, in bytes, of an RTL_OSVERSIONINFOEXW structure.
            This member must be set before the structure is used with RtlGetVersion.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.dwMajorVersion">
            <summary>
            The major version number of the operating system. For example, for Windows 2000, the major version number is five.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.dwMinorVersion">
            <summary>
            The minor version number of the operating system. For example, for Windows 2000, the minor version number is zero
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.dwBuildNumber">
            <summary>
            The build number of the operating system.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.dwPlatformId">
            <summary>
            The operating system platform. For Win32 on NT-based operating systems, RtlGetVersion returns the value
            VER_PLATFORM_WIN32_NT.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.szCSDVersion">
            <summary>
            The service-pack version string. This member contains a null-terminated string, such as "Service Pack 3", which
            indicates the latest service pack installed on the system. If no service pack is installed, RtlGetVersion might not
            initialize this string. Initialize szCSDVersion to zero (empty string) before the call to RtlGetVersion.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.wServicePackMajor">
            <summary>
            The major version number of the latest service pack installed on the system. For example, for Service Pack 3,
            the major version number is three. If no service pack has been installed, the value is zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.wServicePackMinor">
            <summary>
            The minor version number of the latest service pack installed on the system. For example, for Service Pack 3,
            the minor version number is zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.wSuiteMask">
            <summary>
            The product suites available on the system. This member is set to zero or to the bitwise OR of one or more of
            the <see cref="T:PInvoke.Kernel32.PRODUCT_SUITE"/> values.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.wProductType">
            <summary>
            The product type. This member contains additional information about the system.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.wReserved">
            <summary>
            Reserved for future use.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.OSVERSIONINFOEX.Create">
            <summary>
            Helper method to create <see cref="T:PInvoke.Kernel32.OSVERSIONINFOEX"/> with
            the right pre-initialization for <see cref="F:PInvoke.Kernel32.OSVERSIONINFOEX.dwOSVersionInfoSize"/>
            </summary>
            <returns>A newly initialzed instance of <see cref="T:PInvoke.Kernel32.OSVERSIONINFOEX"/></returns>
        </member>
        <member name="T:PInvoke.Kernel32.OS_TYPE">
            <summary>
            The product type enumeration
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.OVERLAPPED">
            <summary>Contains information used in asynchronous (or overlapped) input and output (I/O).</summary>
            <remarks>
            Any unused members of this structure should always be initialized to zero before the structure is used in a function
            call. Otherwise, the function may fail and return <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_PARAMETER"/>.
            <para>
            The Offset and OffsetHigh members together represent a 64-bit file position.It is a byte offset from the start of
            the file or file-like device, and it is specified by the user; the system will not modify these values.The calling
            process must set this member before passing the OVERLAPPED structure to functions that use an offset, such as the
            ReadFile or WriteFile (and related) functions.
            </para>
            <para>
            You can use the HasOverlappedIoCompleted macro to check whether an asynchronous I/O operation has completed if
            GetOverlappedResult is too cumbersome for your application.
            </para>
            <para>You can use the CancelIo function to cancel an asynchronous I/O operation.</para>
            <para>
            A common mistake is to reuse an OVERLAPPED structure before the previous asynchronous operation has been
            completed. You should use a separate structure for each request. You should also create an event object for each thread
            that processes data. If you store the event handles in an array, you could easily wait for all events to be signaled
            using the WaitForMultipleObjects function.
            </para>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.Internal">
            <summary>
            The status code for the I/O request. When the request is issued, the system sets this member to STATUS_PENDING to indicate that the operation has not yet started. When the request is completed, the system sets this member to the status code for the completed request.
            <para>The Internal member was originally reserved for system use and its behavior may change.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.InternalHigh">
            <summary>
            The number of bytes transferred for the I/O request. The system sets this member if the request is completed without errors.
            <para>The InternalHigh member was originally reserved for system use and its behavior may change.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.Offset">
            <summary>
            The low-order portion of the file position at which to start the I/O request, as specified by the user.
            <para>This member is nonzero only when performing I/O requests on a seeking device that supports the concept of an offset(also referred to as a file pointer mechanism), such as a file.Otherwise, this member must be zero.</para>
            <para>For additional information, see Remarks.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.OffsetHigh">
            <summary>
            The high-order portion of the file position at which to start the I/O request, as specified by the user.
            <para>This member is nonzero only when performing I/O requests on a seeking device that supports the concept of an offset(also referred to as a file pointer mechanism), such as a file.Otherwise, this member must be zero.</para>
            <para>For additional information, see Remarks.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.hEvent">
            <summary>
            A handle to the event that will be set to a signaled state by the system when the operation has completed. The user must initialize this member either to zero or a valid event handle using the CreateEvent function before passing this structure to any overlapped functions. This event can then be used to synchronize simultaneous I/O requests for a device. For additional information, see Remarks.
            <para>Functions such as ReadFile and WriteFile set this handle to the nonsignaled state before they begin an I/O operation.When the operation has completed, the handle is set to the signaled state.</para>
            <para>Functions such as GetOverlappedResult and the synchronization wait functions reset auto-reset events to the nonsignaled state. Therefore, you should use a manual reset event; if you use an auto-reset event, your application can stop responding if you wait for the operation to complete and then call GetOverlappedResult with the bWait parameter set to TRUE.</para>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.PRODUCT_SUITE">
            <summary>
            The product suites available on the system.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_BACKOFFICE">
            <summary>
            Microsoft BackOffice components are installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_BLADE">
            <summary>
            Windows Server 2003, Web Edition is installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_COMPUTE_SERVER">
            <summary>
            Windows Server 2003, Compute Cluster Edition is installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_DATACENTER">
            <summary>
            Windows Server 2008 Datacenter, Windows Server 2003, Datacenter Edition, or Windows 2000 Datacenter Server is installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_ENTERPRISE">
            <summary>
            Windows Server 2008 Enterprise, Windows Server 2003, Enterprise Edition, or Windows 2000 Advanced Server is installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_EMBEDDEDNT">
            <summary>
            Windows XP Embedded is installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_PERSONAL">
            <summary>
            Windows Vista Home Premium, Windows Vista Home Basic, or Windows XP Home Edition is installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SINGLEUSERTS">
            <summary>
            Remote Desktop is supported, but only one interactive session is supported.
            This value is set unless the system is running in application server mode.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS">
            <summary>
            Microsoft Small Business Server was once installed on the system, but may have been upgraded to another version of Windows.
            </summary>
            <remarks>
             You should not rely solely on the <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS"/> flag to determine whether Small Business Server is currently installed.
             Both this flag and the <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS_RESTRICTED"/> flag are set when this product suite is installed. If you upgrade this
             installation to Windows Server, Standard Edition, the <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS_RESTRICTED"/> flag is cleared, but the
             <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS"/> flag remains set, which, in this case, indicates that Small Business Server was previously installed on
             this system. If this installation is further upgraded to Windows Server, Enterprise Edition, the <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS"/> flag
             remains set.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS_RESTRICTED">
            <summary>
            Microsoft Small Business Server is installed with the restrictive client license in force.
            For more information about this flag bit, see the remarks for <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS"/> flag.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_STORAGE_SERVER">
            <summary>
            Windows Storage Server 2003 R2 or Windows Storage Server 2003 is installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_TERMINAL">
            <summary>
            Terminal Services is installed. This value is always set. If <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_TERMINAL"/> is set but <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SINGLEUSERTS"/> is not set,
            the operating system is running in application server mode.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_WH_SERVER">
            <summary>
            Windows Home Server is installed.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.SafeFindFilesHandle">
            <summary>
            Represents a Win32 handle that can be closed with <see cref="M:PInvoke.Kernel32.FindClose(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeFindFilesHandle.Invalid">
            <summary>
            An invalid handle that may be used in place of <see cref="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE"/>.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeFindFilesHandle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeFindFilesHandle"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeFindFilesHandle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeFindFilesHandle"/> class.
            </summary>
            <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
                <see langword="true" /> to have the native handle released when this safe handle is disposed or finalized;
                <see langword="false" /> otherwise.
            </param>
        </member>
        <member name="P:PInvoke.Kernel32.SafeFindFilesHandle.IsInvalid">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.SafeFindFilesHandle.ReleaseHandle">
            <inheritdoc />
        </member>
        <member name="T:PInvoke.Kernel32.SafeLibraryHandle">
            <summary>
            Represents a library handle that can be closed with <see cref="M:PInvoke.Kernel32.FreeLibrary(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeLibraryHandle.Null">
            <summary>
            A handle that may be used in place of <see cref="F:System.IntPtr.Zero"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeLibraryHandle.Invalid">
            <summary>
            An invalid handle that may be used in place of <see cref="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE"/>.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeLibraryHandle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeLibraryHandle"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeLibraryHandle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeLibraryHandle"/> class.
            </summary>
            <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
                <see langword="true" /> to have the native handle released when this safe handle is disposed or finalized;
                <see langword="false" /> otherwise.
            </param>
        </member>
        <member name="P:PInvoke.Kernel32.SafeLibraryHandle.IsInvalid">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.SafeLibraryHandle.ReleaseHandle">
            <inheritdoc />
        </member>
        <member name="T:PInvoke.Kernel32.SafeObjectHandle">
            <summary>
            Represents a Win32 handle that can be closed with <see cref="M:PInvoke.Kernel32.CloseHandle(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeObjectHandle.Invalid">
            <summary>
            An invalid handle that may be used in place of <see cref="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeObjectHandle.Null">
            <summary>
            A handle that may be used in place of <see cref="F:System.IntPtr.Zero"/>.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeObjectHandle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeObjectHandle"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeObjectHandle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeObjectHandle"/> class.
            </summary>
            <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
                <see langword="true" /> to have the native handle released when this safe handle is disposed or finalized;
                <see langword="false" /> otherwise.
            </param>
        </member>
        <member name="P:PInvoke.Kernel32.SafeObjectHandle.IsInvalid">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.SafeObjectHandle.ReleaseHandle">
            <inheritdoc />
        </member>
        <member name="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES">
            <summary>
            The SECURITY_ATTRIBUTES structure contains the security descriptor for an object and specifies whether the handle retrieved by specifying this structure is inheritable. This structure provides security settings for objects created by various functions, such as CreateFile, CreatePipe, CreateProcess, RegCreateKeyEx, or RegSaveKeyEx.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.nLength">
            <summary>
            The size, in bytes, of this structure.
            This value is set by the constructor to the size of the <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor">
            <summary>
            A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_DESCRIPTOR"/> structure that controls access to the object. If the value of this member is NULL, the object is assigned the default security descriptor associated with the access token of the calling process. This is not the same as granting access to everyone by assigning a NULL discretionary access control list (DACL). By default, the default DACL in the access token of a process allows access only to the user represented by the access token.
            For information about creating a security descriptor, see Creating a Security Descriptor.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.bInheritHandle">
            <summary>
            A Boolean value that specifies whether the returned handle is inherited when a new process is created. If this member is TRUE, the new process inherits the handle.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.SECURITY_ATTRIBUTES.InheritHandle">
            <summary>
            Gets a value indicating whether the returned handle is inherited when a new process is created. If this member is TRUE, the new process inherits the handle.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SECURITY_ATTRIBUTES.Create">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> struct.
            </summary>
            <returns>A new instance of <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/>.</returns>
        </member>
        <member name="T:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL">
            <summary>
            Contains values that specify security impersonation levels. Security impersonation levels govern the degree to which a server process can act on behalf of a client process.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL.SecurityAnonymous">
            <summary>
            The server process cannot obtain identification information about the client, and it cannot impersonate the client. It is defined with no value given, and thus, by ANSI C rules, defaults to a value of zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL.SecurityIdentification">
            <summary>
            The server process can obtain information about the client, such as security identifiers and privileges, but it cannot impersonate the client. This is useful for servers that export their own objects, for example, database products that export tables and views. Using the retrieved client-security information, the server can make access-validation decisions without being able to use other services that are using the client's security context.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation">
            <summary>
            The server process can impersonate the client's security context on its local system. The server cannot impersonate the client on remote systems.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL.SecurityDelegation">
            <summary>
            The server process can impersonate the client's security context on remote systems.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.SYSTEMTIME">
            <summary>
            Specifies a date and time, using individual members for the month, day, year, weekday, hour, minute, second, and millisecond.
            The time is either in coordinated universal time (UTC) or local time, depending on the function that is being called.
            </summary>
            <remarks>
            It is not recommended that you add and subtract values from the <see cref="T:PInvoke.Kernel32.SYSTEMTIME"/> structure to obtain relative times.
            Instead, you should
            Convert the <see cref="T:PInvoke.Kernel32.SYSTEMTIME"/> structure to a <see cref="T:PInvoke.Kernel32.FILETIME"/> structure.
            <list type="bullet">
            <item>
            <desccription>Copy the resulting <see cref="T:PInvoke.Kernel32.FILETIME"/> structure to a ULARGE_INTEGER structure.</desccription>
            </item>
            <item>
            <desccription>Use normal 64-bit arithmetic on the ULARGE_INTEGER value.</desccription>
            </item>
            <item>
            <description>The system can periodically refresh the time by synchronizing with a time source.</description>
            </item>
            </list>
            Because the system time can be adjusted either forward or backward, do not compare system time readings to determine elapsed time.
            Instead, use one of the methods described in Windows Time.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wYear">
            <summary>
            The year. The valid values for this member are 1601 through 30827.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wMonth">
            <summary>
            The month. This member can be one of the following values.
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>1</term>
            <term>January</term>
            </item>
            <item>
            <term>2</term>
            <term>February</term>
            </item>
            <item>
            <term>3</term>
            <term>March</term>
            </item>
            <item>
            <term>4</term>
            <term>April</term>
            </item>
            <item>
            <term>5</term>
            <term>May</term>
            </item>
            <item>
            <term>6</term>
            <term>June</term>
            </item>
            <item>
            <term>7</term>
            <term>July</term>
            </item>
            <item>
            <term>8</term>
            <term>August</term>
            </item>
            <item>
            <term>9</term>
            <term>September</term>
            </item>
            <item>
            <term>10</term>
            <term>October</term>
            </item>
            <item>
            <term>11</term>
            <term>November</term>
            </item>
            <item>
            <term>12</term>
            <term>December</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wDayOfWeek">
            <summary>
            The day of the week. This member can be one of the following values.
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>Sunday</term>
            </item>
            <item>
            <term>1</term>
            <term>Monday</term>
            </item>
            <item>
            <term>2</term>
            <term>Tuesday</term>
            </item>
            <item>
            <term>3</term>
            <term>Wednesday</term>
            </item>
            <item>
            <term>4</term>
            <term>Thursday</term>
            </item>
            <item>
            <term>5</term>
            <term>Friday</term>
            </item>
            <item>
            <term>6</term>
            <term>Saturday</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wDay">
            <summary>
            The day of the month. The valid values for this member are 1 through 31.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wHour">
            <summary>
            The hour. The valid values for this member are 0 through 23.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wMinute">
            <summary>
            The minute. The valid values for this member are 0 through 59.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wSecond">
            <summary>
            The second. The valid values for this member are 0 through 59.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wMilliseconds">
            <summary>
            The millisecond. The valid values for this member are 0 through 999.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.VER_CONDITION">
            <summary>
            The operator to be used for the comparison. The <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function uses this operator to compare a specified
            attribute value to the corresponding value for the currently running system.
            </summary>
            <remarks>
            For all values of dwTypeBitMask other than VER_SUITENAME, this parameter can be one of the following values:
                - <see cref="F:PInvoke.Kernel32.VER_CONDITION.VER_EQUAL"/>
                - <see cref="F:PInvoke.Kernel32.VER_CONDITION.VER_GREATER"/>
                - <see cref="F:PInvoke.Kernel32.VER_CONDITION.VER_GREATER_EQUAL"/>
                - <see cref="F:PInvoke.Kernel32.VER_CONDITION.VER_LESS"/>
                - <see cref="F:PInvoke.Kernel32.VER_CONDITION.VER_LESS_EQUAL"/>
            If dwTypeBitMask is VER_SUITENAME, this parameter can be one of the following values:
                - <see cref="F:PInvoke.Kernel32.VER_CONDITION.VER_AND"/>
                - <see cref="F:PInvoke.Kernel32.VER_CONDITION.VER_OR"/>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.VER_CONDITION.VER_EQUAL">
            <summary>
            The current value must be equal to the specified value.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_CONDITION.VER_GREATER">
            <summary>
            The current value must be greater than the specified value.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_CONDITION.VER_GREATER_EQUAL">
            <summary>
            The current value must be greater than or equal to the specified value.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_CONDITION.VER_LESS">
            <summary>
            The current value must be less than the specified value.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_CONDITION.VER_LESS_EQUAL">
            <summary>
            The current value must be less than or equal to the specified value.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_CONDITION.VER_AND">
            <summary>
            All product suites specified in the wSuiteMask member must be present in the current system.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_CONDITION.VER_OR">
            <summary>
            At least one of the specified product suites must be present in the current system.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.VER_MASK">
            <summary>
            A mask that indicates the member of the <see cref="T:PInvoke.Kernel32.OSVERSIONINFOEX"/> structure whose comparison operator is being set.
            This value corresponds to one of the bits specified in the dwTypeMask parameter for the <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_BUILDNUMBER">
            <summary>
            dwBuildNumber
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_MAJORVERSION">
            <summary>
            dwBuildNumber
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_MINORVERSION">
            <summary>
            dwMinorVersion
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_PLATFORMID">
            <summary>
            dwPlatformId
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_PRODUCT_TYPE">
            <summary>
            wProductType
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_SERVICEPACKMAJOR">
            <summary>
            wServicePackMajor
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_SERVICEPACKMINOR">
            <summary>
            wServicePackMinor
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_SUITENAME">
            <summary>
            wSuiteMask
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.WaitForSingleObjectResult">
            <summary>
            Values that may be returned from the <see cref="M:PInvoke.Kernel32.WaitForSingleObject(System.Runtime.InteropServices.SafeHandle,System.Int32)"/> function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WaitForSingleObjectResult.WAIT_ABANDONED">
            <summary>
            The specified object is a mutex object that was not released by the thread that owned the mutex object before the owning thread terminated. Ownership of the mutex object is granted to the calling thread and the mutex state is set to nonsignaled.
            If the mutex was protecting persistent state information, you should check it for consistency.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WaitForSingleObjectResult.WAIT_OBJECT_0">
            <summary>
            The state of the specified object is signaled.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WaitForSingleObjectResult.WAIT_TIMEOUT">
            <summary>
            The time-out interval elapsed, and the object's state is nonsignaled.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WaitForSingleObjectResult.WAIT_FAILED">
            <summary>
            The function has failed. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.dwFileAttributes">
            <summary>
            The file attributes of a file.
            </summary>
            <remarks>
            Although the enum we bind to here exists in the .NET Framework
            as System.IO.FileAttributes, it is not reliably present.
            Portable profiles don't include it, for example. So we have to define our own.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.ftCreationTime">
            <summary>
            A FILETIME structure that specifies when a file or directory was created.
            If the underlying file system does not support creation time, this member is zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.ftLastAccessTime">
            <summary>
            A FILETIME structure.
            For a file, the structure specifies when the file was last read from, written to, or for executable files, run.
            For a directory, the structure specifies when the directory is created.If the underlying file system does not support last access time, this member is zero.
            On the FAT file system, the specified date for both files and directories is correct, but the time of day is always set to midnight.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.ftLastWriteTime">
            <summary>
            A FILETIME structure.
            For a file, the structure specifies when the file was last written to, truncated, or overwritten, for example, when WriteFile or SetEndOfFile are used.The date and time are not updated when file attributes or security descriptors are changed.
            For a directory, the structure specifies when the directory is created.If the underlying file system does not support last write time, this member is zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.nFileSizeHigh">
            <summary>
            The high-order DWORD value of the file size, in bytes.
            This value is zero unless the file size is greater than MAXDWORD.
            The size of the file is equal to(nFileSizeHigh* (MAXDWORD+1)) + nFileSizeLow.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.nFileSizeLow">
            <summary>
            The low-order DWORD value of the file size, in bytes.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.dwReserved0">
            <summary>
            If the dwFileAttributes member includes the FILE_ATTRIBUTE_REPARSE_POINT attribute, this member specifies the reparse point tag.
            Otherwise, this value is undefined and should not be used.
            For more information see Reparse Point Tags.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.dwReserved1">
            <summary>
            Reserved for future use.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.cFileName">
            <summary>
            The name of the file.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.cAlternateFileName">
            <summary>
            An alternative name for the file.
            This name is in the classic 8.3 file name format.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MAX_MODULE_NAME32">
            <summary>
            The maximum length of a name for a process module.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MAX_PATH">
            <summary>
            The maximum length of file paths for most Win32 functions.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE">
            <summary>
            Constant for invalid handle value
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.FindFirstFileEx(System.String,PInvoke.Kernel32.FINDEX_INFO_LEVELS,PInvoke.Kernel32.WIN32_FIND_DATA@,PInvoke.Kernel32.FINDEX_SEARCH_OPS,System.Void*,PInvoke.Kernel32.FindFirstFileExFlags)">
            <summary>
            Searches a directory for a file or subdirectory with a name and attributes that match those specified.
            For the most basic version of this function, see FindFirstFile.
            To perform this operation as a transacted operation, use the FindFirstFileTransacted function.
            </summary>
            <param name="lpFileName">
            The directory or path, and the file name, which can include wildcard characters, for example, an asterisk (*) or a question mark (?).
            This parameter should not be NULL, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\).
            If the string ends with a wildcard, period, or directory name, the user must have access to the root and all subdirectories on the path.
            In the ANSI version of this function, the name is limited to MAX_PATH characters. To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming a File.
            </param>
            <param name="fInfoLevelId">
            The information level of the returned data.
            This parameter is one of the <see cref="T:PInvoke.Kernel32.FINDEX_INFO_LEVELS"/> enumeration values.
            </param>
            <param name="lpFindFileData">
            A pointer to the buffer that receives the file data.
            The pointer type is determined by the level of information that is specified in the <paramref name="fInfoLevelId"/> parameter.
            </param>
            <param name="fSearchOp">
            The type of filtering to perform that is different from wildcard matching.
            This parameter is one of the <see cref="T:PInvoke.Kernel32.FINDEX_SEARCH_OPS"/> enumeration values.
            </param>
            <param name="lpSearchFilter">
            A pointer to the search criteria if the specified <paramref name="fSearchOp"/> needs structured search information.
            At this time, none of the supported fSearchOp values require extended search information. Therefore, this pointer must be NULL.
            </param>
            <param name="dwAdditionalFlags">Specifies additional flags that control the search.</param>
            <returns>
            If the function succeeds, the return value is a search handle used in a subsequent call to FindNextFile or FindClose, and the lpFindFileData parameter contains information about the first file or directory found.
            If the function fails or fails to locate files from the search string in the lpFileName parameter, the return value is INVALID_HANDLE_VALUE and the contents of lpFindFileData are indeterminate.To get extended error information, call the <see cref="M:PInvoke.Kernel32.GetLastError"/> function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.Text.StringBuilder,System.Int32,System.IntPtr[])">
            <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested.
            </summary>
            <param name="dwFlags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
            <param name="lpSource">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name="dwFlags"/> parameter.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name="dwMessageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
            </param>
            <param name="dwLanguageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name="lpBuffer">
            A pointer to a buffer that receives the null-terminated string that specifies the formatted message. If dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER" />, the function allocates a buffer using the LocalAlloc function, and places the pointer to the buffer at the address specified in lpBuffer.
            This buffer cannot be larger than 64K bytes.
            </param>
            <param name="nSize">
            If the <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> flag is not set, this parameter specifies the size of the output buffer, in TCHARs. If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> is set,
            this parameter specifies the minimum number of TCHARs to allocate for an output buffer.
            The output buffer cannot be larger than 64K bytes.
            </param>
            <param name="Arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <returns>
            If the function succeeds, the return value is the number of TCHARs stored in the output buffer, excluding the terminating null character.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetCurrentThreadId">
            <summary>
            Retrieves the thread identifier of the calling thread.
            </summary>
            <returns>The thread identifier of the calling thread.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetCurrentProcessId">
            <summary>Retrieves the process identifier of the calling process.</summary>
            <returns>The process identifier of the calling process.</returns>
            <remarks>Until the process terminates, the process identifier uniquely identifies the process throughout the system.</remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetProcessId(System.IntPtr)">
            <summary>
            Retrieves the process identifier of the specified process.
            </summary>
            <param name="Process">A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see Process Security and Access Rights.</param>
            <returns>The process identifier of the specified process.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetCurrentProcess">
            <summary>Retrieves a pseudo handle for the current process.</summary>
            <returns>The return value is a pseudo handle to the current process.</returns>
            <remarks>
                A pseudo handle is a special constant, currently (HANDLE)-1, that is interpreted as the current process handle. For
                compatibility with future operating systems, it is best to call GetCurrentProcess instead of hard-coding this
                constant value. The calling process can use a pseudo handle to specify its own process whenever a process handle is
                required. Pseudo handles are not inherited by child processes.
                <para>This handle has the PROCESS_ALL_ACCESS access right to the process object.</para>
                <para>
                    Windows Server 2003 and Windows XP:  This handle has the maximum access allowed by the security descriptor of
                    the process to the primary token of the process.
                </para>
                <para>
                    A process can create a "real" handle to itself that is valid in the context of other processes, or that can
                    be inherited by other processes, by specifying the pseudo handle as the source handle in a call to the
                    DuplicateHandle function. A process can also use the OpenProcess function to open a real handle to itself.
                </para>
                <para>
                    The pseudo handle need not be closed when it is no longer needed. Calling the <see cref="M:PInvoke.Kernel32.CloseHandle(System.IntPtr)" />
                    function with a pseudo handle has no effect.If the pseudo handle is duplicated by DuplicateHandle, the
                    duplicate handle must be closed.
                </para>
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.CancelIoEx(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Marks any outstanding I/O operations for the specified file handle. The function only cancels I/O operations
                in the current process, regardless of which thread created the I/O operation.
            </summary>
            <param name="hFile">A handle to the file.</param>
            <param name="lpOverlapped">
                A pointer to an <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> data structure that contains the data used for asynchronous I/O.
                <para>If this parameter is NULL, all I/O requests for the hFile parameter are canceled.</para>
                <para>
                    If this parameter is not NULL, only those specific I/O requests that were issued for the file with the
                    specified
                    <paramref name="lpOverlapped" /> overlapped structure are marked as canceled, meaning that you can cancel one
                    or more requests, while the CancelIo function cancels all outstanding requests on a file handle.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is nonzero. The cancel operation for all pending I/O operations issued
                by the calling process for the specified file handle was successfully requested. The application must not free or
                reuse the <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure associated with the canceled I/O operations until they have
                completed. The thread can use the GetOverlappedResult function to determine when the I/O operations themselves have
                been completed.
                <para>
                    If the function fails, the return value is 0 (zero). To get extended error information, call the
                    <see cref="M:PInvoke.Kernel32.GetLastError" /> function.
                </para>
                <para>
                    If this function cannot find a request to cancel, the return value is 0 (zero), and
                    <see cref="M:PInvoke.Kernel32.GetLastError" />
                    returns <see cref="F:PInvoke.Win32ErrorCode.ERROR_NOT_FOUND" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file
                pointer if supported by the device.
                <para>
                    This function is designed for both synchronous and asynchronous operations. For a similar function designed
                    solely for asynchronous operation, see ReadFileEx.
                </para>
            </summary>
            <param name="hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive,
                socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
                <para>
                    For asynchronous read operations, hFile can be any handle that is opened with the FILE_FLAG_OVERLAPPED flag
                    by the CreateFile function, or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name="lpBuffer">
                A pointer to the buffer that receives the data read from a file or device.
                <para>
                    This buffer must remain valid for the duration of the read operation. The caller must not use this buffer
                    until the read operation is completed.
                </para>
            </param>
            <param name="nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <param name="lpNumberOfBytesRead">
                A pointer to the variable that receives the number of bytes read when using a synchronous hFile parameter. ReadFile
                sets this value to zero before doing any work or error checking. Use <see langword="null" /> for this parameter if
                this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be <see langword="null" /> only when the <paramref name="lpOverlapped" /> parameter is not
                    <see langword="null" />.
                </para>
            </param>
            <param name="lpOverlapped">
                A pointer to an <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise it can be <see langword="null" />.
                <para>
                    If hFile is opened with FILE_FLAG_OVERLAPPED, the <paramref name="lpOverlapped" /> parameter must point to a
                    valid and unique <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure, otherwise the function can incorrectly report that the
                    read operation is complete.
                </para>
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start reading from the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword="true" />.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword="false" />. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref="M:PInvoke.Kernel32.GetLastError" /> code <see cref="F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING" /> is not a failure;
                    it designates the read operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Writes data to the specified file or input/output (I/O) device.
                <para>
                    This function is designed for both synchronous and asynchronous operation. For a similar function designed
                    solely for asynchronous operation, see WriteFileEx.
                </para>
            </summary>
            <param name="hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
                <para>
                    For asynchronous write operations, hFile can be any handle opened with the CreateFile function using the
                    FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name="lpBuffer">
                A pointer to the buffer containing the data to be written to the file or device.
                <para>
                    This buffer must remain valid for the duration of the write operation. The caller must not use this buffer
                    until the write operation is completed.
                </para>
            </param>
            <param name="nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <param name="lpNumberOfBytesWritten">
                A pointer to the variable that receives the number of bytes written when using a synchronous hFile parameter.
                WriteFile sets this value to zero before doing any work or error checking. Use <see langword="null" />
                for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be NULL only when the <paramref name="lpOverlapped" /> parameter is not
                    <see langword="null" />.
                </para>
            </param>
            <param name="lpOverlapped">
                A pointer to an <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise this parameter can be NULL.
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start writing to the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
                <para>
                    To write to the end of file, specify both the Offset and OffsetHigh members of the <see cref="T:PInvoke.Kernel32.OVERLAPPED" />
                    structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function to open
                    hFile using FILE_APPEND_DATA access.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword="true" />.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword="false" />. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref="M:PInvoke.Kernel32.GetLastError" /> code <see cref="F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING" /> is not a failure;
                    it designates the write operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SuspendThread(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Suspends the specified thread.
            A 64-bit application can suspend a WOW64 thread using the Wow64SuspendThread function (desktop only).
            </summary>
            <param name="hThread">
            A handle to the thread that is to be suspended.
            The handle must have the THREAD_SUSPEND_RESUME access right. For more information, see Thread Security and Access Rights.
            </param>
            <returns>
            If the function succeeds, the return value is the thread's previous suspend count; otherwise, it is (DWORD) -1. To get extended error information, use the <see cref="M:PInvoke.Kernel32.GetLastError"/> function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ResumeThread(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Decrements a thread's suspend count. When the suspend count is decremented to zero, the execution of the thread is resumed.
            </summary>
            <param name="hThread">
            A handle to the thread to be restarted.
            This handle must have the THREAD_SUSPEND_RESUME access right. For more information, see Thread Security and Access Rights.
            </param>
            <returns>
            If the function succeeds, the return value is the thread's previous suspend count.
            If the function fails, the return value is (DWORD) -1. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WaitForSingleObject(System.Runtime.InteropServices.SafeHandle,System.Int32)">
            <summary>
            Waits until the specified object is in the signaled state or the time-out interval elapses.
            To enter an alertable wait state, use the WaitForSingleObjectEx function. To wait for multiple objects, use WaitForMultipleObjects.
            </summary>
            <param name="hHandle">
            A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section.
            If this handle is closed while the wait is still pending, the function's behavior is undefined.
            The handle must have the SYNCHRONIZE access right. For more information, see Standard Access Rights.
            </param>
            <param name="dwMilliseconds">
            The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is signaled or the interval elapses. If dwMilliseconds is zero, the function does not enter a wait state if the object is not signaled; it always returns immediately. If dwMilliseconds is INFINITE, the function will return only when the object is signaled.
            See MSDN docs for more information.
            </param>
            <returns>
            If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CloseHandle(System.IntPtr)">
            <summary>
            Closes an open object handle.
            </summary>
            <param name="hObject">A valid handle to an open object.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero.To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FlushFileBuffers(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>Flushes the buffers of a specified file and causes all buffered data to be written to a file.</summary>
            <param name="hFile">
                A handle to the open file.
                <para>
                    The file handle must have the GENERIC_WRITE access right. For more information, see File Security and Access
                    Rights.
                </para>
                <para>If hFile is a handle to a communications device, the function only flushes the transmit buffer.</para>
                <para>
                    If hFile is a handle to the server end of a named pipe, the function does not return until the client has
                    read all buffered data from the pipe.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
                <para>
                    The function fails if hFile is a handle to the console output. That is because the console output is not
                    buffered. The function returns FALSE, and <see cref="M:PInvoke.Kernel32.GetLastError" /> returns
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_HANDLE" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateMutex(PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,System.String)">
            <summary>
            Creates or opens a named or unnamed mutex object.
            </summary>
            <param name="lpMutexAttributes">
            A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure. If this parameter is NULL, the handle cannot be inherited by child processes.
            The <see cref="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a security descriptor for the new mutex. If <paramref name="lpMutexAttributes"/> is NULL, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see Synchronization Object Security and Access Rights.
            </param>
            <param name="bInitialOwner">
            If this value is TRUE and the caller created the mutex, the calling thread obtains initial ownership of the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the caller created the mutex, see the Return Values section.
            </param>
            <param name="lpName">
            The name of the mutex object. The name is limited to MAX_PATH characters. Name comparison is case sensitive.
            If lpName matches the name of an existing named mutex object, this function requests the MUTEX_ALL_ACCESS access right. In this case, the bInitialOwner parameter is ignored because it has already been set by the creating process. If the lpMutexAttributes parameter is not NULL, it determines whether the handle can be inherited, but its security-descriptor member is ignored.
            If lpName is NULL, the mutex object is created without a name.
            If lpName matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the GetLastError function returns ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace.
            The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see Kernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.
            The object can be created in a private namespace. For more information, see Object Namespaces.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the newly created mutex object.
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, GetLastError returns ERROR_ALREADY_EXISTS, bInitialOwner is ignored, and the calling thread is not granted ownership. However, if the caller has limited access rights, the function will fail with ERROR_ACCESS_DENIED and the caller should use the OpenMutex function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetProcAddress(PInvoke.Kernel32.SafeLibraryHandle,System.String)">
            <summary>
            Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).
            </summary>
            <param name="hModule">A handle to the DLL module that contains the function or variable. The LoadLibrary, LoadLibraryEx, or GetModuleHandle function returns this handle.</param>
            <param name="procName">The function or variable name, or the function's ordinal value. If this parameter is an ordinal value, it must be in the low-order word; the high-order word must be zero.</param>
            <returns>
            If the function succeeds, the return value is the address of the exported function or variable.
            If the function fails, the return value is NULL.To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>This function does not retrieve handles for modules that were loaded using the LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE flag.</remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetTickCount">
            <summary>
            Retrieves the number of milliseconds that have elapsed since the system was started, up to 49.7 days.
            </summary>
            <returns>The return value is the number of milliseconds that have elapsed since the system was started.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetTickCount64">
            <summary>
            Retrieves the number of milliseconds that have elapsed since the system was started.
            </summary>
            <returns>The number of milliseconds.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetSystemTime(PInvoke.Kernel32.SYSTEMTIME*)">
            <summary>
            Retrieves the current system date and time. The system time is expressed in Coordinated Universal Time (UTC).
            To retrieve the current system date and time in local time, use the GetLocalTime function.
            </summary>
            <param name="lpSystemTime">
            A pointer to a SYSTEMTIME structure to receive the current system date and time.
            The lpSystemTime parameter must not be NULL. Using NULL will result in an access violation.
            </param>
        </member>
        <member name="M:PInvoke.Kernel32.SetLastError(System.UInt32)">
            <summary>
            Sets the last-error code for the calling thread.
            </summary>
            <param name="dwErrCode">The last-error code for the thread.</param>
        </member>
        <member name="M:PInvoke.Kernel32.VerSetConditionMask(System.Int64,PInvoke.Kernel32.VER_MASK,PInvoke.Kernel32.VER_CONDITION)">
            <summary>
            Sets the bits of a 64-bit value to indicate the comparison operator to use for a specified operating system version
            attribute. This function is used to build the dwlConditionMask parameter of the <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function.
            </summary>
            <param name="ConditionMask">A value to be passed as the dwlConditionMask parameter of the <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function.
            The function stores the comparison information in the bits of this variable. Before the first call to <see cref="M:PInvoke.Kernel32.VerSetConditionMask(System.Int64,PInvoke.Kernel32.VER_MASK,PInvoke.Kernel32.VER_CONDITION)"/>,
            initialize this variable to zero. For subsequent calls, pass in the variable used in the previous call.</param>
            <param name="TypeMask">A mask that indicates the member of the <see cref="T:PInvoke.Kernel32.OSVERSIONINFOEX"/> structure whose comparison operator
            is being set. This value corresponds to one of the bits specified in the dwTypeMask parameter for the
            <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function</param>
            <param name="Condition">The operator to be used for the comparison. The <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function uses this
            operator to compare a specified attribute value to the corresponding value for the currently running system.</param>
            <returns>The function returns the condition mask value.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)">
             <summary>
             Compares a set of operating system version requirements to the corresponding values for the currently
             running version of the system.This function is subject to manifest-based behavior.
             </summary>
             <param name="lpVersionInformation">
             A pointer to an OSVERSIONINFOEX structure containing the operating system version requirements to compare. The <paramref name="dwTypeMask"/>
             parameter indicates the members of this structure that contain information to compare.You must set the
             <see cref="F:PInvoke.Kernel32.OSVERSIONINFOEX.dwOSVersionInfoSize"/> member of this structure to <code>Marshal.SizeOf(typeof(OSVERSIONINFOEX))</code>. You must
             also specify valid data for the members indicated by <paramref name="dwTypeMask"/>. The function ignores structure members for which the
             corresponding <paramref name="dwTypeMask"/> bit is not set
             </param>
             <param name="dwTypeMask">A mask that indicates the members of the <see cref="T:PInvoke.Kernel32.OSVERSIONINFOEX"/> structure to be tested.</param>
             <param name="dwlConditionMask">The type of comparison to be used for each <paramref name="lpVersionInformation"/> member being compared. To build this value,
             call the <see cref="M:PInvoke.Kernel32.VerSetConditionMask(System.Int64,PInvoke.Kernel32.VER_MASK,PInvoke.Kernel32.VER_CONDITION)"/> function once for each <see cref="T:PInvoke.Kernel32.OSVERSIONINFOEX"/> member being compared.</param>
             <returns>
             <para>
             If the currently running operating system satisfies the specified requirements, the return value is a nonzero value.
             </para>
             <para>
             If the current system does not satisfy the requirements, the return value is zero and <see cref="M:PInvoke.Kernel32.GetLastError"/> returns <see cref="F:PInvoke.Win32ErrorCode.ERROR_OLD_WIN_VERSION"/>.
             </para>
             <para>
             If the function fails, the return value is zero and <see cref="M:PInvoke.Kernel32.GetLastError"/> returns an error code other than <see cref="F:PInvoke.Win32ErrorCode.ERROR_OLD_WIN_VERSION"/>.
             </para>
             </returns>
             <remarks>
             <para>
             The <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function retrieves version information about the currently running operating system and compares it to the valid
             members of the <paramref name="lpVersionInformation"/> structure. This enables you to easily determine the presence of a required set of
             operating system version conditions. It is preferable to use <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> rather than
             calling the GetVersionEx function to perform your own comparisons.
             </para>
             <para>
             Typically, <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> returns a nonzero value only if all specified tests succeed.
             However, major, minor, and service pack versions are tested in a hierarchical manner because the operating system version is a combination of
             these values. If a condition exists for the major version, it supersedes the conditions specified for minor version and service pack version.
             (You cannot test for major version greater than 5 and minor version less than or equal to 1. If you specify such a test, the function will
             change the request to test for a minor version greater than 1 because it is performing a greater than operation on the major version.)
             </para>
             <para>
             The function tests these values in this order: major version, minor version, and service pack version.The function continues testing values while
             they are equal, and stops when one of the values does not meet the specified condition.For example, if you test for a system greater than or
             equal to version 5.1 service pack 1, the test succeeds if the current version is 6.0. (The major version is greater than the specified version,
             so the testing stops.) In the same way, if you test for a system greater than or equal to version 5.1 service pack 1, the test succeeds if the
             current version is 5.2. (The minor version is greater than the specified versions, so the testing stops.) However, if you test for a system greater
             than or equal to version 5.1 service pack 1, the test fails if the current version is 5.0 service pack 2. (The minor version is not greater than
             the specified version, so the testing stops.)
             </para>
             <para>
             To verify a range of system versions, you must call <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> twice.For example, to verify
             that the system version is greater than 5.0 but less than or equal to 5.1, first call <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> to
             test that the major version is 5 and the minor version is greater than 0, then call <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
             again to test that the major version is 5 and the minor version is less than or equal to 1.
             </para>
             <para>
             Identifying the current operating system is usually not the best way to determine whether a particular operating system feature is present.
             This is because the operating system may have had new features added in a redistributable DLL. Rather than using GetVersionEx to determine the operating
             system platform or version number, test for the presence of the feature itself.
             </para>
             <para>
             To verify whether the current operating system is either the Media Center or Tablet PC version of Windows, call GetSystemMetrics.
             </para>
             <para>
             Windows 10:
                 <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> returns false when called by applications that do not have a
                 compatibility manifest for Windows 8.1 or Windows 10 if the <paramref name="lpVersionInformation"/> parameter is set so that it specifies
                 Windows 8.1 or Windows 10, even when the current operating system version is Windows 8.1 or Windows 10. Specifically,
                 <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> has the following behavior:
            
                 If the application has no manifest, <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> behaves as
                     if the operation system version is Windows 8 (6.2).
                 If the application has a manifest that contains the GUID that corresponds to Windows 8.1, <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
                     behaves as if the operation system version is Windows 8.1 (6.3).
                 If the application has a manifest that contains the GUID that corresponds to Windows 10, <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
                     behaves as if the operation system version is Windows 10 (10.0).
             </para>
             </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.FindClose(System.IntPtr)">
            <summary>
                Closes a file search handle opened by the FindFirstFile, FindFirstFileEx, FindFirstFileNameW,
                FindFirstFileNameTransactedW, FindFirstFileTransacted, FindFirstStreamTransactedW, or FindFirstStreamW functions.
            </summary>
            <param name="hFindFile">The file search handle.</param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FreeLibrary(System.IntPtr)">
            <summary>
                Frees the loaded dynamic-link library (DLL) module and, if necessary, decrements its reference count. When the
                reference count reaches zero, the module is unloaded from the address space of the calling process and the handle
                is no longer valid.
            </summary>
            <param name="hModule">
                A handle to the loaded library module. The LoadLibrary, LoadLibraryEx, GetModuleHandle, or
                GetModuleHandleEx function returns this handle.
            </param>
            <returns>
                If the function succeeds, the return value is a nonzero value.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.IntPtr[],System.Int32)">
            <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested.
            </summary>
            <param name="dwFlags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            The <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ARGUMENT_ARRAY"/> flag is always added
            and the <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> flag is always suppressed by this helper method
            </param>
            <param name="lpSource">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name="dwFlags"/> parameter.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name="dwMessageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
            </param>
            <param name="dwLanguageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name="Arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <param name="maxAllowedBufferSize">The maximum size of the returned string. If exceeded, <c>null</c> is returned.</param>
            <returns>
            If the function succeeds, the return value is the number of TCHARs stored in the output buffer, excluding the terminating null character.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetLastError">
            <summary>
                Returns the error code returned by the last unmanaged function that was called using platform invoke that has
                the <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> flag set.
            </summary>
            <returns>
                The last error code set by a call to the Win32 SetLastError function.
                <para>
                    The Return Value section of the documentation for each function that sets the last-error code notes the
                    conditions under which the function sets the last-error code. Most functions that set the thread's last-error
                    code set it when they fail. However, some functions also set the last-error code when they succeed. If the
                    function is not documented to set the last-error code, the value returned by this function is simply the most
                    recent last-error code to have been set; some functions set the last-error code to
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_SUCCESS" /> on success and others do not.
                </para>
            </returns>
            <remarks>
                This method exists because it is not safe to make a direct platform invoke call to GetLastError to obtain this
                information. If you want to access this error code, you must call <see cref="M:PInvoke.Kernel32.GetLastError" /> instead of writing
                your own platform invoke definition for GetLastError and calling it. The common language runtime can make internal
                calls to APIs that overwrite the GetLastError maintained by the operating system.
                <para>
                    You can use this method to obtain error codes only if you apply the <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> to the
                    method signature and set the <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> field to true. The process for this
                    varies depending upon the source language used: C# and C++ are false by default, but the Declare statement in
                    Visual Basic is true.
                </para>
            </remarks>
            <devremarks>
                See
                https://stackoverflow.com/questions/17918266/winapi-getlasterror-vs-marshal-getlastwin32error/17918729#17918729 for
                more details.
            </devremarks>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)">
            <summary>Writes data synchronously to the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
            </param>
            <param name="lpBuffer">A pointer to the buffer containing the data to be written to the file or device.</param>
            <param name="nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <returns>The number of bytes written.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Write failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.ArraySegment{System.Byte})">
            <summary>Writes data synchronously to the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
            </param>
            <param name="lpBuffer">The buffer containing the data to be written to the file or device.</param>
            <returns>The number of bytes written.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Write failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)">
            <summary>Reads data synchronously from the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer,
                tape drive, socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
            </param>
            <param name="lpBuffer">A pointer to the buffer that receives the data read from a file or device.</param>
            <param name="nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <returns>The number of bytes read.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Read failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.ArraySegment{System.Byte})">
            <summary>Reads data synchronously from the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer,
                tape drive, socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
            </param>
            <param name="lpBuffer">A buffer that receives the data read from a file or device.</param>
            <returns>The number of bytes read.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Read failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Int32)">
            <summary>Reads data synchronously from the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer,
                tape drive, socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
            </param>
            <param name="nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <returns>
                The data that has been read. The segment returned might have a size smaller than
                <paramref name="nNumberOfBytesToRead" /> if less bytes than requested have been read.
            </returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Read failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.TryGetErrorMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.Text.StringBuilder,System.IntPtr[],System.String@)">
            <summary>
            Tries to get the error message text using the supplied buffer.
            </summary>
            <param name="flags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
            <param name="source">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name="flags"/> parameter.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name="messageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
            </param>
            <param name="languageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name="sb">The buffer to use for acquiring the message.</param>
            <param name="arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <param name="errorMsg">Receives the resulting error message.</param>
            <returns><c>true</c> if the attempt is successful; <c>false</c> otherwise.</returns>
        </member>
        <member name="T:PInvoke.Kernel32.CharacterAttributesFlags">
            <summary>
            The character attributes for console input/output.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CharacterAttributesFlags.FOREGROUND_BLUE">
            <summary>
            Text color contains blue.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CharacterAttributesFlags.FOREGROUND_GREEN">
            <summary>
            Text color contains green.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CharacterAttributesFlags.FOREGROUND_RED">
            <summary>
            Text color contains red.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CharacterAttributesFlags.FOREGROUND_INTENSITY">
            <summary>
            Text color contains red.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CharacterAttributesFlags.BACKGROUND_BLUE">
            <summary>
            Background color contains blue.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CharacterAttributesFlags.BACKGROUND_GREEN">
            <summary>
            Background color contains green.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CharacterAttributesFlags.BACKGROUND_RED">
            <summary>
            Background color contains red.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CharacterAttributesFlags.BACKGROUND_INTENSITY">
            <summary>
            Background color is intensified.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CharacterAttributesFlags.COMMON_LVB_LEADING_BYTE">
            <summary>
            Leading byte.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CharacterAttributesFlags.COMMON_LVB_TRAILING_BYTE">
            <summary>
            Trailing byte.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CharacterAttributesFlags.COMMON_LVB_GRID_HORIZONTAL">
            <summary>
            Top horizontal.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CharacterAttributesFlags.COMMON_LVB_GRID_LVERTICAL">
            <summary>
            Left vertical.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CharacterAttributesFlags.COMMON_LVB_GRID_RVERTICAL">
            <summary>
            Right vertical.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CharacterAttributesFlags.COMMON_LVB_REVERSE_VIDEO">
            <summary>
            Reverse foreground and background attribute.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CharacterAttributesFlags.COMMON_LVB_UNDERSCORE">
            <summary>
            Underscore.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.CHAR_INFO">
            <summary>
            Specifies a Unicode or ANSI character and its attributes.
            This structure is used by console functions to read from and write to a console screen buffer.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CHAR_INFO.Char">
            <summary>
            A union of the Unicode and Ascii encodings.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CHAR_INFO.Attributes">
            <summary>
            The character attributes. This member can be zero or any combination of the <see cref="T:PInvoke.Kernel32.CharacterAttributesFlags"/> values
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.CHAR_INFO_ENCODING">
            <summary>
            A union of the Unicode and Ascii encodings.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CHAR_INFO_ENCODING.UnicodeChar">
            <summary>
            Unicode character of a screen buffer character cell.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CHAR_INFO_ENCODING.AsciiChar">
            <summary>
            ANSI character of a screen buffer character cell.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ConsoleBufferModes">
            <summary>
            Designates the console buffer mode on the <see cref="M:PInvoke.Kernel32.GetConsoleMode(System.IntPtr,PInvoke.Kernel32.ConsoleBufferModes@)"/> and <see cref="M:PInvoke.Kernel32.SetConsoleMode(System.IntPtr,PInvoke.Kernel32.ConsoleBufferModes)"/> functions
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ConsoleBufferModes.ENABLE_PROCESSED_INPUT">
            <summary>
            CTRL+C is processed by the system and is not placed in the input buffer.
            If the input buffer is being read by <see cref="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)"/> or <see cref="M:PInvoke.Kernel32.ReadConsole(System.IntPtr,System.Void*,System.Int32,System.Int32,System.IntPtr)"/>,
            other control keys are processed by the system and are not returned in the <see cref="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)"/> or <see cref="M:PInvoke.Kernel32.ReadConsole(System.IntPtr,System.Void*,System.Int32,System.Int32,System.IntPtr)"/> buffer.
            If the <see cref="F:PInvoke.Kernel32.ConsoleBufferModes.ENABLE_LINE_INPUT"/> mode is also enabled, backspace, carriage return, and line feed characters are handled by the system.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ConsoleBufferModes.ENABLE_PROCESSED_OUTPUT">
            <summary>
            Characters written by the <see cref="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)"/> or <see cref="M:PInvoke.Kernel32.WriteConsole(System.IntPtr,System.Void*,System.Int32,System.Int32*,System.IntPtr)"/> function
            or echoed by the <see cref="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)"/> or <see cref="M:PInvoke.Kernel32.ReadConsole(System.IntPtr,System.Void*,System.Int32,System.Int32,System.IntPtr)"/> function are parsed for ASCII control sequences, and the correct action is performed.
            Backspace, tab, bell, carriage return, and line feed characters are processed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ConsoleBufferModes.ENABLE_LINE_INPUT">
            <summary>
            The <see cref="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)"/> or <see cref="M:PInvoke.Kernel32.ReadConsole(System.IntPtr,System.Void*,System.Int32,System.Int32,System.IntPtr)"/> function returns only when a carriage return character is read.
            If this mode is disabled, the functions return when one or more characters are available.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ConsoleBufferModes.ENABLE_WRAP_AT_EOL_OUTPUT">
            <summary>
            When writing with <see cref="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)"/> or <see cref="M:PInvoke.Kernel32.WriteConsole(System.IntPtr,System.Void*,System.Int32,System.Int32*,System.IntPtr)"/> or echoing with <see cref="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)"/> or <see cref="M:PInvoke.Kernel32.ReadConsole(System.IntPtr,System.Void*,System.Int32,System.Int32,System.IntPtr)"/>,
            the cursor moves to the beginning of the next row when it reaches the end of the current row. This causes the rows displayed in the console window to scroll up automatically when the cursor advances beyond the last row in the window.
            It also causes the contents of the console screen buffer to scroll up (discarding the top row of the console screen buffer) when the cursor advances beyond the last row in the console screen buffer.
            If this mode is disabled, the last character in the row is overwritten with any subsequent characters.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ConsoleBufferModes.ENABLE_ECHO_INPUT">
            <summary>
            Characters read by the <see cref="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)"/> or <see cref="M:PInvoke.Kernel32.ReadConsole(System.IntPtr,System.Void*,System.Int32,System.Int32,System.IntPtr)"/> function are written to the active screen buffer as they are read.
            This mode can be used only if the <see cref="F:PInvoke.Kernel32.ConsoleBufferModes.ENABLE_LINE_INPUT"/> mode is also enabled.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ConsoleBufferModes.ENABLE_VIRTUAL_TERMINAL_PROCESSING">
            <summary>
            When writing with <see cref="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)"/> or <see cref="M:PInvoke.Kernel32.WriteConsole(System.IntPtr,System.Void*,System.Int32,System.Int32*,System.IntPtr)"/>, characters are parsed for VT100 and similar control character sequences that control cursor movement,
            color/font mode, and other operations that can also be performed via the existing Console APIs.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ConsoleBufferModes.ENABLE_WINDOW_INPUT">
            <summary>
            User interactions that change the size of the console screen buffer are reported in the console's input buffer.
            Information about these events can be read from the input buffer by applications using the <see cref="M:PInvoke.Kernel32.ReadConsoleInput(System.IntPtr,PInvoke.Kernel32.INPUT_RECORD@,System.Int32,System.Int32@)"/> function, but not by those using <see cref="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)"/> or <see cref="M:PInvoke.Kernel32.ReadConsole(System.IntPtr,System.Void*,System.Int32,System.Int32,System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ConsoleBufferModes.DISABLE_NEWLINE_AUTO_RETURN">
            <summary>
            When writing with <see cref="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)"/> or <see cref="M:PInvoke.Kernel32.WriteConsole(System.IntPtr,System.Void*,System.Int32,System.Int32*,System.IntPtr)"/>, this adds an additional state to end-of-line wrapping that can delay the cursor move and buffer scroll operations.
            Normally when <see cref="F:PInvoke.Kernel32.ConsoleBufferModes.ENABLE_WRAP_AT_EOL_OUTPUT"/> is set and text reaches the end of the line, the cursor will immediately move to the next line and the contents of the buffer will scroll up by one line. In contrast with this flag set,
            the scroll operation and cursor move is delayed until the next character arrives. The written character will be printed in the final position on the line and the cursor will remain above this character as if <see cref="F:PInvoke.Kernel32.ConsoleBufferModes.ENABLE_WRAP_AT_EOL_OUTPUT"/> was off,
            but the next printable character will be printed as if ENABLE_WRAP_AT_EOL_OUTPUT is on. No overwrite will occur. Specifically, the cursor quickly advances down to the following line, a scroll is performed if necessary, the character is printed, and the cursor advances one more position.
            The typical usage of this flag is intended in conjunction with setting ENABLE_VIRTUAL_TERMINAL_PROCESSING to better emulate a terminal emulator where writing the final character on the screen (in the bottom right corner) without triggering an immediate scroll is the desired behavior.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ConsoleBufferModes.ENABLE_MOUSE_INPUT">
            <summary>
            If the mouse pointer is within the borders of the console window and the window has the keyboard focus, mouse events generated by mouse movement and button presses are placed in the input buffer.
            These events are discarded by <see cref="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)"/> or <see cref="M:PInvoke.Kernel32.ReadConsole(System.IntPtr,System.Void*,System.Int32,System.Int32,System.IntPtr)"/>, even when this mode is enabled.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ConsoleBufferModes.ENABLE_LVB_GRID_WORLDWIDE">
            <summary>
            The APIs for writing character attributes including <see cref="M:PInvoke.Kernel32.WriteConsoleOutput(System.IntPtr,PInvoke.Kernel32.CHAR_INFO*,PInvoke.COORD,PInvoke.COORD,PInvoke.SMALL_RECT*)"/> and WriteConsoleOutputAttribute allow the usage of flags from character attributes to adjust the color of the foreground and background of text.
            Additionally, a range of DBCS flags was specified with the COMMON_LVB prefix. Historically, these flags only functioned in DBCS code pages for Chinese, Japanese, and Korean languages.
            With exception of the leading byte and trailing byte flags, the remaining flags describing line drawing and reverse video (swap foreground and background colors) can be useful for other languages to emphasize portions of output.
            Setting this console mode flag will allow these attributes to be used in every code page on every language.
            It is off by default to maintain compatibility with known applications that have historically taken advantage of the console ignoring these flags on non-CJK machines to store bits in these fields for their own purposes or by accident.
            Note that using the <see cref="F:PInvoke.Kernel32.ConsoleBufferModes.ENABLE_VIRTUAL_TERMINAL_PROCESSING"/> mode can result in LVB grid and reverse video flags being set while this flag is still off if the attached application requests underlining or inverse video via Console Virtual Terminal Sequences.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ConsoleBufferModes.ENABLE_INSERT_MODE">
            <summary>
            When enabled, text entered in a console window will be inserted at the current cursor location and all text following that location will not be overwritten.
            When disabled, all following text will be overwritten.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ConsoleBufferModes.ENABLE_QUICK_EDIT_MODE">
            <summary>
            This flag enables the user to use the mouse to select and edit text.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ConsoleDisplayMode">
            <summary>
            Designates the console display mode on the <see cref="M:PInvoke.Kernel32.GetConsoleDisplayMode(PInvoke.Kernel32.ConsoleDisplayMode@)"/> functions
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ConsoleDisplayMode.CONSOLE_FULLSCREEN_MODE">
            <summary>
            Text is displayed in full-screen mode.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ConsoleDisplayMode.CONSOLE_WINDOWED_MODE">
            <summary>
            Text is displayed in a console window.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ConsoleScreenBufferFlag">
            <summary>
            Designates how to create the screen buffer on the <see cref="M:PInvoke.Kernel32.CreateConsoleScreenBuffer(PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.ConsoleScreenBufferFlag,System.Void*)"/> function
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ConsoleScreenBufferFlag.None">
            <summary>
            Creates a default console
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ConsoleScreenBufferFlag.CONSOLE_TEXTMODE_BUFFER">
            <summary>
            Creates a console with a text mode buffer
            </summary>
            <remarks>Actual meaning not documented</remarks>
        </member>
        <member name="T:PInvoke.Kernel32.ConsoleSelectionFlags">
            <summary>
            The console selection indicator for <see cref="F:PInvoke.Kernel32.CONSOLE_SELECTION_INFO.dwFlags"/>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ConsoleSelectionFlags.CONSOLE_MOUSE_DOWN">
            <summary>
            Mouse is down.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ConsoleSelectionFlags.CONSOLE_MOUSE_SELECTION">
            <summary>
            Selecting with the mouse.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ConsoleSelectionFlags.CONSOLE_NO_SELECTION">
            <summary>
            No selection.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ConsoleSelectionFlags.CONSOLE_SELECTION_IN_PROGRESS">
            <summary>
            Selection has begun.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ConsoleSelectionFlags.CONSOLE_SELECTION_NOT_EMPTY">
            <summary>
            Selection rectangle is not empty.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.CONSOLE_SCREEN_BUFFER_INFO">
            <summary>
            Contains information about a console screen buffer.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CONSOLE_SCREEN_BUFFER_INFO.dwSize">
            <summary>
            A <see cref="T:PInvoke.COORD"/> structure that contains the size of the console screen buffer, in character columns and rows.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CONSOLE_SCREEN_BUFFER_INFO.dwCursorPosition">
            <summary>
            A <see cref="T:PInvoke.COORD"/> structure that contains the column and row coordinates of the cursor in the console screen buffer.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CONSOLE_SCREEN_BUFFER_INFO.wAttributes">
            <summary>
            The attributes of the characters written to a screen buffer by the WriteFile and WriteConsole functions,
            or echoed to a screen buffer by the ReadFile and ReadConsole functions.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CONSOLE_SCREEN_BUFFER_INFO.srWindow">
            <summary>
            A <see cref="T:PInvoke.SMALL_RECT"/> structure that contains the console screen buffer coordinates of the upper-left and lower-right corners of the display window.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CONSOLE_SCREEN_BUFFER_INFO.dwMaximumWindowSize">
            <summary>
            A <see cref="T:PInvoke.COORD"/> structure that contains the maximum size of the console window, in character columns and rows,
            given the current screen buffer size and font and the screen size.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.CONSOLE_SELECTION_INFO">
            <summary>
            Contains information for a console selection.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CONSOLE_SELECTION_INFO.dwFlags">
            <summary>
            The selection indicator.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CONSOLE_SELECTION_INFO.dwSelectionAnchor">
            <summary>
            A <see cref="T:PInvoke.COORD"/> structure that specifies the selection anchor, in characters.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CONSOLE_SELECTION_INFO.srSelection">
            <summary>
            A <see cref="T:PInvoke.SMALL_RECT"/> structure that specifies the selection rectangle.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ControlKeyStates">
            <summary>
            Describes the state of the control keys.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ControlKeyStates.CAPSLOCK_ON">
            <summary>
            The CAPS LOCK light is on.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ControlKeyStates.ENHANCED_KEY">
            <summary>
            The key is enhanced.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ControlKeyStates.LEFT_ALT_PRESSED">
            <summary>
            The left ALT key is pressed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ControlKeyStates.LEFT_CTRL_PRESSED">
            <summary>
            The left CTRL key is pressed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ControlKeyStates.NUMLOCK_ON">
            <summary>
            The NUM LOCK light is on.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ControlKeyStates.RIGHT_ALT_PRESSED">
            <summary>
            The right ALT key is pressed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ControlKeyStates.RIGHT_CTRL_PRESSED">
            <summary>
            The right CTRL key is pressed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ControlKeyStates.SCROLLLOCK_ON">
            <summary>
            The SCROLL LOCK light is on.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ControlKeyStates.SHIFT_PRESSED">
            <summary>
            The SHIFT key is pressed.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ControlType">
            <summary>
            Values that are passed to the <see cref="T:PInvoke.Kernel32.HandlerRoutine"/> callback.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ControlType.CTRL_C_EVENT">
            <summary>
            A CTRL+C signal was received, either from keyboard input or from a signal generated by the <see cref="M:PInvoke.Kernel32.GenerateConsoleCtrlEvent(PInvoke.Kernel32.ControlType,System.UInt32)"/> function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ControlType.CTRL_BREAK_EVENT">
            <summary>
            A CTRL+BREAK signal was received, either from keyboard input or from a signal generated by <see cref="M:PInvoke.Kernel32.GenerateConsoleCtrlEvent(PInvoke.Kernel32.ControlType,System.UInt32)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ControlType.CTRL_CLOSE_EVENT">
            <summary>
            A signal that the system sends to all processes attached to a console when the user closes the console
            (either by clicking Close on the console window's window menu, or by clicking the End Task button command from Task Manager).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ControlType.CTRL_LOGOFF_EVENT">
            <summary>
            A signal that the system sends to all console processes when a user is logging off. This signal does not indicate which user is logging off, so no assumptions can be made.
            </summary>
            <remarks>
            Note that this signal is received only by services. Interactive applications are terminated at logoff, so they are not present when the system sends this signal.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.ControlType.CTRL_SHUTDOWN_EVENT">
            <summary>
            A signal that the system sends when the system is shutting down.
            Interactive applications are not present by the time the system sends this signal, therefore it can be received only be services in this situation.
            Services also have their own notification mechanism for shutdown events. For more information, see <see cref="T:PInvoke.Kernel32.HandlerRoutine"/>.
            </summary>
            <remarks>
            This signal can also be generated by an application using GenerateConsoleCtrlEvent.
            </remarks>
        </member>
        <member name="T:PInvoke.Kernel32.CreateProcessFlags">
            <summary>
            Flags that may be passed to the <see cref="M:PInvoke.Kernel32.CreateProcess(System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)"/> function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.None">
            <summary>
            No flags.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_BREAKAWAY_FROM_JOB">
            <summary>
            The child processes of a process associated with a job are not associated with the job.
            If the calling process is not associated with a job, this constant has no effect. If the calling process is associated with a job, the job must set the JOB_OBJECT_LIMIT_BREAKAWAY_OK limit.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_DEFAULT_ERROR_MODE">
            <summary>
            The new process does not inherit the error mode of the calling process. Instead, the new process gets the default error mode.
            This feature is particularly useful for multithreaded shell applications that run with hard errors disabled.
            The default behavior is for the new process to inherit the error mode of the caller. Setting this flag changes that default behavior.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_NEW_CONSOLE">
            <summary>
            The new process has a new console, instead of inheriting its parent's console (the default). For more information, see Creation of a Console.
            This flag cannot be used with DETACHED_PROCESS.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_NEW_PROCESS_GROUP">
            <summary>
            The new process is the root process of a new process group. The process group includes all processes that are descendants of this root process. The process identifier of the new process group is the same as the process identifier, which is returned in the lpProcessInformation parameter. Process groups are used by the GenerateConsoleCtrlEvent function to enable sending a CTRL+BREAK signal to a group of console processes.
            If this flag is specified, CTRL+C signals will be disabled for all processes within the new process group.
            This flag is ignored if specified with <see cref="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_NEW_CONSOLE"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_NO_WINDOW">
            <summary>
            The process is a console application that is being run without a console window. Therefore, the console handle for the application is not set.
            This flag is ignored if the application is not a console application, or if it is used with either <see cref="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_NEW_CONSOLE"/> or <see cref="F:PInvoke.Kernel32.CreateProcessFlags.DETACHED_PROCESS"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_PROTECTED_PROCESS">
            <summary>
            The process is to be run as a protected process. The system restricts access to protected processes and the threads of protected processes. For more information on how processes can interact with protected processes, see Process Security and Access Rights.
            To activate a protected process, the binary must have a special signature. This signature is provided by Microsoft but not currently available for non-Microsoft binaries. There are currently four protected processes: media foundation, audio engine, Windows error reporting, and system. Components that load into these binaries must also be signed. Multimedia companies can leverage the first two protected processes. For more information, see Overview of the Protected Media Path.
            Windows Server 2003 and Windows XP:  This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_PRESERVE_CODE_AUTHZ_LEVEL">
            <summary>
            Allows the caller to execute a child process that bypasses the process restrictions that would normally be applied automatically to the process.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_SEPARATE_WOW_VDM">
            <summary>
            This flag is valid only when starting a 16-bit Windows-based application. If set, the new process runs in a private Virtual DOS Machine (VDM). By default, all 16-bit Windows-based applications run as threads in a single, shared VDM. The advantage of running separately is that a crash only terminates the single VDM; any other programs running in distinct VDMs continue to function normally. Also, 16-bit Windows-based applications that are run in separate VDMs have separate input queues. That means that if one application stops responding momentarily, applications in separate VDMs continue to receive input. The disadvantage of running separately is that it takes significantly more memory to do so. You should use this flag only if the user requests that 16-bit applications should run in their own VDM.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_SHARED_WOW_VDM">
            <summary>
            The flag is valid only when starting a 16-bit Windows-based application. If the DefaultSeparateVDM switch in the Windows section of WIN.INI is TRUE, this flag overrides the switch. The new process is run in the shared Virtual DOS Machine.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_SUSPENDED">
            <summary>
            The primary thread of the new process is created in a suspended state, and does not run until the <see cref="M:PInvoke.Kernel32.ResumeThread(PInvoke.Kernel32.SafeObjectHandle)"/> function is called.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_UNICODE_ENVIRONMENT">
            <summary>
            If this flag is set, the environment block pointed to by lpEnvironment uses Unicode characters. Otherwise, the environment block uses ANSI characters.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.DEBUG_ONLY_THIS_PROCESS">
            <summary>
            The calling thread starts and debugs the new process. It can receive all related debug events using the WaitForDebugEvent function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.DEBUG_PROCESS">
            <summary>
            The calling thread starts and debugs the new process and all child processes created by the new process. It can receive all related debug events using the WaitForDebugEvent function.
            A process that uses <see cref="F:PInvoke.Kernel32.CreateProcessFlags.DEBUG_PROCESS"/> becomes the root of a debugging chain. This continues until another process in the chain is created with <see cref="F:PInvoke.Kernel32.CreateProcessFlags.DEBUG_PROCESS"/>.
            If this flag is combined with <see cref="F:PInvoke.Kernel32.CreateProcessFlags.DEBUG_ONLY_THIS_PROCESS"/>, the caller debugs only the new process, not any child processes.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.DETACHED_PROCESS">
            <summary>
            For console processes, the new process does not inherit its parent's console (the default). The new process can call the <see cref="M:PInvoke.Kernel32.AllocConsole"/> function at a later time to create a console. For more information, see Creation of a Console.
            This value cannot be used with <see cref="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_NEW_CONSOLE"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT">
            <summary>
            The process is created with extended startup information; the lpStartupInfo parameter specifies a <see cref="T:PInvoke.Kernel32.STARTUPINFOEX"/> structure.
            Windows Server 2003 and Windows XP:  This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.INHERIT_PARENT_AFFINITY">
            <summary>
            The process inherits its parent's affinity. If the parent process has threads in more than one processor group, the new process inherits the group-relative affinity of an arbitrary group in use by the parent.
            Windows Server 2008, Windows Vista, Windows Server 2003, and Windows XP:  This value is not supported.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags">
            <summary>
            The portions of the system to be included in the snapshot for <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_INHERIT">
            <summary>
            Indicates that the snapshot handle is to be inheritable.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPHEAPLIST">
            <summary>
            Includes all heaps of the process specified in th32ProcessID in the snapshot.
            To enumerate the heaps, see Heap32ListFirst.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE">
            <summary>
            Includes all modules of the process specified in th32ProcessID in the snapshot.
            To enumerate the modules, see <see cref="M:PInvoke.Kernel32.Module32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.MODULEENTRY32*)"/>.
            If the function fails with <see cref="F:PInvoke.Win32ErrorCode.ERROR_BAD_LENGTH"/>, retry the function until
            it succeeds.
            <para>
            64-bit Windows:  Using this flag in a 32-bit process includes the 32-bit modules of the process
            specified in th32ProcessID, while using it in a 64-bit process includes the 64-bit modules.
            To include the 32-bit modules of the process specified in th32ProcessID from a 64-bit process, use
            the <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE32"/> flag.
            </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE32">
            <summary>
            Includes all 32-bit modules of the process specified in th32ProcessID in the snapshot when called from
            a 64-bit process.
            This flag can be combined with <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE"/> or <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPALL"/>.
            If the function fails with <see cref="F:PInvoke.Win32ErrorCode.ERROR_BAD_LENGTH"/>, retry the function until it
            succeeds.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPPROCESS">
            <summary>
            Includes all processes in the system in the snapshot. To enumerate the processes, see
            <see cref="M:PInvoke.Kernel32.Process32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESSENTRY32*)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPTHREAD">
            <summary>
            Includes all threads in the system in the snapshot. To enumerate the threads, see
            Thread32First.
            <para>
            To identify the threads that belong to a specific process, compare its process identifier to the
            th32OwnerProcessID member of the THREADENTRY32 structure when
            enumerating the threads.
            </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPALL">
            <summary>
            Includes all processes and threads in the system, plus the heaps and modules of the process specified in
            th32ProcessID.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.EXECUTION_STATE">
            <summary>
            The thread's execution requirements.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.EXECUTION_STATE.None">
            <summary>
            No flags.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.EXECUTION_STATE.ES_AWAYMODE_REQUIRED">
            <summary>
            Enables away mode. This value must be specified with <see cref="F:PInvoke.Kernel32.EXECUTION_STATE.ES_CONTINUOUS"/>.
            Away mode should be used only by media-recording and media-distribution applications that must perform critical background processing on desktop computers while the computer appears to be sleeping. See Remarks.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.EXECUTION_STATE.ES_CONTINUOUS">
            <summary>
            Informs the system that the state being set should remain in effect until the next call that uses <see cref="F:PInvoke.Kernel32.EXECUTION_STATE.ES_CONTINUOUS"/> and one of the other state flags is cleared.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.EXECUTION_STATE.ES_DISPLAY_REQUIRED">
            <summary>
            Forces the display to be on by resetting the display idle timer.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.EXECUTION_STATE.ES_SYSTEM_REQUIRED">
            <summary>
            Forces the system to be in the working state by resetting the system idle timer.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.EXECUTION_STATE.ES_USER_PRESENT">
            <summary>
            This value is not supported. If <see cref="F:PInvoke.Kernel32.EXECUTION_STATE.ES_USER_PRESENT"/> is combined with other esFlags values, the call will fail and none of the specified states will be set.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.FOCUS_EVENT_RECORD">
            <summary>
            Describes a focus event in a console <see cref="T:PInvoke.Kernel32.INPUT_RECORD"/> structure.
            </summary>
            <remarks>
            These events are used internally and should be ignored.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.FOCUS_EVENT_RECORD.bSetFocus">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.GetModuleHandleExFlags">
            <summary>
            Flags that may be passed to the <see cref="M:PInvoke.Kernel32.GetModuleHandleEx(PInvoke.Kernel32.GetModuleHandleExFlags,System.String,PInvoke.Kernel32.SafeLibraryHandle@)"/> function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GetModuleHandleExFlags.None">
            <summary>
            Define no flags.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GetModuleHandleExFlags.GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS">
            <summary>
            The lpModuleName parameter is an address in the module.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GetModuleHandleExFlags.GET_MODULE_HANDLE_EX_FLAG_PIN">
            <summary>
            The module stays loaded until the process is terminated, no matter how many times <see cref="M:PInvoke.Kernel32.FreeLibrary(System.IntPtr)"/> is called.
            </summary>
            <remarks>This option cannot be used with <see cref="F:PInvoke.Kernel32.GetModuleHandleExFlags.GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT"/>.</remarks>
        </member>
        <member name="F:PInvoke.Kernel32.GetModuleHandleExFlags.GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT">
            <summary>
            The reference count for the module is not incremented. This option is equivalent to the behavior of <see cref="M:PInvoke.Kernel32.GetModuleHandle(System.String)"/>.
            Do not pass the retrieved module handle to the <see cref="M:PInvoke.Kernel32.FreeLibrary(System.IntPtr)"/> function; doing so can cause the DLL to be unmapped prematurely.
            </summary>
            <remarks>
            This option cannot be used with <see cref="F:PInvoke.Kernel32.GetModuleHandleExFlags.GET_MODULE_HANDLE_EX_FLAG_PIN" />.
            </remarks>
        </member>
        <member name="T:PInvoke.Kernel32.GlobalAllocFlags">
            <summary>
            Flags for the <see cref="M:PInvoke.Kernel32.GlobalAlloc(PInvoke.Kernel32.GlobalAllocFlags,System.IntPtr)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_FIXED">
            <summary>
            Allocates fixed memory. The return value is a pointer.
            </summary>
            <remarks>Cannot be combined with the <see cref="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_MOVEABLE"/> flags.</remarks>
        </member>
        <member name="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_MOVEABLE">
            <summary>
            Allocates movable memory. Memory blocks are never moved in physical memory, but they can
            be moved within the default heap. The return value is a handle to the memory object. To
            translate the handle into a pointer, use the <see cref="M:PInvoke.Kernel32.GlobalLock(System.Void*)"/> function.
            </summary>
            <remarks>This value cannot be combined with <see cref="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_FIXED"/>.</remarks>
        </member>
        <member name="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_NOCOMPACT">
            <summary>
            Does not compact or discard memory to satisfy the allocation request.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_NODISCARD">
            <summary>
            Does not discard memory to satisfy the allocation request.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_ZEROINIT">
            <summary>
            Initializes memory contents to zero
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GlobalAllocFlags.GPTR">
            <summary>
            Combines <see cref="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_FIXED"/> and <see cref="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_ZEROINIT"/>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GlobalAllocFlags.GHND">
            <summary>
            Combines <see cref="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_MOVEABLE"/> and <see cref="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_ZEROINIT"/>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_DISCARDABLE">
            <summary>
            Allocates discardable memory.
            </summary>
            <remarks>This flag can only be used with the GMEM_MOVEABLE flag.</remarks>
        </member>
        <member name="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_NOT_BANKED">
            <summary>
            Allocates non-banked memory (memory is not within the <see cref="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_NOTIFY"/> flag).
            Same as <see cref="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_LOWER"/>.
            </summary>
            <remarks>This flag is ignored in Windows 3.1.</remarks>
        </member>
        <member name="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_LOWER">
            <summary>
            Allocates non-banked memory (memory is not within the <see cref="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_NOTIFY"/> flag).
            Same as <see cref="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_NOT_BANKED"/>.
            </summary>
            <remarks>This flag is ignored in Windows 3.1.</remarks>
        </member>
        <member name="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_DDESHARE">
            <summary>
            Allocates memory that can be shared with other applications. This flag is used for
            dynamic data exchange (DDE) only.
            </summary>
            <remarks>This flag is equivalent to <see cref="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_SHARE"/>.</remarks>
        </member>
        <member name="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_SHARE">
            <summary>
            Allocates memory that can be shared with other applications. This flag is used for
            dynamic data exchange (DDE) only.
            </summary>
            <remarks>This flag is equivalent to <see cref="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_DDESHARE"/>.</remarks>
        </member>
        <member name="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_NOTIFY">
            <summary>
            Calls the notification routine if the memory object is discarded.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.GlobalReAllocFlags">
            <summary>
            Flags for the <see cref="M:PInvoke.Kernel32.GlobalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.GlobalReAllocFlags)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GlobalReAllocFlags.GMEM_MODIFY">
            <summary>
            Modifies the attributes of the memory object only (the uBytes parameter is ignored.) Otherwise, the function reallocates the memory object.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GlobalReAllocFlags.GMEM_MOVEABLE">
            <summary>
            Allocates fixed or movable memory.
            If the memory is a locked <see cref="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_MOVEABLE"/> memory block or a
            <see cref="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_FIXED"/> memory block and this flag is not specified, the memory can only be reallocated in place.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GlobalReAllocFlags.GMEM_ZEROINIT">
            <summary>
            Causes the additional memory contents to be initialized to zero if the memory object is growing in size.
            </summary>
            <remarks>If the parameter does not specify <see cref="F:PInvoke.Kernel32.GlobalReAllocFlags.GMEM_MODIFY"/>, you can use this value.</remarks>
        </member>
        <member name="T:PInvoke.Kernel32.GRPICONDIR">
            <summary>
            Represents a group of icons as stored in a resource
            </summary>
            <remarks>
            The structure is followed by <see cref="F:PInvoke.Kernel32.GRPICONDIR.idCount"/> <see cref="T:PInvoke.Kernel32.GRPICONDIRENTRY"/> entries.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIR.idReserved">
            <summary>
            Reserved (must be 0)
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIR.idType">
            <summary>
            Resource type (1 for icons)
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIR.idCount">
            <summary>
            How many images?
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.GRPICONDIRENTRY">
            <summary>
            Represents an icon as stored in a resource
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIRENTRY.bWidth">
            <summary>
            Width, in pixels, of the image
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIRENTRY.bHeight">
            <summary>
            Height, in pixels, of the image
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIRENTRY.bColorCount">
            <summary>
            Number of colors in image (0 if >= 8bpp)
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIRENTRY.bReserved">
            <summary>
            Reserved
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIRENTRY.wPlanes">
            <summary>
            Color Planes
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIRENTRY.wBitCount">
            <summary>
            Bits per pixel
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIRENTRY.dwBytesInRes">
            <summary>
            How many bytes in this resource?
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.GRPICONDIRENTRY.nId">
            <summary>
            The ID
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.HeapAllocFlags">
            <summary>
            Flags for the <see cref="M:PInvoke.Kernel32.HeapAlloc(System.IntPtr,PInvoke.Kernel32.HeapAllocFlags,System.IntPtr)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.HeapAllocFlags.HEAP_GENERATE_EXCEPTIONS">
            <summary>
            The system will raise an exception to indicate a function failure, such as an out-of-memory condition, instead of returning NULL.
            </summary>
            <remarks>
            To ensure that exceptions are generated for all calls to this function, specify HEAP_GENERATE_EXCEPTIONS in the call to HeapCreate.
            In this case, it is not necessary to additionally specify HEAP_GENERATE_EXCEPTIONS in this function call.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.HeapAllocFlags.HEAP_NO_SERIALIZE">
            <summary>
            Serialized access will not be used for this allocation.
            </summary>
            <remarks>
            <para>
            To ensure that serialized access is disabled for all calls to this function, specify HEAP_NO_SERIALIZE in the call to HeapCreate.
            In this case, it is not necessary to additionally specify HEAP_NO_SERIALIZE in this function call.
            </para>
            <para>
            This value should not be specified when accessing the process's default heap.
            The system may create additional threads within the application's process, such as a CTRL+C handler, that simultaneously access the process's default heap.
            </para>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.HeapAllocFlags.HEAP_ZERO_MEMORY">
            <summary>
            The allocated memory will be initialized to zero. Otherwise, the memory is not initialized to zero.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.HeapFreeFlags">
            <summary>
            Flags for the <see cref="M:PInvoke.Kernel32.HeapFree(System.IntPtr,PInvoke.Kernel32.HeapFreeFlags,System.Void*)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.HeapFreeFlags.HEAP_NO_SERIALIZE">
            <summary>
            Serialized access will not be used.
            </summary>
            <remarks>
            <para>
            To ensure that serialized access is disabled for all calls to this function, specify HEAP_NO_SERIALIZE in the call to HeapCreate.
            In this case, it is not necessary to additionally specify HEAP_NO_SERIALIZE in this function call.
            </para>
            <para>
            Do not specify this value when accessing the process heap. The system may create additional threads within the application's process,
            such as a CTRL+C handler, that simultaneously access the process heap.
            </para>
            </remarks>
        </member>
        <member name="T:PInvoke.Kernel32.HeapReAllocFlags">
            <summary>
            Flags for the <see cref="M:PInvoke.Kernel32.HeapReAlloc(System.IntPtr,PInvoke.Kernel32.HeapReAllocFlags,System.Void*,System.IntPtr)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.HeapReAllocFlags.HEAP_GENERATE_EXCEPTIONS">
            <summary>
            The operating-system raises an exception to indicate a function failure, such as an out-of-memory condition, instead of returning NULL.
            </summary>
            <remarks>
            To ensure that exceptions are generated for all calls to this function, specify HEAP_GENERATE_EXCEPTIONS in the call to HeapCreate.
            In this case, it is not necessary to additionally specify HEAP_GENERATE_EXCEPTIONS in this function call.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.HeapReAllocFlags.HEAP_NO_SERIALIZE">
            <summary>
            Serialized access will not be used.
            </summary>
            <remarks>
            <para>
            To ensure that serialized access is disabled for all calls to this function, specify HEAP_NO_SERIALIZE in the call to HeapCreate.
            In this case, it is not necessary to additionally specify HEAP_NO_SERIALIZE in this function call.
            </para>
            <para>
            This value should not be specified when accessing the process's default heap.
            The system may create additional threads within the application's process, such as a CTRL+C handler, that simultaneously access the process's default heap.
            </para>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.HeapReAllocFlags.HEAP_REALLOC_IN_PLACE_ONLY">
            <summary>
            There can be no movement when reallocating a memory block.
            If this value is not specified, the function may move the block to a new location.
            If this value is specified and the block cannot be resized without moving, the function fails, leaving the original memory block unchanged.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.HeapReAllocFlags.HEAP_ZERO_MEMORY">
            <summary>
            If the reallocation request is for a larger size, the additional region of memory beyond the original size be initialized to zero.
            The contents of the memory block up to its original size are unaffected.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ICONDIR">
            <summary>
            Represents a group of icons as stored in a '.ico' file
            </summary>
            <remarks>
            The structure is followed by <see cref="F:PInvoke.Kernel32.ICONDIR.idCount"/> <see cref="T:PInvoke.Kernel32.ICONDIRENTRY"/> entries.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIR.idReserved">
            <summary>
            Reserved (must be 0)
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIR.idType">
            <summary>
            Resource type (1 for icons)
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIR.idCount">
            <summary>
            How many images?
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ICONDIRENTRY">
            <summary>
            Represents an icon as stored in a '.ico' file
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIRENTRY.bWidth">
            <summary>
            Width, in pixels, of the image
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIRENTRY.bHeight">
            <summary>
            Height, in pixels, of the image
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIRENTRY.bColorCount">
            <summary>
            Number of colors in image (0 if >= 8bpp)
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIRENTRY.bReserved">
            <summary>
            Reserved
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIRENTRY.wPlanes">
            <summary>
            Color Planes
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIRENTRY.wBitCount">
            <summary>
            Bits per pixel
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIRENTRY.dwBytesInRes">
            <summary>
            How many bytes in this resource
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ICONDIRENTRY.dwImageOffset">
            <summary>
            Location (relative to the start of the ICO file) of the actual image data.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.InputEventTypeFlag">
            <summary>
            A handle to the type of input event and the event record stored in the <see cref="F:PInvoke.Kernel32.INPUT_RECORD.Event"/> member.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.InputEventTypeFlag.FOCUS_EVENT">
            <summary>
            The Event member contains a <see cref="T:PInvoke.Kernel32.FOCUS_EVENT_RECORD"/> structure. These events are used internally and should be ignored
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.InputEventTypeFlag.KEY_EVENT">
            <summary>
            The Event member contains a <see cref="T:PInvoke.Kernel32.KEY_EVENT_RECORD"/> structure with information about a keyboard event.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.InputEventTypeFlag.MENU_EVENT">
            <summary>
            The Event member contains a <see cref="T:PInvoke.Kernel32.MENU_EVENT_RECORD"/> structure. These events are used internally and should be ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.InputEventTypeFlag.MOUSE_EVENT">
            <summary>
            The Event member contains a <see cref="T:PInvoke.Kernel32.MOUSE_EVENT_RECORD"/> structure with information about a mouse movement or button press event.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.InputEventTypeFlag.WINDOW_BUFFER_SIZE_EVENT">
            <summary>
            The Event member contains a <see cref="T:PInvoke.Kernel32.WINDOW_BUFFER_SIZE_RECORD"/> structure with information about the new size of the console screen buffer.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.INPUT_EVENT_RECORD">
            <summary>
            The input event information. The format of this member depends on the event type specified by the <see cref="F:PInvoke.Kernel32.INPUT_RECORD.EventType"/> member.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.INPUT_EVENT_RECORD.KeyEvent">
            <summary>
            Structure with information about a keyboard event.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.INPUT_EVENT_RECORD.MouseEvent">
            <summary>
            Structure with information about a mouse movement or button press event.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.INPUT_EVENT_RECORD.WindowBufferSizeEvent">
            <summary>
            Structure with information about the new size of the console screen buffer.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.INPUT_EVENT_RECORD.MenuEvent">
            <summary>
            These events are used internally and should be ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.INPUT_EVENT_RECORD.FocusEvent">
            <summary>
            These events are used internally and should be ignored.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.INPUT_RECORD">
            <summary>
            Describes an input event in the console input buffer.
            These records can be read from the input buffer by using the <see cref="M:PInvoke.Kernel32.ReadConsoleInput(System.IntPtr,PInvoke.Kernel32.INPUT_RECORD@,System.Int32,System.Int32@)"/> or <see cref="M:PInvoke.Kernel32.PeekConsoleInput(System.IntPtr,PInvoke.Kernel32.INPUT_RECORD@,System.Int32,System.Int32@)"/> function,
            or written to the input buffer by using the <see cref="M:PInvoke.Kernel32.WriteConsoleInput(System.IntPtr,PInvoke.Kernel32.INPUT_RECORD*,System.Int32,System.Int32*)"/> function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.INPUT_RECORD.EventType">
            <summary>
            A handle to the type of input event and the event record stored in the <see cref="F:PInvoke.Kernel32.INPUT_RECORD.Event"/> member.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.INPUT_RECORD.Event">
            <summary>
            The event information. The format of this member depends on the event type specified by the <see cref="F:PInvoke.Kernel32.INPUT_RECORD.EventType"/> member.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.IO_COUNTERS">
            <summary>
            Contains I/O accounting information for a process or a job object.
            For a job object, the counters include all operations performed by all processes that have ever been associated with the job,
            in addition to all processes currently associated with the job.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.IO_COUNTERS.ReadOperationCount">
            <summary>
            The number of read operations performed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.IO_COUNTERS.WriteOperationCount">
            <summary>
            The number of write operations performed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.IO_COUNTERS.OtherOperationCount">
            <summary>
            The number of I/O operations performed, other than read and write operations.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.IO_COUNTERS.ReadTransferCount">
            <summary>
            The number of bytes read.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.IO_COUNTERS.WriteTransferCount">
            <summary>
            The number of bytes written.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.IO_COUNTERS.OtherTransferCount">
            <summary>
            The number of bytes transferred during operations other than read and write operations.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.JOBOBJECTINFOCLASS">
            <summary>
            The information class for the limits to be set.
            </summary>
            <remarks>
            Taken from https://msdn.microsoft.com/en-us/library/windows/desktop/ms686216(v=vs.85).aspx
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECTINFOCLASS.JobObjectBasicLimitInformation">
            <summary>
            The lpJobObjectInfo parameter is a pointer to a <see cref="T:PInvoke.Kernel32.JOBOBJECT_BASIC_LIMIT_INFORMATION" /> structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECTINFOCLASS.JobObjectBasicUIRestrictions">
            <summary>
            The lpJobObjectInfo parameter is a pointer to a JOBOBJECT_BASIC_UI_RESTRICTIONS structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECTINFOCLASS.JobObjectSecurityLimitInformation">
            <summary>
            This flag is not supported. Applications must set security limitations individually for each process.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECTINFOCLASS.JobObjectEndOfJobTimeInformation">
            <summary>
            The lpJobObjectInfo parameter is a pointer to a JOBOBJECT_END_OF_JOB_TIME_INFORMATION structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECTINFOCLASS.JobObjectAssociateCompletionPortInformation">
            <summary>
            The lpJobObjectInfo parameter is a pointer to a JOBOBJECT_ASSOCIATE_COMPLETION_PORT structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECTINFOCLASS.JobObjectExtendedLimitInformation">
            <summary>
            The lpJobObjectInfo parameter is a pointer to a <see cref="T:PInvoke.Kernel32.JOBOBJECT_EXTENDED_LIMIT_INFORMATION" /> structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECTINFOCLASS.JobObjectGroupInformation">
            <summary>
            The lpJobObjectInfo parameter is a pointer to a USHORT value that specifies the list of processor groups to assign the job to.
            The cbJobObjectInfoLength parameter is set to the size of the group data. Divide this value by sizeof(USHORT) to determine the number of groups.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECTINFOCLASS.JobObjectNotificationLimitInformation">
            <summary>
            The lpJobObjectInfo parameter is a pointer to a JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECTINFOCLASS.JobObjectGroupInformationEx">
            <summary>
            The lpJobObjectInfo parameter is a pointer to a buffer that contains an array of GROUP_AFFINITY structures that specify the affinity of the job for the processor groups to which the job is currently assigned.
            The cbJobObjectInfoLength parameter is set to the size of the group affinity data. Divide this value by sizeof(GROUP_AFFINITY) to determine the number of groups.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECTINFOCLASS.JobObjectCpuRateControlInformation">
            <summary>
            The lpJobObjectInfo parameter is a pointer to a JOBOBJECT_CPU_RATE_CONTROL_INFORMATION structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECTINFOCLASS.JobObjectNetRateControlInformation">
            <summary>
            The lpJobObjectInfo parameter is a pointer to a JOBOBJECT_NET_RATE_CONTROL_INFORMATION structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECTINFOCLASS.JobObjectNotificationLimitInformation2">
            <summary>
            The lpJobObjectInfo parameter is a pointer to a JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECTINFOCLASS.JobObjectLimitViolationInformation2">
            <summary>
            The lpJobObjectInfo parameter is a pointer to a JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 structure.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.JOBOBJECT_BASIC_LIMIT_INFORMATION">
            <summary>
            Contains basic limit information for a job object.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_BASIC_LIMIT_INFORMATION.PerProcessUserTimeLimit">
            <summary>
            If LimitFlags specifies JOB_OBJECT_LIMIT_PROCESS_TIME, this member is the per-process user-mode execution time limit, in 100-nanosecond ticks. Otherwise, this member is ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_BASIC_LIMIT_INFORMATION.PerJobUserTimeLimit">
            <summary>
            If LimitFlags specifies JOB_OBJECT_LIMIT_JOB_TIME, this member is the per-job user-mode execution time limit, in 100-nanosecond ticks. Otherwise, this member is ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_BASIC_LIMIT_INFORMATION.LimitFlags">
            <summary>
            The limit flags that are in effect. This member is a bitfield that determines whether other structure members are used.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_BASIC_LIMIT_INFORMATION.MinWorkingSetSize">
            <summary>
            If LimitFlags specifies JOB_OBJECT_LIMIT_WORKINGSET, this member is the minimum working set size in bytes for each process associated with the job. Otherwise, this member is ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_BASIC_LIMIT_INFORMATION.MaxWorkingSetSize">
            <summary>
            If LimitFlags specifies JOB_OBJECT_LIMIT_WORKINGSET, this member is the maximum working set size in bytes for each process associated with the job. Otherwise, this member is ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_BASIC_LIMIT_INFORMATION.ActiveProcessLimit">
            <summary>
            If LimitFlags specifies JOB_OBJECT_LIMIT_ACTIVE_PROCESS, this member is the active process limit for the job. Otherwise, this member is ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_BASIC_LIMIT_INFORMATION.Affinity">
            <summary>
            If LimitFlags specifies JOB_OBJECT_LIMIT_AFFINITY, this member is the processor affinity for all processes associated with the job. Otherwise, this member is ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_BASIC_LIMIT_INFORMATION.PriorityClass">
            <summary>
            If LimitFlags specifies JOB_OBJECT_LIMIT_PRIORITY_CLASS, this member is the priority class for all processes associated with the job. Otherwise, this member is ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_BASIC_LIMIT_INFORMATION.SchedulingClass">
            <summary>
            If LimitFlags specifies JOB_OBJECT_LIMIT_SCHEDULING_CLASS, this member is the scheduling class for all processes associated with the job. Otherwise, this member is ignored.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.JOBOBJECT_CPU_RATE_CONTROL_FLAGS">
            <summary>
            The scheduling policy for CPU rate control.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_CPU_RATE_CONTROL_FLAGS.JOB_OBJECT_CPU_RATE_CONTROL_ENABLE">
            <summary>
            This flag enables the job's CPU rate to be controlled based on weight or hard cap. You must set this value if you also set JOB_OBJECT_CPU_RATE_CONTROL_WEIGHT_BASED, JOB_OBJECT_CPU_RATE_CONTROL_HARD_CAP, or JOB_OBJECT_CPU_RATE_CONTROL_MIN_MAX_RATE.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_CPU_RATE_CONTROL_FLAGS.JOB_OBJECT_CPU_RATE_CONTROL_WEIGHT_BASED">
            <summary>
            The job's CPU rate is calculated based on its relative weight to the weight of other jobs. If this flag is set, the Weight member contains more information. If this flag is clear, the CpuRate member contains more information.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_CPU_RATE_CONTROL_FLAGS.JOB_OBJECT_CPU_RATE_CONTROL_HARD_CAP">
            <summary>
            The job's CPU rate is a hard limit. After the job reaches its CPU cycle limit for the current scheduling interval, no threads associated with the job will run until the next interval.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_CPU_RATE_CONTROL_FLAGS.JOB_OBJECT_CPU_RATE_CONTROL_NOTIFY">
            <summary>
            Sends messages when the CPU rate for the job exceeds the rate limits for the job during the tolerance interval.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_CPU_RATE_CONTROL_FLAGS.JOB_OBJECT_CPU_RATE_CONTROL_MIN_MAX_RATE">
            <summary>
            The CPU rate for the job is limited by minimum and maximum rates that you specify in the MinRate and MaxRate members.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.JOBOBJECT_CPU_RATE_CONTROL_INFORMATION">
            <summary>
            Contains CPU rate control information for a job object. This structure is used by the SetInformationJobObject and QueryInformationJobObject functions with the JobObjectCpuRateControlInformation information class.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_CPU_RATE_CONTROL_INFORMATION.ControlFlags">
            <summary>
            The scheduling policy for CPU rate control.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_CPU_RATE_CONTROL_INFORMATION.CpuRate">
            <summary>
            Specifies the portion of processor cycles that the threads in a job object can use during each scheduling interval, as the number of cycles per 10,000 cycles. If the ControlFlags member specifies JOB_OBJECT_CPU_RATE_WEIGHT_BASED or JOB_OBJECT_CPU_RATE_CONTROL_MIN_MAX_RATE, this member is not used.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_CPU_RATE_CONTROL_INFORMATION.Weight">
            <summary>
            If the ControlFlags member specifies JOB_OBJECT_CPU_RATE_WEIGHT_BASED, this member specifies the scheduling weight of the job object, which determines the share of processor time given to the job relative to other workloads on the processor.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_CPU_RATE_CONTROL_INFORMATION.MinRate">
            <summary>
            Specifies the minimum portion of the processor cycles that the threads in a job object can reserve during each scheduling interval. Specify this rate as a percentage times 100. For example, to set a minimum rate of 50%, specify 50 times 100, or 5,000.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_CPU_RATE_CONTROL_INFORMATION.MaxRate">
            <summary>
            Specifies the maximum portion of processor cycles that the threads in a job object can use during each scheduling interval. Specify this rate as a percentage times 100. For example, to set a maximum rate of 50%, specify 50 times 100, or 5,000.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.JOBOBJECT_EXTENDED_LIMIT_INFORMATION">
            <summary>
            Contains basic and extended limit information for a job object.
            </summary>
            <remarks>
            <para>The system tracks the value of PeakProcessMemoryUsed and PeakJobMemoryUsed constantly. This allows you know the peak memory usage of each job. You can use this information to establish a memory limit using the JOB_OBJECT_LIMIT_PROCESS_MEMORY or JOB_OBJECT_LIMIT_JOB_MEMORY value.</para>
            <para>Note that the job memory and process memory limits are very similar in operation, but they are independent. You could set a job-wide limit of 100 MB with a per-process limit of 10 MB. In this scenario, no single process could commit more than 10 MB, and the set of processes associated with a job could never exceed 100 MB.</para>
            <para>To register for notifications that a job has exceeded its peak memory limit while allowing processes to continue to commit memory, use the SetInformationJobObject function with the JobObjectNotificationLimitInformation information class.</para>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_EXTENDED_LIMIT_INFORMATION.BasicLimitInformation">
            <summary>
            A <see cref="T:PInvoke.Kernel32.JOBOBJECT_BASIC_LIMIT_INFORMATION"/> structure that contains basic limit information.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_EXTENDED_LIMIT_INFORMATION.IoInfo">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_EXTENDED_LIMIT_INFORMATION.ProcessMemoryLimit">
            <summary>
            If the <see cref="F:PInvoke.Kernel32.JOBOBJECT_BASIC_LIMIT_INFORMATION.LimitFlags"/> member of the <see cref="T:PInvoke.Kernel32.JOBOBJECT_BASIC_LIMIT_INFORMATION"/> structure specifies the
            <see cref="F:PInvoke.Kernel32.JOB_OBJECT_LIMIT_FLAGS.JOB_OBJECT_LIMIT_PROCESS_MEMORY"/> value, this member specifies the limit for the virtual memory that can be committed by a process.
            Otherwise, this member is ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_EXTENDED_LIMIT_INFORMATION.JobMemoryLimit">
            <summary>
            If the <see cref="F:PInvoke.Kernel32.JOBOBJECT_BASIC_LIMIT_INFORMATION.LimitFlags"/> member of the <see cref="T:PInvoke.Kernel32.JOBOBJECT_BASIC_LIMIT_INFORMATION"/> structure specifies the
            <see cref="F:PInvoke.Kernel32.JOB_OBJECT_LIMIT_FLAGS.JOB_OBJECT_LIMIT_JOB_MEMORY"/> value,
            this member specifies the limit for the virtual memory that can be committed for the job. Otherwise, this member is ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_EXTENDED_LIMIT_INFORMATION.PeakProcessMemoryUsed">
            <summary>
            The peak memory used by any process ever associated with the job.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOBOBJECT_EXTENDED_LIMIT_INFORMATION.PeakJobMemoryUsed">
            <summary>
            The peak memory usage of all processes currently associated with the job.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.JOB_OBJECT_LIMIT_FLAGS">
            <summary>
            The limit flags that are in effect
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOB_OBJECT_LIMIT_FLAGS.JOB_OBJECT_LIMIT_WORKINGSET">
            <summary>
            Causes all processes associated with the job to use the same minimum and maximum working set sizes.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOB_OBJECT_LIMIT_FLAGS.JOB_OBJECT_LIMIT_PROCESS_TIME">
            <summary>
            Causes all processes associated with the job to use the same priority class.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOB_OBJECT_LIMIT_FLAGS.JOB_OBJECT_LIMIT_JOB_TIME">
            <summary>
            Establishes a user-mode execution time limit for the job.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOB_OBJECT_LIMIT_FLAGS.JOB_OBJECT_LIMIT_ACTIVE_PROCESS">
            <summary>
            Establishes a maximum number of simultaneously active processes associated with the job.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOB_OBJECT_LIMIT_FLAGS.JOB_OBJECT_LIMIT_AFFINITY">
            <summary>
            Causes all processes associated with the job to use the same processor affinity.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOB_OBJECT_LIMIT_FLAGS.JOB_OBJECT_LIMIT_PRIORITY_CLASS">
            <summary>
            Causes all processes associated with the job to use the same priority class.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOB_OBJECT_LIMIT_FLAGS.JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME">
            <summary>
            Preserves any job time limits you previously set. As long as this flag is set, you can establish a per-job time limit once, then alter other limits in subsequent calls.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOB_OBJECT_LIMIT_FLAGS.JOB_OBJECT_LIMIT_SCHEDULING_CLASS">
            <summary>
            Causes all processes in the job to use the same scheduling class.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOB_OBJECT_LIMIT_FLAGS.JOB_OBJECT_LIMIT_PROCESS_MEMORY">
            <summary>
            Causes all processes associated with the job to limit their committed memory.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOB_OBJECT_LIMIT_FLAGS.JOB_OBJECT_LIMIT_JOB_MEMORY">
            <summary>
            Causes all processes associated with the job to limit the job-wide sum of their committed memory.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOB_OBJECT_LIMIT_FLAGS.JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION">
            <summary>
            Forces a call to the SetErrorMode function with the SEM_NOGPFAULTERRORBOX flag for each process associated with the job.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOB_OBJECT_LIMIT_FLAGS.JOB_OBJECT_LIMIT_BREAKAWAY_OK">
            <summary>
            If any process associated with the job creates a child process using the CREATE_BREAKAWAY_FROM_JOB flag while this limit is in effect, the child process is not associated with the job.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOB_OBJECT_LIMIT_FLAGS.JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK">
            <summary>
            Allows any process associated with the job to create child processes that are not associated with the job.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOB_OBJECT_LIMIT_FLAGS.JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE">
            <summary>
            Causes all processes associated with the job to terminate when the last handle to the job is closed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.JOB_OBJECT_LIMIT_FLAGS.JOB_OBJECT_LIMIT_SUBSET_AFFINITY">
            <summary>
            Allows processes to use a subset of the processor affinity for all processes associated with the job.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.KEY_EVENT_RECORD">
            <summary>
            Describes a keyboard input event in a console <see cref="T:PInvoke.Kernel32.INPUT_RECORD"/> structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.KEY_EVENT_RECORD.bKeyDown">
            <summary>
            If the key is pressed, this member is TRUE. Otherwise, this member is FALSE (the key is released).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.KEY_EVENT_RECORD.wRepeatCount">
            <summary>
            The repeat count, which indicates that a key is being held down.
            For example, when a key is held down, you might get five events with this member equal to 1,
            one event with this member equal to 5, or multiple events with this member greater than or equal to 1.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.KEY_EVENT_RECORD.wVirtualKeyCode">
            <summary>
            A virtual-key code that identifies the given key in a device-independent manner.
            Possible values are in the User32.VirtualKey enum.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.KEY_EVENT_RECORD.wVirtualScanCode">
            <summary>
            The virtual scan code of the given key that represents the device-dependent value generated by the keyboard hardware.
            Possible values are in the User32.ScanCode enum.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.KEY_EVENT_RECORD.uChar">
            <summary>
            A union of the Unicode and Ascii encodings.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.KEY_EVENT_RECORD.dwControlKeyState">
            <summary>
            The state of the control keys.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.MAKELANGID(System.UInt16,System.UInt16)">
            <summary>
                Creates a language identifier from a primary language identifier and a sublanguage identifier.
            </summary>
            <param name="usPrimaryLanguage">
                Primary language identifier. This identifier can be a predefined value or a value for a user-defined primary
                language. For a user-defined language, the identifier is a value in the range 0x0200 to 0x03FF. All other
                values are reserved for operating system use. For more information, see Language Identifier Constants and
                Strings.
            </param>
            <param name="usSubLanguage">
                Sublanguage identifier. This parameter can be a predefined sublanguage identifier or a user-defined
                sublanguage. For a user-defined sublanguage, the identifier is a value in the range 0x20 to 0x3F. All other
                values are reserved for operating system use. For more information, see Language Identifier Constants and
                Strings.
            </param>
            <returns>Returns the language identifier.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.MAKELANGID(PInvoke.Kernel32.LANGID.PrimaryLanguage,PInvoke.Kernel32.LANGID.SubLanguage)">
            <summary>
                Creates a language identifier from a primary language identifier and a sublanguage identifier.
            </summary>
            <param name="ePrimaryLanguage">
                Primary language identifier. This identifier can be a predefined value or a value for a user-defined primary
                language. For a user-defined language, the identifier is a value in the range 0x0200 to 0x03FF. All other
                values are reserved for operating system use. For more information, see Language Identifier Constants and
                Strings.
            </param>
            <param name="eSubLanguage">
                Sublanguage identifier. This parameter can be a predefined sublanguage identifier or a user-defined
                sublanguage. For a user-defined sublanguage, the identifier is a value in the range 0x20 to 0x3F. All other
                values are reserved for operating system use. For more information, see Language Identifier Constants and
                Strings.
            </param>
            <returns>Returns the language identifier.</returns>
        </member>
        <member name="T:PInvoke.Kernel32.LANGID">
            <summary>
            Represents a language identifier.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.LoadLibraryExFlags">
            <summary>
            Flags that may be passed to the <see cref="M:PInvoke.Kernel32.LoadLibraryEx(System.String,System.IntPtr,PInvoke.Kernel32.LoadLibraryExFlags)"/> function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.None">
            <summary>
            Define no flags, the function will behave as <see cref="M:PInvoke.Kernel32.LoadLibrary(System.String)"/> does.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.DONT_RESOLVE_DLL_REFERENCES">
            <summary>
                If this value is used, and the executable module is a DLL, the system does not call DllMain for process and
                thread initialization and termination. Also, the system does not load additional executable modules that are
                referenced by the specified module.
            </summary>
            <remarks>
                Do not use this value; it is provided only for backward compatibility. If you are planning to access only data
                or resources in the DLL, use <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE" /> or
                <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_IMAGE_RESOURCE" /> or both. Otherwise, load the library as a DLL or executable module
                using the LoadLibrary function.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_IGNORE_CODE_AUTHZ_LEVEL">
            <summary>
                If this value is used, the system does not check AppLocker rules or apply Software Restriction Policies for
                the DLL. This action applies only to the DLL being loaded and not to its dependencies. This value is recommended
                for use in setup programs that must run extracted DLLs during installation.
            </summary>
            <remarks>
                <para>
                    Windows Server 2008 R2 and Windows 7:  On systems with KB2532445 installed, the caller must be running as
                    "LocalSystem" or "TrustedInstaller"; otherwise the system ignores this flag. For more information, see "You can
                    circumvent AppLocker rules by using an Office macro on a computer that is running Windows 7 or Windows Server
                    2008 R2" in the Help and Support Knowledge Base at http://support.microsoft.com/kb/2532445.
                </para>
                <para>
                    Windows Server 2008, Windows Vista, Windows Server 2003, and Windows XP:  AppLocker was introduced in Windows
                    7 and Windows Server 2008 R2.
                </para>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE">
            <summary>
                If this value is used, the system maps the file into the calling process's virtual address space as if it were
                a data file. Nothing is done to execute or prepare to execute the mapped file. Therefore, you cannot call functions
                like GetModuleFileName, GetModuleHandle or GetProcAddress with this DLL. Using this value causes writes to
                read-only memory to raise an access violation. Use this flag when you want to load a DLL only to extract messages
                or resources from it.
                <para>This value can be used with <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_IMAGE_RESOURCE" />.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE">
            <summary>
                Similar to <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE" />, except that the DLL file is opened with exclusive write
                access for the calling process. Other processes cannot open the DLL file for write access while it is in use.
                However, the DLL can still be opened by other processes.
                <para>This value can be used with <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_IMAGE_RESOURCE" />.</para>
            </summary>
            <remarks>Windows Server 2003 and Windows XP:  This value is not supported until Windows Vista.</remarks>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_IMAGE_RESOURCE">
            <summary>
                If this value is used, the system maps the file into the process's virtual address space as an image file. However,
                the loader does not load the static imports or perform the other usual initialization steps. Use this flag when you
                want to load a DLL only to extract messages or resources from it.
                <para>
                    Unless the application depends on the file having the in-memory layout of an image, this value should be used
                    with either <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE" /> or <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE" />. For
                    more information, see the Remarks section.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_APPLICATION_DIR">
            <summary>
                If this value is used, the application's installation directory is searched for the DLL and its dependencies.
                Directories in the standard search path are not searched. This value cannot be combined with
                <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_WITH_ALTERED_SEARCH_PATH" />.
            </summary>
            <remarks>
                Windows 7, Windows Server 2008 R2, Windows Vista, and Windows Server 2008:  This value requires KB2533623 to
                be installed.
                <para>Windows Server 2003 and Windows XP:  This value is not supported.</para>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_DEFAULT_DIRS">
            <summary>
                This value is a combination of <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_APPLICATION_DIR" />,
                <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_SYSTEM32" />, and <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_USER_DIRS" />. Directories in the
                standard search path are not searched. This value cannot be combined with
                <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_WITH_ALTERED_SEARCH_PATH" />.
                <para>
                    This value represents the recommended maximum number of directories an application should include in its DLL
                    search path.
                </para>
            </summary>
            <remarks>
                Windows 7, Windows Server 2008 R2, Windows Vista, and Windows Server 2008:  This value requires KB2533623 to
                be installed.
                <para>Windows Server 2003 and Windows XP:  This value is not supported.</para>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR">
            <summary>
                If this value is used, the directory that contains the DLL is temporarily added to the beginning of the list of
                directories that are searched for the DLL's dependencies. Directories in the standard search path are not searched.
                <para>
                    The lpFileName parameter must specify a fully qualified path. This value cannot be combined with
                    <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_WITH_ALTERED_SEARCH_PATH" />.
                </para>
                <para>
                    For example, if Lib2.dll is a dependency of C:\Dir1\Lib1.dll, loading Lib1.dll with this value causes the
                    system to search for Lib2.dll only in C:\Dir1. To search for Lib2.dll in C:\Dir1 and all of the directories in
                    the DLL search path, combine this value with <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_DEFAULT_DIRS" />.
                </para>
            </summary>
            <remarks>
                Windows 7, Windows Server 2008 R2, Windows Vista, and Windows Server 2008:  This value requires KB2533623 to
                be installed.
                <para>Windows Server 2003 and Windows XP:  This value is not supported.</para>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_SYSTEM32">
            <summary>
                If this value is used, %windows%\system32 is searched for the DLL and its dependencies. Directories in the
                standard search path are not searched. This value cannot be combined with
                <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_WITH_ALTERED_SEARCH_PATH" />.
            </summary>
            <remarks>
                Windows 7, Windows Server 2008 R2, Windows Vista, and Windows Server 2008:  This value requires KB2533623 to
                be installed.
                <para>Windows Server 2003 and Windows XP:  This value is not supported.</para>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_SEARCH_USER_DIRS">
            <summary>
                If this value is used, directories added using the AddDllDirectory or the SetDllDirectory function are
                searched for the DLL and its dependencies. If more than one directory has been added, the order in which the
                directories are searched is unspecified. Directories in the standard search path are not searched. This value
                cannot be combined with <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_WITH_ALTERED_SEARCH_PATH" />.
            </summary>
            <remarks>
                Windows 7, Windows Server 2008 R2, Windows Vista, and Windows Server 2008:  This value requires KB2533623 to
                be installed.
                <para>Windows Server 2003 and Windows XP:  This value is not supported.</para>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_WITH_ALTERED_SEARCH_PATH">
            <summary>
                If this value is used and lpFileName specifies an absolute path, the system uses the alternate file search strategy
                discussed in the Remarks section to find associated executable modules that the specified module causes to be
                loaded. If this value is used and lpFileName specifies a relative path, the behavior is undefined.
                <para>
                    If this value is not used, or if lpFileName does not specify a path, the system uses the standard search
                    strategy discussed in the Remarks section to find associated executable modules that the specified module
                    causes to be loaded.
                </para>
                <para>This value cannot be combined with any LOAD_LIBRARY_SEARCH flag.</para>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.LocalAllocFlags">
            <summary>
            Flags for the <see cref="M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_FIXED">
            <summary>
            Allocates fixed memory. The return value is a pointer to the memory object.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LocalAllocFlags.LHND">
            <summary>
            Combines LMEM_MOVEABLE and LMEM_ZEROINIT
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_MOVEABLE">
            <summary>
            Allocates movable memory. Memory blocks are never moved in physical memory, but they can be moved within the default heap.
            The return value is a handle to the memory object. To translate the handle to a pointer, use the LocalLock function.
            This value cannot be combined with <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_FIXED"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_ZEROINIT">
            <summary>
            Initializes memory contents to zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LocalAllocFlags.LPTR">
            <summary>
            Combines <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_FIXED"/> and <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_ZEROINIT"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LocalAllocFlags.NONZEROLHND">
            <summary>
            Same as <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_MOVEABLE"/>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LocalAllocFlags.NONZEROLPTR">
            <summary>
            Same as <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_FIXED"/>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.LocalReAllocFlags">
            <summary>
            Flags for the <see cref="M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.LocalReAllocFlags)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MODIFY">
            <summary>
            modifies the attributes of the memory object only (the uBytes parameter is ignored.) Otherwise, the function reallocates the memory object.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MOVEABLE">
            <summary>
            Allocates fixed or movable memory.
            If the memory is a locked <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_MOVEABLE"/> memory block or
            a <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_FIXED"/> memory block and this flag is not specified, the memory can only be reallocated in place.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_ZEROINIT">
            <summary>
            Causes the additional memory contents to be initialized to zero if the memory object is growing in size.
            </summary>
            <remarks>If the parameter does not specify <see cref="F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MODIFY"/>, you can use this value.</remarks>
        </member>
        <member name="T:PInvoke.Kernel32.MENU_EVENT_RECORD">
            <summary>
            Describes a menu event in a console <see cref="T:PInvoke.Kernel32.INPUT_RECORD"/> structure.
            </summary>
            <remarks>
            These events are used internally and should be ignored.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.MENU_EVENT_RECORD.dwCommandId">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.MODULEENTRY32">
            <summary>
            Describes an entry from a list of the modules belonging to the specified process.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MODULEENTRY32.dwSize">
            <summary>
            The size of the structure, in bytes. Set automatically by the <see cref="M:PInvoke.Kernel32.MODULEENTRY32.Create"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MODULEENTRY32.th32ModuleID">
            <summary>
            This member is no longer used, and is always set to one.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MODULEENTRY32.th32ProcessID">
            <summary>
            The identifier of the process whose modules are to be examined.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MODULEENTRY32.GlblcntUsage">
            <summary>
            The load count of the module, which is not generally meaningful, and usually equal to <c>0xFFFF</c>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MODULEENTRY32.ProccntUsage">
            <summary>
            The load count of the module (same as <see cref="F:PInvoke.Kernel32.MODULEENTRY32.GlblcntUsage"/>), which is not generally meaningful, and usually equal to <c>0xFFFF</c>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MODULEENTRY32.modBaseAddr">
            <summary>
            The base address of the module in the context of the owning process.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MODULEENTRY32.modBaseSize">
            <summary>
            The size of the module, in bytes.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MODULEENTRY32.hModule">
            <summary>
            A handle to the module in the context of the owning process.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MODULEENTRY32.szModule">
            <summary>
            The module name.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MODULEENTRY32.szExePath">
            <summary>
            The module path.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.MODULEENTRY32.Module">
            <summary>
            Gets the name of the module, as specified by the <see cref="F:PInvoke.Kernel32.MODULEENTRY32.szModule"/> character array.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.MODULEENTRY32.ExePath">
            <summary>
            Gets the executable path for the module, as specified by the <see cref="F:PInvoke.Kernel32.MODULEENTRY32.szExePath"/> character array.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.MODULEENTRY32.Create">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.MODULEENTRY32" /> struct
            with <see cref="F:PInvoke.Kernel32.MODULEENTRY32.dwSize" /> set to the correct value.
            </summary>
            <returns>An instance of <see cref="T:PInvoke.Kernel32.MODULEENTRY32"/>.</returns>
        </member>
        <member name="P:PInvoke.Kernel32.MODULEENTRY32.modBaseAddr_IntPtr">
            <summary>
            The base address of the module in the context of the owning process.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.MODULEENTRY32.hModule_IntPtr">
            <summary>
            A handle to the module in the context of the owning process.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.MouseButtonStates">
            <summary>
            Describes the state of the mouse buttons.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MouseButtonStates.FROM_LEFT_1ST_BUTTON_PRESSED">
            <summary>
            The leftmost mouse button.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MouseButtonStates.FROM_LEFT_2ND_BUTTON_PRESSED">
            <summary>
            The second button from the left.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MouseButtonStates.FROM_LEFT_3RD_BUTTON_PRESSED">
            <summary>
            The third button from the left.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MouseButtonStates.FROM_LEFT_4TH_BUTTON_PRESSED">
            <summary>
            The fourth button from the left.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MouseButtonStates.RIGHTMOST_BUTTON_PRESSED">
            <summary>
            The rightmost mouse button.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.MouseEvents">
            <summary>
            Describes the type of the mouse event.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MouseEvents.None">
            <summary>
            If this is the value, it indicates a mouse button being pressed or released. Otherwise, it takes one of the other values.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MouseEvents.DOUBLE_CLICK">
            <summary>
            The second click (button press) of a double-click occurred. The first click is returned as a regular button-press event.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MouseEvents.MOUSE_HWHEELED">
            <summary>
            The horizontal mouse wheel was moved.
            If the high word of the <see cref="F:PInvoke.Kernel32.MOUSE_EVENT_RECORD.dwButtonState"/> member contains a positive value,
            the wheel was rotated to the right. Otherwise, the wheel was rotated to the left.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MouseEvents.MOUSE_MOVED">
            <summary>
            A change in mouse position occurred.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MouseEvents.MOUSE_WHEELED">
            <summary>
            The vertical mouse wheel was moved.
            If the high word of the <see cref="F:PInvoke.Kernel32.MOUSE_EVENT_RECORD.dwButtonState"/>  member contains a positive value,
            the wheel was rotated forward, away from the user. Otherwise, the wheel was rotated backward, toward the user.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.MOUSE_EVENT_RECORD">
            <summary>
            Describes a mouse input event in a console <see cref="T:PInvoke.Kernel32.INPUT_RECORD"/> structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MOUSE_EVENT_RECORD.dwMousePosition">
            <summary>
            A <see cref="T:PInvoke.COORD"/> structure that contains the location of the cursor, in terms of the console screen buffer's character-cell coordinates.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MOUSE_EVENT_RECORD.dwButtonState">
            <summary>
            The status of the mouse buttons.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MOUSE_EVENT_RECORD.dwControlKeyState">
            <summary>
            The state of the control keys.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MOUSE_EVENT_RECORD.dwEventFlags">
            <summary>
            The type of mouse event. If this value is <see cref="F:PInvoke.Kernel32.MouseEvents.None"/>, it indicates a mouse button being pressed or released.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.NamedPipeInfoFlags">
            <summary>Flags returned by <see cref="M:PInvoke.Kernel32.GetNamedPipeInfo(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.NamedPipeInfoFlags@,System.Int32@,System.Int32@,System.Int32@)" />.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.NamedPipeInfoFlags.PIPE_CLIENT_END">
            <summary>The handle refers to the client end of a named pipe instance. This is the default.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.NamedPipeInfoFlags.PIPE_SERVER_END">
            <summary>
                The handle refers to the server end of a named pipe instance. If this value is not specified, the handle
                refers to the client end of a named pipe instance.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.NamedPipeInfoFlags.PIPE_TYPE_BYTE">
            <summary>The named pipe is a byte pipe. This is the default.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.NamedPipeInfoFlags.PIPE_TYPE_MESSAGE">
            <summary>The named pipe is a message pipe. If this value is not specified, the pipe is a byte pipe.</summary>
        </member>
        <member name="T:PInvoke.Kernel32.PipeAccessMode">
            <summary>
            Pipe access mode used when creating a pipe using <see cref="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeAccessMode.PIPE_ACCESS_DUPLEX">
            <summary>
                The pipe is bi-directional; both server and client processes can read from and write to the pipe. This mode
                gives the server the equivalent of GENERIC_READ and GENERIC_WRITE access to the pipe. The client can specify
                GENERIC_READ or GENERIC_WRITE, or both, when it connects to the pipe using the CreateFile function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeAccessMode.PIPE_ACCESS_INBOUND">
            <summary>
                The flow of data in the pipe goes from client to server only. This mode gives the server the equivalent of
                GENERIC_READ access to the pipe. The client must specify GENERIC_WRITE access when connecting to the pipe. If the
                client must read pipe settings by calling the GetNamedPipeInfo or GetNamedPipeHandleState functions, the client
                must specify GENERIC_WRITE and FILE_READ_ATTRIBUTES access when connecting to the pipe.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeAccessMode.PIPE_ACCESS_OUTBOUND">
            <summary>
                The flow of data in the pipe goes from server to client only. This mode gives the server the equivalent of
                GENERIC_WRITE access to the pipe. The client must specify GENERIC_READ access when connecting to the pipe. If the
                client must change pipe settings by calling the SetNamedPipeHandleState function, the client must specify
                GENERIC_READ and FILE_WRITE_ATTRIBUTES access when connecting to the pipe.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeAccessMode.FILE_FLAG_FIRST_PIPE_INSTANCE">
            <summary>
                If you attempt to create multiple instances of a pipe with this flag, creation of the first instance succeeds,
                but creation of the next instance fails with ERROR_ACCESS_DENIED.
                <para>Windows 2000: This flag is not supported until Windows 2000 SP2 and Windows XP.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeAccessMode.FILE_FLAG_WRITE_THROUGH">
            <summary>
                Write-through mode is enabled. This mode affects only write operations on byte-type pipes and, then, only when
                the client and server processes are on different computers. If this mode is enabled, functions writing to a named
                pipe do not return until the data written is transmitted across the network and is in the pipe's buffer on the
                remote computer. If this mode is not enabled, the system enhances the efficiency of network operations by buffering
                data until a minimum number of bytes accumulate or until a maximum time elapses.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeAccessMode.FILE_FLAG_OVERLAPPED">
            <summary>
                Overlapped mode is enabled. If this mode is enabled, functions performing read, write, and connect operations
                that may take a significant time to be completed can return immediately. This mode enables the thread that started
                the operation to perform other operations while the time-consuming operation executes in the background. For
                example, in overlapped mode, a thread can handle simultaneous input and output (I/O) operations on multiple
                instances of a pipe or perform simultaneous read and write operations on the same pipe handle. If overlapped mode
                is not enabled, functions performing read, write, and connect operations on the pipe handle do not return until the
                operation is finished. The ReadFileEx and WriteFileEx functions can only be used with a pipe handle in overlapped
                mode. The ReadFile, WriteFile, ConnectNamedPipe, and TransactNamedPipe functions can execute either synchronously
                or as overlapped operations.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeAccessMode.WRITE_DAC">
            <summary>The caller will have write access to the named pipe's discretionary access control list (ACL).</summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeAccessMode.WRITE_OWNER">
            <summary>The caller will have write access to the named pipe's owner.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeAccessMode.ACCESS_SYSTEM_SECURITY">
            <summary>The caller will have write access to the named pipe's SACL.</summary>
        </member>
        <member name="T:PInvoke.Kernel32.PipeMode">
            <summary>A named pipe usage mode, used in <see cref="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)" />.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeMode.PIPE_TYPE_BYTE">
            <summary>
                Data is written to the pipe as a stream of bytes. This mode cannot be used with
                <see cref="F:PInvoke.Kernel32.PipeMode.PIPE_READMODE_MESSAGE" />. The pipe does not distinguish bytes written during different write
                operations.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeMode.PIPE_TYPE_MESSAGE">
            <summary>
                Data is written to the pipe as a stream of messages. The pipe treats the bytes written during each write
                operation as a message unit. The GetLastError function returns <see cref="F:PInvoke.Win32ErrorCode.ERROR_MORE_DATA" /> when a
                message is not read completely. This mode can be used with either <see cref="F:PInvoke.Kernel32.PipeMode.PIPE_READMODE_MESSAGE" /> or
                <see cref="F:PInvoke.Kernel32.PipeMode.PIPE_READMODE_BYTE" />.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeMode.PIPE_READMODE_BYTE">
            <summary>
                Data is read from the pipe as a stream of bytes. This mode can be used with either
                <see cref="F:PInvoke.Kernel32.PipeMode.PIPE_TYPE_MESSAGE" /> or
                <see cref="F:PInvoke.Kernel32.PipeMode.PIPE_TYPE_BYTE" />.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeMode.PIPE_READMODE_MESSAGE">
            <summary>
                Data is read from the pipe as a stream of messages. This mode can be only used if
                <see cref="F:PInvoke.Kernel32.PipeMode.PIPE_TYPE_MESSAGE" /> is also specified.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeMode.PIPE_WAIT">
            <summary>
                Blocking mode is enabled. When the pipe handle is specified in the
                <see cref="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)" />,
                <see cref="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)" />, or <see cref="M:PInvoke.Kernel32.ConnectNamedPipe(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.OVERLAPPED*)"/> function, the
                operations are not completed until there is data to read, all data is written, or a client is connected. Use of
                this mode can mean waiting indefinitely in some situations for a client process to perform an action.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeMode.PIPE_NOWAIT">
            <summary>
                Nonblocking mode is enabled. In this mode,
                <see cref="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)" />,
                <see cref="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)" />, and ConnectNamedPipe always
                return immediately.
                <para>
                    Note that nonblocking mode is supported for compatibility with Microsoft LAN Manager version 2.0 and should
                    not be used to achieve asynchronous I/O with named pipes.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeMode.PIPE_ACCEPT_REMOTE_CLIENTS">
            <summary>Connections from remote clients can be accepted and checked against the security descriptor for the pipe.
                <para>Windows Server 2003 and Windows XP/2000:  This flag is not supported.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PipeMode.PIPE_REJECT_REMOTE_CLIENTS">
            <summary>
                Connections from remote clients are automatically rejected.
                <para>
                    Windows Server 2003 and Windows XP/2000:  This flag is not supported. To achieve the same results, deny
                    access to the pipe to the NETWORK ACE.
                </para>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ProcessAccess">
            <summary>
            Enumerates the <see cref="P:PInvoke.Kernel32.ACCESS_MASK.SpecificRights"/> that may apply to processes.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_CREATE_PROCESS">
            <summary>Required to create a process.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_CREATE_THREAD">
            <summary>Required to create a thread.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_DUP_HANDLE">
            <summary>Required to duplicate a handle using DuplicateHandle.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_INFORMATION">
            <summary>
            Required to retrieve certain information about a process, such as its token, exit code, and priority class
            (see OpenProcessToken).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_LIMITED_INFORMATION">
            <summary>
            Required to retrieve certain information about a process (see GetExitCodeProcess, GetPriorityClass,
            IsProcessInJob, QueryFullProcessImageName). A handle that has the <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_INFORMATION" /> access right
            is automatically granted <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_LIMITED_INFORMATION" />.
            </summary>
            <remarks>Windows Server 2003 and Windows XP:  This access right is not supported.</remarks>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_SET_INFORMATION">
            <summary>Required to set certain information about a process, such as its priority class (see SetPriorityClass).</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_SET_QUOTA">
            <summary>Required to set memory limits using SetProcessWorkingSetSize.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_SUSPEND_RESUME">
            <summary>Required to suspend or resume a process.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_TERMINATE">
            <summary>Required to terminate a process using TerminateProcess.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_VM_OPERATION">
            <summary>
            Required to perform an operation on the address space of a process (see VirtualProtectEx and
            WriteProcessMemory).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_VM_READ">
            <summary>Required to read memory in a process using ReadProcessMemory.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_VM_WRITE">
            <summary>Required to write to memory in a process using WriteProcessMemory.</summary>
        </member>
        <member name="T:PInvoke.Kernel32.PROCESSENTRY32">
            <summary>
            Describes an entry from a list of the processes residing in the system address space when a snapshot was taken.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSENTRY32.dwSize">
            <summary>
            The size of the structure, in bytes. Set automatically by the <see cref="M:PInvoke.Kernel32.PROCESSENTRY32.Create"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSENTRY32.cntUsage">
            <summary>
            This member is no longer used and is always set to zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSENTRY32.th32ProcessID">
            <summary>
            The process identifier.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSENTRY32.th32DefaultHeapID">
            <summary>
            This member is no longer used and is always set to zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSENTRY32.th32ModuleID">
            <summary>
            This member is no longer used and is always set to zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSENTRY32.cntThreads">
            <summary>
            The number of execution threads started by the process.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSENTRY32.th32ParentProcessID">
            <summary>
            The identifier of the process that created this process (its parent process).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSENTRY32.pcPriClassBase">
            <summary>
            The base priority of any threads created by this process.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSENTRY32.dwFlags">
            <summary>
            This member is no longer used, and is always set to zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSENTRY32.szExeFile">
            <summary>
            The name of the executable file for the process.
            <para>
            To retrieve the full path to the executable file, call the Module32First function and check the szExePath member
            of the MODULEENTRY32 structure that is returned. However, if the calling process is a 32-bit process, you must call the
            <see cref="M:PInvoke.Kernel32.QueryFullProcessImageName(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.QueryFullProcessImageNameFlags,System.Char*,System.Int32@)" />
            function to retrieve the full path of the executable file for a 64-bit process.
            </para>
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.PROCESSENTRY32.ExeFile">
            <summary>
            Gets the name of the executable file for the process, as specified by the <see cref="F:PInvoke.Kernel32.PROCESSENTRY32.szExeFile"/> character array.
            <para>
            To retrieve the full path to the executable file, call the <see cref="M:PInvoke.Kernel32.Module32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.MODULEENTRY32*)"/> function and check the <see cref="F:PInvoke.Kernel32.MODULEENTRY32.szExePath"/> member
            of the <see cref="T:PInvoke.Kernel32.MODULEENTRY32"/> structure that is returned. However, if the calling process is a 32-bit process, you must call the
            <see cref="M:PInvoke.Kernel32.QueryFullProcessImageName(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.QueryFullProcessImageNameFlags,System.Char*,System.Int32@)" />
            function to retrieve the full path of the executable file for a 64-bit process.
            </para>
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.PROCESSENTRY32.Create">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.PROCESSENTRY32" /> struct
            with <see cref="F:PInvoke.Kernel32.PROCESSENTRY32.dwSize" /> set to the correct value.
            </summary>
            <returns>An instance of <see cref="T:PInvoke.Kernel32.PROCESSENTRY32"/>.</returns>
        </member>
        <member name="T:PInvoke.Kernel32.ProcessShutdownFlags">
            <summary>
            Values that are passed to the <see cref="M:PInvoke.Kernel32.SetProcessShutdownParameters(System.Int32,PInvoke.Kernel32.ProcessShutdownFlags)"/> flag.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessShutdownFlags.SHUTDOWN_NORETRY">
            <summary>
            The system terminates the process without displaying a retry dialog box for the user.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.PROCESS_INFORMATION">
            <summary>
            Contains information about a newly created process and its primary thread. It is used with the <see cref="M:PInvoke.Kernel32.CreateProcess(System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)"/>,
            <see cref="M:PInvoke.Kernel32.CreateProcessAsUser(System.IntPtr,System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)"/>, CreateProcessWithLogonW, or CreateProcessWithTokenW function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_INFORMATION.hProcess">
            <summary>
            A handle to the newly created process. The handle is used to specify the process in all functions that perform operations on the process object.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_INFORMATION.hThread">
            <summary>
            A handle to the primary thread of the newly created process. The handle is used to specify the thread in all functions that perform operations on the thread object.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_INFORMATION.dwProcessId">
            <summary>
            A value that can be used to identify a process. The value is valid from the time the process is created until all handles to the process are closed and the process object is freed; at this point, the identifier may be reused.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_INFORMATION.dwThreadId">
            <summary>
            A value that can be used to identify a thread. The value is valid from the time the thread is created until all handles to the thread are closed and the thread object is freed; at this point, the identifier may be reused.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST">
            <summary>
            An empty struct.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.QueryFullProcessImageNameFlags.None">
            <summary>
            The name should use the Win32 path format.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.QueryFullProcessImageNameFlags.PROCESS_NAME_NATIVE">
            <summary>
            The name should use the native system path format.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_CURSOR">
            <summary>Hardware-dependent cursor resource.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_BITMAP">
            <summary>Bitmap resource.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_ICON">
            <summary>Hardware-dependent icon resource.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_MENU">
            <summary>Menu resource.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_DIALOG">
            <summary>Dialog box.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_STRING">
            <summary>String-table entry.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_FONTDIR">
            <summary>Font directory resource.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_FONT">
            <summary>Font resource.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_ACCELERATOR">
            <summary>Accelerator table.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_RCDATA">
            <summary>Application-defined resource (raw data).</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_MESSAGETABLE">
            <summary>Message-table entry.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_GROUP_CURSOR">
            <summary>Hardware-independent cursor resource.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_GROUP_ICON">
            <summary>Hardware-independent icon resource.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_VERSION">
            <summary>Version resource</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_DLGINCLUDE">
            <summary>
                Allows a resource editing tool to associate a string with an .rc file. Typically, the string is the name of the
                header file that provides symbolic names. The resource compiler parses the string but otherwise ignores the value.
                For example,
                <para>
                    <code>1 DLGINCLUDE "MyFile.h"</code>
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_PLUGPLAY">
            <summary>Plug and Play resource.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_VXD">
            <summary>VXD.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_ANICURSOR">
            <summary>Animated cursor.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_ANIICON">
            <summary>Animated icon.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.RT_HTML">
            <summary>HTML resource.</summary>
        </member>
        <member name="T:PInvoke.Kernel32.STARTUPINFO">
            <summary>
            Specifies the window station, desktop, standard handles, and appearance of the main window for a process at creation time.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.cb">
            <summary>
            The size of this data structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.lpReserved">
            <summary>
            Reserved; must be NULL.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.lpDesktop">
            <summary>
            The name of the desktop, or the name of both the desktop and window station for this process. A backslash in the string indicates that the string includes both the desktop and window station names. For more information, see Thread Connection to a Desktop.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.lpTitle">
            <summary>
            For console processes, this is the title displayed in the title bar if a new console window is created. If NULL, the name of the executable file is used as the window title instead. This parameter must be NULL for GUI or console processes that do not create a new console window.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.dwX">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies STARTF_USEPOSITION, this member is the x offset of the upper left corner of a window if a new window is created, in pixels. Otherwise, this member is ignored.
            The offset is from the upper left corner of the screen. For GUI processes, the specified position is used the first time the new process calls CreateWindow to create an overlapped window if the x parameter of CreateWindow is CW_USEDEFAULT.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.dwY">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies STARTF_USEPOSITION, this member is the y offset of the upper left corner of a window if a new window is created, in pixels. Otherwise, this member is ignored.
            The offset is from the upper left corner of the screen. For GUI processes, the specified position is used the first time the new process calls CreateWindow to create an overlapped window if the y parameter of CreateWindow is CW_USEDEFAULT.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.dwXSize">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies STARTF_USESIZE, this member is the width of the window if a new window is created, in pixels. Otherwise, this member is ignored.
            For GUI processes, this is used only the first time the new process calls CreateWindow to create an overlapped window if the nWidth parameter of CreateWindow is CW_USEDEFAULT.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.dwYSize">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies STARTF_USESIZE, this member is the height of the window if a new window is created, in pixels. Otherwise, this member is ignored.
            For GUI processes, this is used only the first time the new process calls CreateWindow to create an overlapped window if the nHeight parameter of CreateWindow is CW_USEDEFAULT.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.dwXCountChars">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies STARTF_USECOUNTCHARS, if a new console window is created in a console process, this member specifies the screen buffer width, in character columns. Otherwise, this member is ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.dwYCountChars">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies STARTF_USECOUNTCHARS, if a new console window is created in a console process, this member specifies the screen buffer height, in character rows. Otherwise, this member is ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.dwFillAttribute">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies STARTF_USEFILLATTRIBUTE, this member is the initial text and background colors if a new console window is created in a console application. Otherwise, this member is ignored.
            This value can be any combination of the following values: FOREGROUND_BLUE, FOREGROUND_GREEN, FOREGROUND_RED, FOREGROUND_INTENSITY, BACKGROUND_BLUE, BACKGROUND_GREEN, BACKGROUND_RED, and BACKGROUND_INTENSITY. For example, the following combination of values produces red text on a white background:
            FOREGROUND_RED| BACKGROUND_RED| BACKGROUND_GREEN| BACKGROUND_BLUE
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.dwFlags">
            <summary>
            A bitfield that determines whether certain STARTUPINFO members are used when the process creates a window.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.wShowWindow">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESHOWWINDOW"/>, this member can be any of the values that can be specified in the nCmdShow parameter for the ShowWindow function, except for SW_SHOWDEFAULT. Otherwise, this member is ignored.
            For GUI processes, the first time ShowWindow is called, its nCmdShow parameter is ignored wShowWindow specifies the default value. In subsequent calls to ShowWindow, the wShowWindow member is used if the nCmdShow parameter of ShowWindow is set to SW_SHOWDEFAULT.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.cbReserved2">
            <summary>
            Reserved for use by the C Run-time; must be zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.lpReserved2">
            <summary>
            Reserved for use by the C Run-time; must be NULL.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.hStdInput">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>, this member is the standard input handle for the process. If <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/> is not specified, the default for standard input is the keyboard buffer.
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USEHOTKEY"/>, this member specifies a hotkey value that is sent as the wParam parameter of a WM_SETHOTKEY message to the first eligible top-level window created by the application that owns the process. If the window is created with the WS_POPUP window style, it is not eligible unless the WS_EX_APPWINDOW extended window style is also set. For more information, see CreateWindowEx.
            Otherwise, this member is ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.hStdOutput">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>, this member is the standard output handle for the process. Otherwise, this member is ignored and the default for standard output is the console window's buffer.
            If a process is launched from the taskbar or jump list, the system sets <see cref="F:PInvoke.Kernel32.STARTUPINFO.hStdOutput"/> to a handle to the monitor that contains the taskbar or jump list used to launch the process. For more information, see Remarks.
            Windows 7, Windows Server 2008 R2, Windows Vista, Windows Server 2008, Windows XP, and Windows Server 2003:  This behavior was introduced in Windows 8 and Windows Server 2012.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFO.hStdError">
            <summary>
            If <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFlags"/> specifies <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>, this member is the standard error handle for the process. Otherwise, this member is ignored and the default for standard error is the console window's buffer.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.STARTUPINFO.Desktop">
            <summary>
            Gets the value of <see cref="F:PInvoke.Kernel32.STARTUPINFO.lpDesktop" /> as a string.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.STARTUPINFO.Title">
            <summary>
            Gets the value of <see cref="F:PInvoke.Kernel32.STARTUPINFO.lpDesktop" /> as a string.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.STARTUPINFO.Create">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> struct.
            </summary>
            <returns>An initialized instance of the struct.</returns>
        </member>
        <member name="P:PInvoke.Kernel32.STARTUPINFO.lpReserved_IntPtr">
            <summary>
            Reserved; must be NULL.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.STARTUPINFO.lpDesktop_IntPtr">
            <summary>
            The name of the desktop, or the name of both the desktop and window station for this process. A backslash in the string indicates that the string includes both the desktop and window station names. For more information, see Thread Connection to a Desktop.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.STARTUPINFO.lpTitle_IntPtr">
            <summary>
            For console processes, this is the title displayed in the title bar if a new console window is created. If NULL, the name of the executable file is used as the window title instead. This parameter must be NULL for GUI or console processes that do not create a new console window.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.STARTUPINFOEX">
            <summary>
            Specifies the window station, desktop, standard handles, and attributes for a new process. It is used with the <see cref="M:PInvoke.Kernel32.CreateProcess(System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)"/> and <see cref="M:PInvoke.Kernel32.CreateProcessAsUser(System.IntPtr,System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)"/> functions.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFOEX.StartupInfo">
            <summary>
            A <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.STARTUPINFOEX.lpAttributeList">
            <summary>
            An attribute list. This list is created by the <see cref="M:PInvoke.Kernel32.InitializeProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*,System.Int32,System.UInt32,System.IntPtr@)"/> function.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.STARTUPINFOEX.Create">
            <summary>
            Creates an instance of this structure and initializes its members to
            reasonable defaults.
            </summary>
            <returns>The initialized instance of this struct.</returns>
        </member>
        <member name="P:PInvoke.Kernel32.STARTUPINFOEX.lpAttributeList_IntPtr">
            <summary>
            An attribute list. This list is created by the <see cref = "M:PInvoke.Kernel32.InitializeProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*,System.Int32,System.UInt32,System.IntPtr@)"/> function.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.StartupInfoFlags">
            <summary>
            A bitfield that determines whether certain <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> members are used when the process creates a window.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.None">
            <summary>
            No flags.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_FORCEONFEEDBACK">
            <summary>
            Indicates that the cursor is in feedback mode for two seconds after <see cref="M:PInvoke.Kernel32.CreateProcessAsUser(System.IntPtr,System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)"/> is called. The Working in Background cursor is displayed (see the Pointers tab in the Mouse control panel utility).
            If during those two seconds the process makes the first GUI call, the system gives five more seconds to the process. If during those five seconds the process shows a window, the system gives five more seconds to the process to finish drawing the window.
            The system turns the feedback cursor off after the first call to GetMessage, regardless of whether the process is drawing.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_FORCEOFFFEEDBACK">
            <summary>
            Indicates that the feedback cursor is forced off while the process is starting. The Normal Select cursor is displayed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_PREVENTPINNING">
            <summary>
            Indicates that any windows created by the process cannot be pinned on the taskbar.
            This flag must be combined with <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_TITLEISAPPID"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_RUNFULLSCREEN">
            <summary>
            Indicates that the process should be run in full-screen mode, rather than in windowed mode.
            This flag is only valid for console applications running on an x86 computer.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_TITLEISAPPID">
            <summary>
            The lpTitle member contains an AppUserModelID. This identifier controls how the taskbar and Start menu present the application, and enables it to be associated with the correct shortcuts and Jump Lists. Generally, applications will use the SetCurrentProcessExplicitAppUserModelID and GetCurrentProcessExplicitAppUserModelID functions instead of setting this flag. For more information, see Application User Model IDs.
            If <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_PREVENTPINNING"/> is used, application windows cannot be pinned on the taskbar. The use of any AppUserModelID-related window properties by the application overrides this setting for that window only.
            This flag cannot be used with <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_TITLEISLINKNAME"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_TITLEISLINKNAME">
            <summary>
            The lpTitle member contains the path of the shortcut file (.lnk) that the user invoked to start this process. This is typically set by the shell when a .lnk file pointing to the launched application is invoked. Most applications will not need to set this value.
            This flag cannot be used with <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_TITLEISAPPID"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_UNTRUSTEDSOURCE">
            <summary>
            The command line came from an untrusted source. For more information, see Remarks.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USECOUNTCHARS">
            <summary>
            The <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwXCountChars"/> and <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwYCountChars"/> members contain additional information.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USEFILLATTRIBUTE">
            <summary>
            The <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwFillAttribute"/> member contains additional information.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USEHOTKEY">
            <summary>
            The <see cref="F:PInvoke.Kernel32.STARTUPINFO.hStdInput"/> member contains additional information.
            This flag cannot be used with <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USEPOSITION">
            <summary>
            The <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwX"/> and <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwY"/> members contain additional information.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESHOWWINDOW">
            <summary>
            The <see cref="F:PInvoke.Kernel32.STARTUPINFO.wShowWindow"/> member contains additional information.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESIZE">
            <summary>
            The <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwXSize"/> and <see cref="F:PInvoke.Kernel32.STARTUPINFO.dwYSize"/> members contain additional information.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES">
            <summary>
            The <see cref="F:PInvoke.Kernel32.STARTUPINFO.hStdInput"/>, <see cref="F:PInvoke.Kernel32.STARTUPINFO.hStdOutput"/>, and <see cref="F:PInvoke.Kernel32.STARTUPINFO.hStdError"/> members contain additional information.
            If this flag is specified when calling one of the process creation functions, the handles must be inheritable and the function's bInheritHandles parameter must be set to TRUE. For more information, see Handle Inheritance.
            If this flag is specified when calling the <see cref="M:PInvoke.Kernel32.GetStartupInfo(PInvoke.Kernel32.STARTUPINFO*)"/> function, these members are either the handle value specified during process creation or <see cref="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE"/>.
            Handles must be closed with <see cref="M:PInvoke.Kernel32.CloseHandle(System.IntPtr)"/> when they are no longer needed.
            This flag cannot be used with <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USEHOTKEY"/>.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.StdHandle">
            <summary>
            Standard handles for the <see cref="M:PInvoke.Kernel32.GetStdHandle(PInvoke.Kernel32.StdHandle)"/> and <see cref="M:PInvoke.Kernel32.SetStdHandle(PInvoke.Kernel32.StdHandle,System.IntPtr)"/> methods.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StdHandle.STD_INPUT_HANDLE">
            <summary>
            The standard input device. Initially, this is the console input buffer, CONIN$.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StdHandle.STD_OUTPUT_HANDLE">
            <summary>
            The standard output device. Initially, this is the active console screen buffer, CONOUT$.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.StdHandle.STD_ERROR_HANDLE">
            <summary>
            The standard error device. Initially, this is the active console screen buffer, CONOUT$.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.WINDOW_BUFFER_SIZE_RECORD">
            <summary>
            Describes a change in the size of the screen buffer in a console <see cref="T:PInvoke.Kernel32.INPUT_RECORD"/> structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WINDOW_BUFFER_SIZE_RECORD.dwSize">
            <summary>
            A <see cref="T:PInvoke.COORD"/> structure that contains the size of the console screen buffer, in character cell columns and rows.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES">
            <summary>
                Used to specify to <see cref="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)" /> that the number of pipe instances that can be created is
                limited only by the availability of system resources.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.DefaultShutdownLevel">
            <summary>
            All processes start at this shutdown level
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.NMPWAIT_USE_DEFAULT_WAIT">
            <summary>The time-out interval is the default value specified by the server process in the
                <see cref="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)" /> function.
                <para>This constant is a special value for named pipes timeouts.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.NMPWAIT_WAIT_FOREVER">
            <summary>The function does not return until an instance of the named pipe is available.
                <para>This constant is a special value for named pipes timeouts.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.NMPWAIT_NOWAIT">
            <summary>Does not wait for the named pipe. If the named pipe is not available, the function returns an error.
                <para>This constant is a special value for named pipes timeouts.</para>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.EnumResNameProc">
            <summary>
                An application-defined callback function used with the EnumResourceNames and EnumResourceNamesEx functions. It
                receives the type and name of a resource. The ENUMRESNAMEPROC type defines a pointer to this callback function.
                EnumResNameProc is a placeholder for the application-defined function name.
            </summary>
            <param name="hModule">
                A handle to the module whose executable file contains the resources that are being enumerated.
                <para>
                    If this parameter is <see langword="null" />, the function enumerates the resource names in the
                    module used to create the current process.
                </para>
            </param>
            <param name="lpszType">
                The type of resource for which the name is being enumerated. Alternately, rather than a pointer,
                this parameter can be <see cref="M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)" />(ID), where ID is an integer value representing a predefined
                resource type.
            </param>
            <param name="lpszName">
                The name of a resource of the type being enumerated. Alternately, rather than a pointer, this
                parameter can be <see cref="M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)" />(ID), where ID is the integer identifier of the resource. For more
                information, see the Remarks section below.
            </param>
            <param name="lParam">
                An application-defined parameter passed to the <see cref="M:PInvoke.Kernel32.EnumResourceNames(PInvoke.Kernel32.SafeLibraryHandle,System.Char*,PInvoke.Kernel32.EnumResNameProc,System.IntPtr)" /> or
                EnumResourceNamesEx function. This parameter can be used in error checking.
            </param>
            <returns>Returns TRUE to continue enumeration or FALSE to stop enumeration.</returns>
        </member>
        <member name="T:PInvoke.Kernel32.HandlerRoutine">
            <summary>
            Callback function used with the <see cref="M:PInvoke.Kernel32.SetConsoleCtrlHandler(PInvoke.Kernel32.HandlerRoutine,System.Boolean)"/> function.
            A console process uses this function to handle control signals received by the process.
            When the signal is received, the system creates a new thread in the process to execute the function.
            </summary>
            <param name="dwCtrlType">The type of control signal received by the handler. This parameter can be one of the following values.</param>
            <returns>If the function handles the control signal, it should return TRUE. If it returns FALSE, the next handler function in the list of handlers for this process is used.</returns>
            <remarks>
            <para>
            Because the system creates a new thread in the process to execute the handler function,
            it is possible that the handler function will be terminated by another thread in the process.
            Be sure to synchronize threads in the process with the thread for the handler function.
            Each console process has its own list of <see cref="T:PInvoke.Kernel32.HandlerRoutine"/> callbacks.
            Initially, this list contains only a default handler function that calls <see cref="M:PInvoke.Kernel32.ExitProcess(System.Int32)"/>.
            A console process adds or removes additional handler functions by calling the <see cref="M:PInvoke.Kernel32.SetConsoleCtrlHandler(PInvoke.Kernel32.HandlerRoutine,System.Boolean)"/> function,
            which does not affect the list of handler functions for other processes. When a console process receives any of the control signals,
            its handler functions are called on a last-registered, first-called basis until one of the handlers returns TRUE.
            If none of the handlers returns TRUE, the default handler is called.
            </para>
            <para>
            The <see cref="F:PInvoke.Kernel32.ControlType.CTRL_CLOSE_EVENT"/>, <see cref="F:PInvoke.Kernel32.ControlType.CTRL_LOGOFF_EVENT"/>, and <see cref="F:PInvoke.Kernel32.ControlType.CTRL_SHUTDOWN_EVENT"/> signals give the process
            an opportunity to clean up before termination. A <see cref="T:PInvoke.Kernel32.HandlerRoutine"/> can perform any necessary cleanup, then take one of the following actions:
            </para>
            <list>
            <item>Call the <see cref="M:PInvoke.Kernel32.ExitProcess(System.Int32)"/> function to terminate the process.</item>
            <item>Return FALSE. If none of the registered handler functions returns TRUE, the default handler terminates the process.</item>
            <item>Return TRUE. In this case, no other handler functions are called and the system terminates the process.</item>
            </list>
            <para>
            A process can use the <see cref="M:PInvoke.Kernel32.SetProcessShutdownParameters(System.Int32,PInvoke.Kernel32.ProcessShutdownFlags)"/> function to prevent the system from displaying a dialog box to the user during logoff or shutdown.
            In this case, the system terminates the process when <see cref="T:PInvoke.Kernel32.HandlerRoutine"/> returns TRUE or when the time-out period elapses.
            When a console application is run as a service, it receives a modified default console control handler.
            This modified handler does not call <see cref="M:PInvoke.Kernel32.ExitProcess(System.Int32)"/> when processing the <see cref="F:PInvoke.Kernel32.ControlType.CTRL_LOGOFF_EVENT"/> and <see cref="F:PInvoke.Kernel32.ControlType.CTRL_SHUTDOWN_EVENT"/> signals.
            This allows the service to continue running after the user logs off.
            If the service installs its own console control handler, this handler is called before the default handler.
            If the installed handler calls <see cref="M:PInvoke.Kernel32.ExitProcess(System.Int32)"/> when processing the <see cref="F:PInvoke.Kernel32.ControlType.CTRL_LOGOFF_EVENT"/> signal, the service exits when the user logs off.
            </para>
            <para>
            Note that a third-party library or DLL can install a console control handler for your application.
            If it does, this handler overrides the default handler, and can cause the application to exit when the user logs off.
            </para>
            </remarks>
        </member>
        <member name="T:PInvoke.Kernel32.EnumResLangProc">
            <summary>
                An application-defined callback function used with the EnumResourceLanguages and EnumResourceLanguagesEx
                functions. It receives the type, name, and language of a resource item. The ENUMRESLANGPROC type defines
                a pointer to this callback function. EnumResLangProc is a placeholder for the application-defined
                function name.
            </summary>
            <param name="hModule">
                A handle to the module whose executable file contains the resources for which the languages are being
                enumerated.
                <para>
                    If this parameter is NULL, the function enumerates the resource languages in the module used to
                    create the current process.
                </para>
            </param>
            <param name="lpType">
                The type of resource for which the language is being enumerated. Alternately, rather than a pointer,
                this parameter can be <see cref="M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)" />(ID), where ID is an integer value representing a predefined
                resource type. For standard resource types, see Resource Types. For more information, see the Remarks
                section below.
            </param>
            <param name="lpName">
                The name of the resource for which the language is being enumerated. Alternately, rather than a
                pointer, this parameter can be <see cref="M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)" />(ID), where ID is the integer identifier
                of the resource. For more information, see the Remarks section below.
            </param>
            <param name="wLanguage">
                The language identifier for the resource for which the language is being enumerated. The
                EnumResourceLanguages or EnumResourceLanguagesEx function provides this value. For a list of the primary
                language identifiers and sublanguage identifiers that constitute a language identifier, see
                <see cref="M:PInvoke.Kernel32.MAKELANGID(System.UInt16,System.UInt16)" />.
            </param>
            <param name="lParam">
                The application-defined parameter passed to the <see cref="M:PInvoke.Kernel32.EnumResourceLanguages(PInvoke.Kernel32.SafeLibraryHandle,System.Char*,System.Char*,PInvoke.Kernel32.EnumResLangProc,System.Void*)"/> EnumResourceLanguages
                or EnumResourceLanguagesEx function. This parameter can be used in error checking.
            </param>
            <returns>Returns TRUE to continue enumeration or FALSE to stop enumeration.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.Beep(System.Int32,System.Int32)">
            <summary>
            Generates simple tones on the speaker. The function is synchronous; it performs an alertable wait and does not return control to its caller until the sound finishes.
            </summary>
            <param name="frequency">The frequency of the sound, in hertz. This parameter must be in the range 37 through 32,767 (0x25 through 0x7FFF).</param>
            <param name="duration">The duration of the sound, in milliseconds.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.TerminateProcess(System.IntPtr,System.Int32)">
            <summary>
            Terminates the specified process and all of its threads.
            </summary>
            <param name="hProcess">
            A handle to the process to be terminated.
            The handle must have the PROCESS_TERMINATE access right
            </param>
            <param name="uExitCode">
            The exit code to be used by the process and threads terminated as a result of this call.
            Use the <see cref="M:PInvoke.Kernel32.GetExitCodeProcess(System.IntPtr,System.Int32@)"/> function to retrieve a process's exit value.
            Use the <see cref="M:PInvoke.Kernel32.GetExitCodeThread(System.IntPtr,System.Int32@)"/> function to retrieve a thread's exit value.
            </param>
            <returns>If the function succeeds, the return value is true, else the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.</returns>
            <remarks>
            <para>
            The TerminateProcess function is used to unconditionally cause a process to exit.
            The state of global data maintained by dynamic-link libraries (DLLs) may be compromised if TerminateProcess is used rather than <see cref="M:PInvoke.Kernel32.ExitProcess(System.Int32)"/>.
            </para>
            <para>
            This function stops execution of all threads within the process and requests cancellation of all pending I/O.
            The terminated process cannot exit until all pending I/O has been completed or canceled.When a process terminates,
            its kernel object is not destroyed until all processes that have open handles to the process have released those handles.
            TerminateProcess is asynchronous; it initiates termination and returns immediately.
            If you need to be sure the process has terminated, call the <see cref="M:PInvoke.Kernel32.WaitForSingleObject(System.Runtime.InteropServices.SafeHandle,System.Int32)"/> function with a handle to the process.
            A process cannot prevent itself from being terminated.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.TerminateThread(System.IntPtr,System.Int32)">
            <summary>
            Terminates a thread.
            </summary>
            <param name="hThread">A handle to the thread to be terminated. The handle must have the THREAD_TERMINATE access right.</param>
            <param name="dwExitCode">The exit code for the thread. Use the <see cref="M:PInvoke.Kernel32.GetExitCodeThread(System.IntPtr,System.Int32@)"/> function to retrieve a thread's exit value.</param>
            <returns>If the function succeeds, the return value is true, else the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.</returns>
            <remarks>
            TerminateThread is used to cause a thread to exit.
            When this occurs, the target thread has no chance to execute any user-mode code.
            DLLs attached to the thread are not notified that the thread is terminating.
            The system frees the thread's initial stack.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.ExitProcess(System.Int32)">
            <summary>
            Ends the calling process and all its threads.
            </summary>
            <param name="uExitCode">The exit code for the process and all threads.</param>
            <remarks>
            <para>
            Use the <see cref="M:PInvoke.Kernel32.GetExitCodeProcess(System.IntPtr,System.Int32@)"/> function to retrieve the process's exit value. Use the <see cref="M:PInvoke.Kernel32.GetExitCodeThread(System.IntPtr,System.Int32@)"/> function to retrieve a thread's exit value.
            Exiting a process causes the following:
            </para>
            <list>
            <item>All of the threads in the process, except the calling thread, terminate their execution without receiving a DLL_THREAD_DETACH notification.</item>
            <item>The states of all of the threads terminated in step 1 become signaled.</item>
            <item>The entry-point functions of all loaded dynamic-link libraries (DLLs) are called with DLL_PROCESS_DETACH.</item>
            <item>After all attached DLLs have executed any process termination code, the ExitProcess function terminates the current process, including the calling thread.</item>
            <item>The state of the calling thread becomes signaled.</item>
            <item>All of the object handles opened by the process are closed.</item>
            <item>The termination status of the process changes from STILL_ACTIVE to the exit value of the process.</item>
            <item>The state of the process object becomes signaled, satisfying any threads that had been waiting for the process to terminate.</item>
            </list>
            <para>
            If one of the terminated threads in the process holds a lock and the DLL detach code in one of the loaded DLLs attempts to acquire the same lock,
            then calling ExitProcess results in a deadlock. In contrast, if a process terminates by calling <see cref="M:PInvoke.Kernel32.TerminateProcess(System.IntPtr,System.Int32)"/>,
            the DLLs that the process is attached to are not notified of the process termination.
            Therefore, if you do not know the state of all threads in your process, it is better to call <see cref="M:PInvoke.Kernel32.TerminateProcess(System.IntPtr,System.Int32)"/> than <see cref="M:PInvoke.Kernel32.ExitProcess(System.Int32)"/>.
            Note that returning from the main function of an application results in a call to <see cref="M:PInvoke.Kernel32.ExitProcess(System.Int32)"/>.
            </para>
            <para>
            Calling ExitProcess in a DLL can lead to unexpected application or system errors.
            Be sure to call <see cref="M:PInvoke.Kernel32.ExitProcess(System.Int32)"/> from a DLL only if you know which applications or system components
            will load the DLL and that it is safe to call <see cref="M:PInvoke.Kernel32.ExitProcess(System.Int32)"/> in this context.
            Exiting a process does not cause child processes to be terminated.
            Exiting a process does not necessarily remove the process object from the operating system.
            A process object is deleted when the last handle to the process is closed.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.ExitThread(System.Int32)">
            <summary>
            Ends the calling thread.
            </summary>
            <param name="dwExitCode">The exit code for the thread.</param>
            <remarks>
            <para>
            ExitThread is the preferred method of exiting a thread in C code.
            However, in C++ code, the thread is exited before any destructors can be called or any other automatic cleanup can be performed.
            Therefore, in C++ code, you should return from your thread function.
            When this function is called (either explicitly or by returning from a thread procedure), the current thread's stack is deallocated,
            all pending I/O initiated by the thread is canceled, and the thread terminates.
            The entry-point function of all attached dynamic-link libraries (DLLs) is invoked with a value indicating that the thread is detaching from the DLL.
            If the thread is the last thread in the process when this function is called, the thread's process is also terminated.
            The state of the thread object becomes signaled, releasing any other threads that had been waiting for the thread to terminate.
            The thread's termination status changes from STILL_ACTIVE to the value of the dwExitCode parameter.
            </para>
            <para>
            Terminating a thread does not necessarily remove the thread object from the operating system.
            A thread object is deleted when the last handle to the thread is closed.
            The <see cref="M:PInvoke.Kernel32.ExitProcess(System.Int32)"/>, ExitThread, CreateThread"/>, CreateRemoteThread functions,
            and a process that is starting (as the result of a CreateProcess call) are serialized between each other within a process.
            Only one of these events can happen in an address space at a time.
            This means the following restrictions hold:
            </para>
            <list>
            <item>During process startup and DLL initialization routines, new threads can be created, but they do not begin execution until DLL initialization is done for the process.</item>
            <item>Only one thread in a process can be in a DLL initialization or detach routine at a time.</item>
            <item>ExitProcess does not return until no threads are in their DLL initialization or detach routines.</item>
            </list>
            <para>
            A thread in an executable that is linked to the static C run-time library(CRT) should use _beginthread and _endthread for thread management
            rather than CreateThread and ExitThread.
            Failure to do so results in small memory leaks when the thread calls ExitThread.
            Another work around is to link the executable to the CRT in a DLL instead of the static CRT.
            Note that this memory leak only occurs from a DLL if the DLL is linked to the static CRT and a thread calls the DisableThreadLibraryCalls function.
            Otherwise, it is safe to call CreateThread and ExitThread from a thread in a DLL that links to the static CRT.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetExitCodeThread(System.IntPtr,System.Int32@)">
            <summary>
            Retrieves the termination status of the specified thread.
            </summary>
            <param name="hThread">
            A handle to the thread. The handle must have the THREAD_QUERY_INFORMATION or THREAD_QUERY_LIMITED_INFORMATION access right.
            Windows Server 2003 and Windows XP:  The handle must have the THREAD_QUERY_INFORMATION access right.
            </param>
            <param name="lpExitCode">A pointer to a variable to receive the thread termination status. For more information, see Remarks.</param>
            <returns>If the function is succeeds, the return value is true, else the return value is zero.  To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.</returns>
            <remarks>
            <para>
            This function returns immediately. If the specified thread has not terminated and the function succeeds, the status returned is STILL_ACTIVE.
            If the thread has terminated and the function succeeds, the status returned is one of the following values:
            </para>
            <list>
            <item>The exit value specified in the <see cref="M:PInvoke.Kernel32.ExitThread(System.Int32)"/> or <see cref="M:PInvoke.Kernel32.TerminateThread(System.IntPtr,System.Int32)"/> function.</item>
            <item>The return value from the thread function.</item>
            <item>he exit value of the thread's process.</item>
            </list>
            <para>
            Important: The GetExitCodeThread function returns a valid error code defined by the application only after the thread terminates.
            Therefore, an application should not use STILL_ACTIVE (259) as an error code.
            If a thread returns STILL_ACTIVE (259) as an error code, applications that test for this value could interpret it to mean that the thread is still running
            and continue to test for the completion of the thread after the thread has terminated, which could put the application into an infinite loop.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetExitCodeProcess(System.IntPtr,System.Int32@)">
            <summary>
            Retrieves the termination status of the specified process.
            </summary>
            <param name="hProcess">
            A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right.
            Windows Server 2003 and Windows XP:  The handle must have the PROCESS_QUERY_INFORMATION access right.
            </param>
            <param name="lpExitCode">A pointer to a variable to receive the process termination status. For more information, see Remarks.</param>
            <returns>If the function is succeeds, the return value is true, else the return value is zero.  To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.</returns>
            <remarks>
            <para>
            This function returns immediately.
            If the process has not terminated and the function succeeds, the status returned is STILL_ACTIVE.
            If the process has terminated and the function succeeds, the status returned is one of the following values:
            </para>
            <list>
            <item>The exit value specified in the <see cref="M:PInvoke.Kernel32.ExitProcess(System.Int32)"/> or <see cref="M:PInvoke.Kernel32.TerminateProcess(System.IntPtr,System.Int32)"/> function.</item>
            <item>The return value from the main or WinMain function of the process.</item>
            <item>The exception value for an unhandled exception that caused the process to terminate.</item>
            </list>
            <para>
            Important: The GetExitCodeProcess function returns a valid error code defined by the application only after the thread terminates.
            Therefore, an application should not use STILL_ACTIVE (259) as an error code.
            If a thread returns STILL_ACTIVE (259) as an error code, applications that test for this value could interpret it to mean that the thread is still running
            and continue to test for the completion of the thread after the thread has terminated, which could put the application into an infinite loop.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.SetProcessShutdownParameters(System.Int32,PInvoke.Kernel32.ProcessShutdownFlags)">
            <summary>
            Sets shutdown parameters for the currently calling process. This function sets a shutdown order for a process relative to the other processes in the system.
            </summary>
            <param name="dwLevel">
            The shutdown priority for a process relative to other processes in the system. The system shuts down processes from high dwLevel values to low.
            The highest and lowest shutdown priorities are reserved for system components.
            This parameter must be in the following range of values:
            <list>
            <item>0x000-0x0FF: System reserved last shutdown range.</item>
            <item>100-1FF: Application reserved last shutdown range.</item>
            <item>200-2FF: Application reserved "in between" shutdown range.</item>
            <item>0x280: All processes start at this shutdown level.</item>         /// <item>300-3FF: Application reserved first shutdown range.</item>
            <item>400-4FF: System reserved first shutdown range.</item>
            </list>
            </param>
            <param name="dwFlags">Flag to indicate if a retry box should appear for the user when the process terminate.</param>
            <returns>If the function is succeeds, the return value is true, else the return value is zero.  To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.</returns>
            <remarks>
            Applications running in the system security context do not get shut down by the operating system.
            They get notified of shutdown or logoff through the callback function installable via <see cref="M:PInvoke.Kernel32.SetConsoleCtrlHandler(PInvoke.Kernel32.HandlerRoutine,System.Boolean)"/>.
            They also get notified in the order specified by the dwLevel parameter.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.CreateProcess(System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)">
            <summary>
            Creates a new process and its primary thread. The new process runs in the security context of the calling process.
            If the calling process is impersonating another user, the new process uses the token for the calling process, not the impersonation token. To run the new process in the security context of the user represented by the impersonation token, use the <see cref="M:PInvoke.Kernel32.CreateProcessAsUser(System.IntPtr,System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)"/> or CreateProcessWithLogonW function.
            </summary>
            <param name="lpApplicationName">
            The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.
            The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.
            The lpApplicationName parameter can be NULL. In that case, the module name must be the first white space–delimited token in the lpCommandLine string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways.
            See MSDN docs for more information.
            </param>
            <param name="lpCommandLine">
            The command line to be executed. The maximum length of this string is 32K characters. If lpApplicationName is NULL, the module name portion of lpCommandLine is limited to MAX_PATH characters.
            The Unicode version of this function, CreateProcessAsUserW, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a const variable or a literal string). If this parameter is a constant string, the function may cause an access violation.
            The lpCommandLine parameter can be NULL. In that case, the function uses the string pointed to by lpApplicationName as the command line.
            If both lpApplicationName and lpCommandLine are non-NULL, *lpApplicationName specifies the module to execute, and *lpCommandLine specifies the command line. The new process can use GetCommandLine to retrieve the entire command line. Console processes written in C can use the argc and argv arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.
            If lpApplicationName is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the lpApplicationName parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended.
            See MSDN docs for more information.
            </param>
            <param name="lpProcessAttributes">
            A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If lpProcessAttributes is NULL or lpSecurityDescriptor is NULL, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.
            </param>
            <param name="lpThreadAttributes">
            A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If lpThreadAttributes is NULL or lpSecurityDescriptor is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller.
            </param>
            <param name="bInheritHandles">
            If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
            Terminal Services:  You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.
            </param>
            <param name="dwCreationFlags">
            The flags that control the priority class and the creation of the process. For a list of values, see Process Creation Flags.
            This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see GetPriorityClass. If none of the priority class flags is specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default priority class of the calling process.
            </param>
            <param name="lpEnvironment">
            A pointer to an environment block for the new process. If this parameter is NULL, the new process uses the environment of the calling process.
            An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:
            name=value\0
            Because the equal sign is used as a separator, it must not be used in the name of an environment variable.
            An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, be sure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT. If this parameter is NULL and the environment block of the parent process contains Unicode characters, you must also ensure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT.
            The ANSI version of this function, CreateProcessAsUserA fails if the total size of the environment block for the process exceeds 32,767 characters.
            Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.
            See MSDN docs for more information.
            </param>
            <param name="lpCurrentDirectory">
            The full path to the current directory for the process. The string can also specify a UNC path.
            If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)
            </param>
            <param name="lpStartupInfo">
            A pointer to a <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref="T:PInvoke.Kernel32.STARTUPINFOEX"/> structure.
            The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the lpDesktop member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in Process Connection to a Window Station.
            To set extended attributes, use a <see cref="T:PInvoke.Kernel32.STARTUPINFOEX"/> structure and specify <see cref="F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT"/> in the <paramref name="dwCreationFlags"/> parameter.
            Handles in <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref="T:PInvoke.Kernel32.STARTUPINFOEX"/> must be closed with CloseHandle when they are no longer needed.
            Important  The caller is responsible for ensuring that the standard handle fields in <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the dwFlags member specifies <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>. Incorrect values can cause the child process to misbehave or crash. Use the Application Verifier runtime verification tool to detect invalid handles.
            </param>
            <param name="lpProcessInformation">
            A pointer to a <see cref="T:PInvoke.Kernel32.PROCESS_INFORMATION"/> structure that receives identification information about the new process.
            Handles in <see cref="T:PInvoke.Kernel32.PROCESS_INFORMATION"/> must be closed with CloseHandle when they are no longer needed.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateProcessAsUser(System.IntPtr,System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)">
            <summary>
            Creates a new process and its primary thread. The new process runs in the security context of the user represented by the specified token.
            Typically, the process that calls the CreateProcessAsUser function must have the SE_INCREASE_QUOTA_NAME privilege and may require the SE_ASSIGNPRIMARYTOKEN_NAME privilege if the token is not assignable. If this function fails with ERROR_PRIVILEGE_NOT_HELD (1314), use the CreateProcessWithLogonW function instead. CreateProcessWithLogonW requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use CreateProcessWithLogonW to create a process with alternate credentials.
            </summary>
            <param name="hToken">
            A handle to the primary token that represents a user. The handle must have the TOKEN_QUERY, TOKEN_DUPLICATE, and TOKEN_ASSIGN_PRIMARY access rights. For more information, see Access Rights for Access-Token Objects. The user represented by the token must have read and execute access to the application specified by the <paramref name="lpApplicationName"/> or the <paramref name="lpCommandLine"/> parameter.
            To get a primary token that represents the specified user, call the LogonUser function. Alternatively, you can call the DuplicateTokenEx function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.
            If hToken is a restricted version of the caller's primary token, the SE_ASSIGNPRIMARYTOKEN_NAME privilege is not required. If the necessary privileges are not already enabled, CreateProcessAsUser enables them for the duration of the call. For more information, see Running with Special Privileges.
            Terminal Services:  The process is run in the session specified in the token. By default, this is the same session that called LogonUser. To change the session, use the SetTokenInformation function.
            </param>
            <param name="lpApplicationName">
            The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.
            The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.
            The lpApplicationName parameter can be NULL. In that case, the module name must be the first white space–delimited token in the lpCommandLine string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways.
            See MSDN docs for more information.
            </param>
            <param name="lpCommandLine">
            The command line to be executed. The maximum length of this string is 32K characters. If lpApplicationName is NULL, the module name portion of lpCommandLine is limited to MAX_PATH characters.
            The Unicode version of this function, CreateProcessAsUserW, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a const variable or a literal string). If this parameter is a constant string, the function may cause an access violation.
            The lpCommandLine parameter can be NULL. In that case, the function uses the string pointed to by lpApplicationName as the command line.
            If both lpApplicationName and lpCommandLine are non-NULL, *lpApplicationName specifies the module to execute, and *lpCommandLine specifies the command line. The new process can use GetCommandLine to retrieve the entire command line. Console processes written in C can use the argc and argv arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.
            If lpApplicationName is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the lpApplicationName parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended.
            See MSDN docs for more information.
            </param>
            <param name="lpProcessAttributes">
            A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If lpProcessAttributes is NULL or lpSecurityDescriptor is NULL, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.
            </param>
            <param name="lpThreadAttributes">
            A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If lpThreadAttributes is NULL or lpSecurityDescriptor is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller.
            </param>
            <param name="bInheritHandles">
            If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
            Terminal Services:  You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.
            </param>
            <param name="dwCreationFlags">
            The flags that control the priority class and the creation of the process. For a list of values, see Process Creation Flags.
            This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see GetPriorityClass. If none of the priority class flags is specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default priority class of the calling process.
            </param>
            <param name="lpEnvironment">
            A pointer to an environment block for the new process. If this parameter is NULL, the new process uses the environment of the calling process.
            An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:
            name=value\0
            Because the equal sign is used as a separator, it must not be used in the name of an environment variable.
            An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, be sure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT. If this parameter is NULL and the environment block of the parent process contains Unicode characters, you must also ensure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT.
            The ANSI version of this function, CreateProcessAsUserA fails if the total size of the environment block for the process exceeds 32,767 characters.
            Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.
            See MSDN docs for more information.
            </param>
            <param name="lpCurrentDirectory">
            The full path to the current directory for the process. The string can also specify a UNC path.
            If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)
            </param>
            <param name="lpStartupInfo">
            A pointer to a <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref="T:PInvoke.Kernel32.STARTUPINFOEX"/> structure.
            The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the lpDesktop member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in Process Connection to a Window Station.
            To set extended attributes, use a <see cref="T:PInvoke.Kernel32.STARTUPINFOEX"/> structure and specify <see cref="F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT"/> in the <paramref name="dwCreationFlags"/> parameter.
            Handles in <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref="T:PInvoke.Kernel32.STARTUPINFOEX"/> must be closed with CloseHandle when they are no longer needed.
            Important  The caller is responsible for ensuring that the standard handle fields in <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the dwFlags member specifies <see cref="F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>. Incorrect values can cause the child process to misbehave or crash. Use the Application Verifier runtime verification tool to detect invalid handles.
            </param>
            <param name="lpProcessInformation">
            A pointer to a <see cref="T:PInvoke.Kernel32.PROCESS_INFORMATION"/> structure that receives identification information about the new process.
            Handles in <see cref="T:PInvoke.Kernel32.PROCESS_INFORMATION"/> must be closed with CloseHandle when they are no longer needed.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetStartupInfo(PInvoke.Kernel32.STARTUPINFO*)">
            <summary>
            Retrieves the contents of the <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> structure that was specified when the calling process was created.
            </summary>
            <param name="lpStartupInfo">
            A pointer to a <see cref="T:PInvoke.Kernel32.STARTUPINFO"/> structure that receives the startup information.
            </param>
            <remarks>
            This function does not return a value, and does not fail.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.InitializeProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*,System.Int32,System.UInt32,System.IntPtr@)">
            <summary>
            Initializes the specified list of attributes for process and thread creation.
            </summary>
            <param name="lpAttributeList">
            The attribute list. This parameter can be NULL to determine the buffer size required to support the specified number of attributes.
            </param>
            <param name="dwAttributeCount">
            The count of attributes to be added to the list.
            </param>
            <param name="dwFlags">
            This parameter is reserved and must be zero.
            </param>
            <param name="lpSize">
            If lpAttributeList is not NULL, this parameter specifies the size in bytes of the lpAttributeList buffer on input. On output, this parameter receives the size in bytes of the initialized attribute list.
            If lpAttributeList is NULL, this parameter receives the required buffer size in bytes.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            First, call this function with the <paramref name="dwAttributeCount "/> parameter set to the maximum number of attributes you will be using and the lpAttributeList to NULL. The function returns the required buffer size in bytes in the lpSize parameter. Allocate enough space for the data in the lpAttributeList buffer and call the function again to initialize the buffer.
            To add attributes to the list, call the <see cref="M:PInvoke.Kernel32.UpdateProcThreadAttribute(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*,System.UInt32,System.UInt32@,System.Void*,System.IntPtr,System.IntPtr@,System.IntPtr@)"/> function. To specify these attributes when creating a process, specify <see cref="F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT"/> in the dwCreationFlag parameter and a <see cref="T:PInvoke.Kernel32.STARTUPINFOEX"/> structure in the lpStartupInfo parameter. Note that you can specify the same <see cref="T:PInvoke.Kernel32.STARTUPINFOEX"/> structure to multiple child processes.
            When you have finished using the list, call the <see cref="M:PInvoke.Kernel32.DeleteProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*)"/> function.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.UpdateProcThreadAttribute(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*,System.UInt32,System.UInt32@,System.Void*,System.IntPtr,System.IntPtr@,System.IntPtr@)">
            <summary>
            Updates the specified attribute in a list of attributes for process and thread creation.
            </summary>
            <param name="lpAttributeList">
            A pointer to an attribute list created by the <see cref="M:PInvoke.Kernel32.InitializeProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*,System.Int32,System.UInt32,System.IntPtr@)"/> function.
            </param>
            <param name="dwFlags">
            This parameter is reserved and must be zero.
            </param>
            <param name="Attribute">
            The attribute key to update in the attribute list.
            </param>
            <param name="lpValue">
            A pointer to the attribute value. This value should persist until the attribute is destroyed using the <see cref="M:PInvoke.Kernel32.DeleteProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*)"/> function.
            </param>
            <param name="cbSize">
            The size of the attribute value specified by the <paramref name="lpValue"/> parameter.
            </param>
            <param name="lpPreviousValue">
            This parameter is reserved and must be NULL.
            </param>
            <param name="lpReturnSize">This parameter is reserved and must be NULL.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.DeleteProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*)">
            <summary>
            Deletes the specified list of attributes for process and thread creation.
            </summary>
            <param name="lpAttributeList">
            The attribute list. This list is created by the <see cref="M:PInvoke.Kernel32.InitializeProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*,System.Int32,System.UInt32,System.IntPtr@)"/> function.
            </param>
        </member>
        <member name="M:PInvoke.Kernel32.AllocConsole">
            <summary>
            Allocates a new console for the calling process.
            </summary>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FreeConsole">
            <summary>
            Detaches the calling process from its console.
            </summary>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.AttachConsole(System.Int32)">
            <summary>
            Attaches the calling process to the console of the specified process.
            </summary>
            <param name="dwProcessId">
            The identifier of the process whose console is to be used. This parameter can be one of the following values.
            pid: Use the console of the specified process.
            -1: Use the console of the parent of the current process.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Creates or opens a file or I/O device. The most commonly used I/O devices are as follows: file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe. The function returns a handle that can be used to access the file or device for various types of I/O depending on the file or device and the flags and attributes specified.
            To perform this operation as a transacted operation, which results in a handle that can be used for transacted I/O, use the CreateFileTransacted function.
            </summary>
            <param name="filename">
            The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes (\) in this name.
            In the ANSI version of this function, the name is limited to <see cref="F:PInvoke.Kernel32.MAX_PATH"/> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming Files, Paths, and Namespaces.
            For information on special device names, see Defining an MS-DOS Device Name.
            To create a file stream, specify the name of the file, a colon, and then the name of the stream.For more information, see File Streams.
            </param>
            <param name="access">
            The requested access to the file or device, which can be summarized as read, write, both or neither zero).
            The most commonly used values are <see cref="F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/>, <see cref="F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_WRITE"/>, or both(<see cref="F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/> | <see cref="F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_WRITE"/>). For more information, see Generic Access Rights, File Security and Access Rights, File Access Rights Constants, and ACCESS_MASK.
            If this parameter is zero, the application can query certain metadata such as file, directory, or device attributes without accessing that file or device, even if <see cref="F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/> access would have been denied.
            You cannot request an access mode that conflicts with the sharing mode that is specified by the dwShareMode parameter in an open request that already has an open handle.
            For more information, see the Remarks section of this topic and Creating and Opening Files.
            Common specific rights are defined in <seealso cref="T:PInvoke.Kernel32.FileAccess"/>.
            </param>
            <param name="share">
            The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none (refer to the following table). Access requests to attributes or extended attributes are not affected by this flag.
            If this parameter is zero and <see cref="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> succeeds, the file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. For more information, see the Remarks section.
            You cannot request a sharing mode that conflicts with the access mode that is specified in an existing request that has an open handle. <see cref="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> would fail and the <see cref="M:PInvoke.Kernel32.GetLastError"/> function would return ERROR_SHARING_VIOLATION.
            To enable a process to share a file or device while another process has the file or device open, use a compatible combination of one or more of the following values. For more information about valid combinations of this parameter with the dwDesiredAccess parameter, see Creating and Opening Files.
            </param>
            <param name="securityAttributes">
            A pointer to a SECURITY_ATTRIBUTES structure that contains two separate but related data members: an optional security descriptor, and a Boolean value that determines whether the returned handle can be inherited by child processes.
            This parameter can be NULL.
            If this parameter is NULL, the handle returned by CreateFile cannot be inherited by any child processes the application may create and the file or device associated with the returned handle gets a default security descriptor.
            The <see cref="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a <see cref="T:PInvoke.Kernel32.SECURITY_DESCRIPTOR"/> for a file or device. If this member is NULL, the file or device associated with the returned handle is assigned a default security descriptor.
            CreateFile ignores the <see cref="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member when opening an existing file or device, but continues to use the <see cref="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.bInheritHandle"/> member.
            The <see cref="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.bInheritHandle"/> member of the structure specifies whether the returned handle can be inherited.
            </param>
            <param name="creationDisposition">
            An action to take on a file or device that exists or does not exist.
            For devices other than files, this parameter is usually set to <see cref="F:PInvoke.Kernel32.CreationDisposition.OPEN_EXISTING"/>.
            </param>
            <param name="flagsAndAttributes">
            The file or device attributes and flags, <see cref="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_NORMAL"/> being the most common default value for files.
            This parameter can include any combination of the available file attributes (CreateFileFlags.*Attribute). All other file attributes override <see cref="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_NORMAL"/>.
            This parameter can also contain combinations of flags (CreateFileFlags.*Flag) for control of file or device caching behavior, access modes, and other special-purpose flags. These combine with any CreateFileFlags.*Attribute values.
            This parameter can also contain Security Quality of Service (SQOS) information by specifying the SECURITY_SQOS_PRESENT flag. Additional SQOS-related flags information is presented in the table following the attributes and flags tables.
            Note When CreateFile opens an existing file, it generally combines the file flags with the file attributes of the existing file, and ignores any file attributes supplied as part of dwFlagsAndAttributes. Special cases are detailed in Creating and Opening Files.
            Some of the following file attributes and flags may only apply to files and not necessarily all other types of devices that CreateFile can open.For additional information, see the Remarks section of this topic and Creating and Opening Files.
            For more advanced access to file attributes, see SetFileAttributes. For a complete list of all file attributes with their values and descriptions, see File Attribute Constants.
            </param>
            <param name="templateFile">
            A valid handle to a template file with the <see cref="F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/> access right. The template file supplies file attributes and extended attributes for the file that is being created.
            This parameter can be NULL.
            When opening an existing file, CreateFile ignores this parameter.
            When opening a new encrypted file, the file inherits the discretionary access control list from its parent directory.For additional information, see File Encryption.
            </param>
            <returns>
            If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot.
            If the function fails, the return value is INVALID_HANDLE_VALUE.To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FindFirstFile(System.String,PInvoke.Kernel32.WIN32_FIND_DATA@)">
            <summary>
            Searches a directory for a file or subdirectory with a name that matches a specific name (or partial name if wildcards are used).
            To specify additional attributes to use in a search, use the FindFirstFileEx function.
            To perform this operation as a transacted operation, use the FindFirstFileTransacted function.
            </summary>
            <param name="lpFileName">
            The directory or path, and the file name, which can include wildcard characters, for example, an asterisk (*) or a question mark (?).
            This parameter should not be NULL, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash(\).
            If the string ends with a wildcard, period(.), or directory name, the user must have access permissions to the root and all subdirectories on the path.
            In the ANSI version of this function, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming a File.
            </param>
            <param name="lpFindFileData">A pointer to the WIN32_FIND_DATA structure that receives information about a found file or directory.</param>
            <returns>
            If the function succeeds, the return value is a search handle used in a subsequent call to FindNextFile or FindClose, and the lpFindFileData parameter contains information about the first file or directory found.
            If the function fails or fails to locate files from the search string in the lpFileName parameter, the return value is INVALID_HANDLE_VALUE and the contents of lpFindFileData are indeterminate.To get extended error information, call the <see cref="M:PInvoke.Kernel32.GetLastError"/> function.
            If the function fails because no matching files can be found, the <see cref="M:PInvoke.Kernel32.GetLastError"/> function returns ERROR_FILE_NOT_FOUND.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FindNextFile(PInvoke.Kernel32.SafeFindFilesHandle,PInvoke.Kernel32.WIN32_FIND_DATA@)">
            <summary>
            Continues a file search from a previous call to the <see cref="M:PInvoke.Kernel32.FindFirstFile(System.String,PInvoke.Kernel32.WIN32_FIND_DATA@)"/>, FindFirstFileEx, or FindFirstFileTransacted functions.
            </summary>
            <param name="hFindFile">The search handle returned by a previous call to the FindFirstFile or FindFirstFileEx function.</param>
            <param name="lpFindFileData">A pointer to the WIN32_FIND_DATA structure that receives information about the found file or subdirectory.</param>
            <returns>
            If the function succeeds, the return value is nonzero and the lpFindFileData parameter contains information about the next file or directory found.
            If the function fails, the return value is zero and the contents of lpFindFileData are indeterminate. To get extended error information, call the <see cref="M:PInvoke.Kernel32.GetLastError"/> function.
            If the function fails because no more matching files can be found, the <see cref="M:PInvoke.Kernel32.GetLastError"/> function returns ERROR_NO_MORE_FILES.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)">
            <summary>
            Takes a snapshot of the specified processes, as well as the heaps, modules, and threads used by these
            processes.
            </summary>
            <param name="dwFlags">The portions of the system to be included in the snapshot.</param>
            <param name="th32ProcessID">
            The process identifier of the process to be included in the snapshot. This parameter can be zero to indicate the
            current process. This parameter is used when the <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPHEAPLIST" />,
            <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE" />,
            <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE32" />, or
            <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPALL" /> value is specified. Otherwise, it is ignored and all
            processes are included in the snapshot.
            <para>
            If the specified process is the Idle process or one of the CSRSS processes, this function fails and the last
            error code is <see cref="F:PInvoke.Win32ErrorCode.ERROR_ACCESS_DENIED" /> because their access restrictions prevent user-level
            code from opening them.
            </para>
            <para>
            If the specified process is a 64-bit process and the caller is a 32-bit process, this function fails and the last
            error code is <see cref="F:PInvoke.Win32ErrorCode.ERROR_PARTIAL_COPY" />.
            </para>
            </param>
            <returns>
            If the function succeeds, it returns an open handle to the specified snapshot.
            <para>
            If the function fails, it returns <see cref="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE" />. To get extended error information, call
            <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />. Possible error codes include
            <see cref="F:PInvoke.Win32ErrorCode.ERROR_BAD_LENGTH" />.
            </para>
            </returns>
            <remarks>
            The snapshot taken by this function is examined by the other tool help functions to provide their results.Access to the
            snapshot is read only.The snapshot handle acts as an object handle and is subject to the same rules regarding which
            processes and threads it is valid in.
            <para>
            To enumerate the heap or module states for all processes, specify
            <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPALL" /> and set <paramref name="th32ProcessID" /> to zero.Then, for
            each additional process in the snapshot, call CreateToolhelp32Snapshot again, specifying its process identifier and the
            <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPHEAPLIST" /> or
            <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE" /> value.
            </para>
            <para>
            When taking snapshots that include heaps and modules for a process other than the current process, the
            CreateToolhelp32Snapshot function can fail or return incorrect information for a variety of reasons. For example, if
            the loader data table in the target process is corrupted or not initialized, or if the module list changes during the
            function call as a result of DLLs being loaded or unloaded, the function might fail with
            <see cref="F:PInvoke.Win32ErrorCode.ERROR_BAD_LENGTH" /> or other error code. Ensure that the target process was not started in a
            suspended state, and try calling the function again. If the function fails with
            <see cref="F:PInvoke.Win32ErrorCode.ERROR_BAD_LENGTH" /> when called with
            <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE" /> or
            <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE32" />, call the function again until it succeeds.
            </para>
            <para>
            The <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE" /> and
            <see cref="F:PInvoke.Kernel32.CreateToolhelp32SnapshotFlags.TH32CS_SNAPMODULE32" /> flags do not retrieve handles for modules that were
            loaded with the LOAD_LIBRARY_AS_DATAFILE or similar flags. For more information, see LoadLibraryEx.
            </para>
            <para>To destroy the snapshot, call <see cref="M:System.Runtime.InteropServices.SafeHandle.Dispose" /> on the returned handle.</para>
            <para>
            Note that you can use the
            <see cref="M:PInvoke.Kernel32.QueryFullProcessImageName(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.QueryFullProcessImageNameFlags,System.Char*,System.Int32@)" />
            function to retrieve the full name of an executable image for both 32- and 64-bit processes from a 32-bit process.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.Process32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESSENTRY32*)">
            <summary>Retrieves information about the first process encountered in a system snapshot.</summary>
            <param name="hSnapshot">
            A handle to the snapshot returned from a previous call to the
            <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)" /> function.
            </param>
            <param name="lppe">
            Contains process information such as the name of the executable file, the process identifier, and
            the process identifier of the parent process.
            </param>
            <returns>
            Returns <see langword="true" /> if the first entry of the process list has been copied to the buffer or
            <see langword="false" /> otherwise. The <see cref="F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES" /> error value is returned by
            the <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" /> function if no processes exist or the snapshot does not contain process
            information.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.Process32Next(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESSENTRY32*)">
            <summary>Retrieves information about the next process recorded in a system snapshot.</summary>
            <param name="hSnapshot">
            A handle to the snapshot returned from a previous call to the
            <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)" /> function.
            </param>
            <param name="lppe">A <see cref="T:PInvoke.Kernel32.PROCESSENTRY32" /> structure.</param>
            <returns>
            Returns <see langword="true" /> if the next entry of the process list has been copied to the buffer or
            <see langword="false" /> otherwise. The <see cref="F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES" /> error value is returned by
            the <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" /> function if no processes exist or the snapshot does not contain process
            information.
            </returns>
            <remarks>
            To retrieve information about the first process recorded in a snapshot, use the
            <see cref="M:PInvoke.Kernel32.Process32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESSENTRY32*)" />
            function.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.Module32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.MODULEENTRY32*)">
            <summary>
            Retrieves information about the first module associated with a process.
            </summary>
            <param name="hSnapshot">A handle to the snapshot returned from a previous call to the <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)" /> function.</param>
            <param name="lpme">A <see cref="T:PInvoke.Kernel32.MODULEENTRY32"/> structure.</param>
            <returns>
            Returns <see langword="true" /> if the first entry of the module list has been copied to the buffer or
            <see langword="false" /> otherwise. The <see cref="F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES" /> error value is returned by
            the <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" /> function if no modules exist or the snapshot does not contain module
            information.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.Module32Next(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.MODULEENTRY32*)">
            <summary>Retrieves information about the next process recorded in a system snapshot.</summary>
            <param name="hSnapshot">A handle to the snapshot returned from a previous call to the
            <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)" /> function.</param>
            <param name="lpme">A <see cref="T:PInvoke.Kernel32.MODULEENTRY32"/> structure.</param>
            <returns>Returns <see langword="true" /> if the next entry of the module list has been copied to the buffer or
            <see langword="false" /> otherwise. The <see cref="F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES" /> error value is returned by
            the <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" /> function if no modules exist or the snapshot does not contain module
            information.</returns>
            <remarks>
            To retrieve information about the first module recorded in a snapshot, use the
            <see cref="M:PInvoke.Kernel32.Module32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.MODULEENTRY32*)" />
            function.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetProcessTimes(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.FILETIME@,PInvoke.Kernel32.FILETIME@,PInvoke.Kernel32.FILETIME@,PInvoke.Kernel32.FILETIME@)">
            <summary>
            Retrieves timing information for the specified process.
            </summary>
            <param name="handle">
            A handle to the process whose timing information is sought.
            The handle must have the <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_INFORMATION" /> or
            <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_LIMITED_INFORMATION" /> access right.</param>
            <param name="creation">A pointer to a <see cref="T:PInvoke.Kernel32.FILETIME"/> structure that receives the creation time of the process.</param>
            <param name="exit">A pointer to a <see cref="T:PInvoke.Kernel32.FILETIME"/>  structure that receives the exit time of the process.
            If the process has not exited, the content of this structure is undefined.</param>
            <param name="kernel">A pointer to a <see cref="T:PInvoke.Kernel32.FILETIME"/> structure that receives the amount of time that the process
            has executed in kernel mode.
            The time that each of the threads of the process has executed in kernel mode is determined, and then all of those times
            are summed together to obtain this value.</param>
            <param name="user">A pointer to a <see cref="T:PInvoke.Kernel32.FILETIME"/> structure that receives the amount of time that the process
            has executed in user mode.
            The time that each of the threads of the process has executed in user mode is determined, and then all of those times
            are summed together to obtain this value.
            Note that this value can exceed the amount of real time elapsed (between creation and exit)
            if the process executes across multiple CPU cores.</param>
            <returns>
                If the function succeeds, the return value is a nonzero value.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.QueryFullProcessImageName(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.QueryFullProcessImageNameFlags,System.Char*,System.Int32@)">
            <summary>Retrieves the full name of the executable image for the specified process.</summary>
            <param name="hProcess">
            A handle to the process. This handle must be created with the
            <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_INFORMATION" /> or
            <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_LIMITED_INFORMATION" /> access right.
            </param>
            <param name="dwFlags">One of the <see cref="T:PInvoke.Kernel32.QueryFullProcessImageNameFlags" /> values.</param>
            <param name="lpExeName">The path to the executable image. If the function succeeds, this string is null-terminated.</param>
            <param name="lpdwSize">
            On input, specifies the size of the lpExeName buffer, in characters. On success, receives the
            number of characters written to the buffer, not including the null-terminating character.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            <para>If the function fails, the return value is zero.To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.</para>
            </returns>
            <remarks>Minimum OS: Windows Vista / Windows Server 2008.</remarks>
        </member>
        <member name="M:PInvoke.Kernel32.QueryFullProcessImageName(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.QueryFullProcessImageNameFlags,System.Text.StringBuilder,System.Int32@)">
            <summary>Retrieves the full name of the executable image for the specified process.</summary>
            <param name="hProcess">
            A handle to the process. This handle must be created with the
            <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_INFORMATION" /> or
            <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_LIMITED_INFORMATION" /> access right.
            </param>
            <param name="dwFlags">One of the <see cref="T:PInvoke.Kernel32.QueryFullProcessImageNameFlags" /> values.</param>
            <param name="lpExeName">The path to the executable image. If the function succeeds, this string is null-terminated.</param>
            <param name="lpdwSize">
            On input, specifies the size of the lpExeName buffer, in characters. On success, receives the
            number of characters written to the buffer, not including the null-terminating character.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            <para>If the function fails, the return value is zero.To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.</para>
            </returns>
            <remarks>Minimum OS: Windows Vista / Windows Server 2008.</remarks>
        </member>
        <member name="M:PInvoke.Kernel32.OpenProcess(PInvoke.Kernel32.ACCESS_MASK,System.Boolean,System.Int32)">
            <summary>Opens an existing local process object.</summary>
            <param name="dwDesiredAccess">
            The access to the process object. This access right is checked against the security descriptor for the process. This
            parameter can be one or more of the <see cref="T:PInvoke.Kernel32.ProcessAccess" /> values.
            <para>
            If the caller has enabled the SeDebugPrivilege privilege, the requested access is granted regardless of the
            contents of the security descriptor.
            </para>
            </param>
            <param name="bInheritHandle">
            If this value is <see langword="true" />, processes created by this process will inherit
            the handle. Otherwise, the processes do not inherit this handle.
            </param>
            <param name="dwProcessId">
            The identifier of the local process to be opened.
            <para>
            If the specified process is the System Process(0x00000000), the function fails and the last error code is
            <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_PARAMETER" />.If the specified process is the Idle process or one of the CSRSS
            processes, this function fails and the last error code is <see cref="F:PInvoke.Win32ErrorCode.ERROR_ACCESS_DENIED" /> because
            their access restrictions prevent user-level code from opening them.
            </para>
            <para>
            If you are using <see cref="M:PInvoke.Kernel32.GetCurrentProcessId" /> as an argument to this function, consider using
            <see cref="M:PInvoke.Kernel32.GetCurrentProcess"/> instead of OpenProcess, for improved performance.
            </para>
            </param>
            <returns>If the function succeeds, the return value is an open handle to the specified process.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetOverlappedResult(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.OVERLAPPED*,System.Int32@,System.Boolean)">
            <summary>
            Retrieves the results of an overlapped operation on the specified file, named pipe, or communications device.
            To specify a timeout interval or wait on an alertable thread, use GetOverlappedResultEx.
            </summary>
            <param name="hFile">
            A handle to the file, named pipe, or communications device. This is the same handle that was
            specified when the overlapped operation was started by a call to the ReadFile, WriteFile, ConnectNamedPipe,
            TransactNamedPipe, DeviceIoControl, or WaitCommEvent function.
            </param>
            <param name="lpOverlapped">
            A pointer to an <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure that was specified when the overlapped
            operation was started.
            </param>
            <param name="lpNumberOfBytesTransferred">
            A pointer to a variable that receives the number of bytes that were actually
            transferred by a read or write operation. For a TransactNamedPipe operation, this is the number of bytes that were read
            from the pipe. For a DeviceIoControl operation, this is the number of bytes of output data returned by the device
            driver. For a ConnectNamedPipe or WaitCommEvent operation, this value is undefined.
            </param>
            <param name="bWait">
            If this parameter is TRUE, and the Internal member of the lpOverlapped structure is STATUS_PENDING,
            the function does not return until the operation has been completed. If this parameter is FALSE and the operation is
            still pending, the function returns FALSE and the <see cref="M:PInvoke.Kernel32.GetLastError" /> function returns
            <see cref="F:PInvoke.Win32ErrorCode.ERROR_IO_INCOMPLETE" />.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            <para>
            If the function fails, the return value is zero.To get extended error information, call
            <see cref="M:PInvoke.Kernel32.GetLastError" />.
            </para>
            </returns>
            <remarks>
            The results reported by the GetOverlappedResult function are those of the specified handle's last overlapped operation
            to which the specified <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure was provided, and for which the operation's results were
            pending. A pending operation is indicated when the function that started the operation returns FALSE, and the
            GetLastError function returns <see cref="F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING" />. When an I/O operation is pending, the
            function that started the operation resets the hEvent member of the <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure to the
            nonsignaled state. Then when the pending operation has been completed, the system sets the event object to the signaled
            state.
            <para>
            If the bWait parameter is TRUE, GetOverlappedResult determines whether the pending operation has been completed
            by waiting for the event object to be in the signaled state.
            </para>
            <para>
            If the hEvent member of the <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure is NULL, the system uses the state of the hFile
            handle to signal when the operation has been completed. Use of file, named pipe, or communications-device handles for
            this purpose is discouraged. It is safer to use an event object because of the confusion that can occur when multiple
            simultaneous overlapped operations are performed on the same file, named pipe, or communications device. In this
            situation, there is no way to know which operation caused the object's state to be signaled.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.CancelIo(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Cancels all pending input and output (I/O) operations that are issued by the calling thread for the specified file. The
            function does not cancel I/O operations that other threads issue for a file handle.
            <para>To cancel I/O operations from another thread, use the CancelIoEx function.</para>
            </summary>
            <param name="hFile">
            A handle to the file.
            <para>The function cancels all pending I/O operations for this file handle.</para>
            </param>
            <returns>
            If the function succeeds, the return value is nonzero. The cancel operation for all pending I/O operations issued by
            the calling thread for the specified file handle was successfully requested. The thread can use the
            <see cref="M:PInvoke.Kernel32.GetOverlappedResult(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.OVERLAPPED*,System.Int32@,System.Boolean)" /> function to determine when the I/O operations themselves have been completed.
            <para>
            If the function fails, the return value is zero (0). To get extended error information, call the
            <see cref="M:PInvoke.Kernel32.GetLastError" /> function.
            </para>
            </returns>
            <remarks>
            If there are any pending I/O operations in progress for the specified file handle, and they are issued by the calling
            thread, the CancelIo function cancels them. CancelIo cancels only outstanding I/O on the handle, it does not change the
            state of the handle; this means that you cannot rely on the state of the handle because you cannot know whether the
            operation was completed successfully or canceled.
            <para>
            The I/O operations must be issued as overlapped I/O. If they are not, the I/O operations do not return to allow
            the thread to call the CancelIo function. Calling the CancelIo function with a file handle that is not opened with
            FILE_FLAG_OVERLAPPED does nothing.
            </para>
            <para>
            All I/O operations that are canceled complete with the error
            <see cref="F:PInvoke.Win32ErrorCode.ERROR_OPERATION_ABORTED" />, and all completion notifications for the I/O operations occur
            normally.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.IsWow64Process(PInvoke.Kernel32.SafeObjectHandle,System.Boolean@)">
            <summary>
            Determines whether the specified process is running under WOW64 (x86 emulator that allows 32-bit Windows-based
            applications to run seamlessly on 64-bit Windows)
            </summary>
            <param name="hProcess">
            A handle to the process. The handle must have the <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_INFORMATION" /> or
            <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_LIMITED_INFORMATION" /> access right.
            <para>
            Windows Server 2003 and Windows XP:  The handle must have the
            <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_INFORMATION" /> access right.
            </para>
            </param>
            <param name="Wow64Process">
            A pointer to a value that is set to <see langword="true" /> if the process is running under
            WOW64. If the process is running under 32-bit Windows, the value is set to <see langword="false" />. If the process is
            a 64-bit application running under 64-bit Windows, the value is also set to <see langword="false" />.
            </param>
            <returns>
            If the function succeeds, the return value is a nonzero value.
            <para>
            If the function fails, the return value is zero. To get extended error information, call
            <see cref="M:PInvoke.Kernel32.GetLastError" />.
            </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Int32)">
            <summary>Creates an anonymous pipe, and returns handles to the read and write ends of the pipe.</summary>
            <param name="hReadPipe">A pointer to a variable that receives the read handle for the pipe.</param>
            <param name="hWritePipe">A pointer to a variable that receives the write handle for the pipe.</param>
            <param name="lpPipeAttributes">
                A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES" /> structure that determines whether the returned handle can be
                inherited by child processes. If <paramref name="lpPipeAttributes"/>  is NULL, the handle cannot be inherited.
                <para>
                    The <see cref="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor" /> member of the structure specifies a security
                    descriptor for the new pipe. If <paramref name="lpPipeAttributes"/>  is NULL, the pipe gets a default security descriptor. The ACLs
                    in the default security descriptor for a pipe come from the primary or impersonation token of the creator.
                </para>
            </param>
            <param name="nSize">
                The size of the buffer for the pipe, in bytes. The size is only a suggestion; the system uses the
                value to calculate an appropriate buffering mechanism. If this parameter is zero, the system uses the default
                buffer size.
            </param>
            <returns>
                If the function succeeds, the return value is a nonzero value.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.K32EmptyWorkingSet(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>Removes as many pages as possible from the working set of the specified process.</summary>
            <param name="hProcess">
                A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or
                PROCESS_QUERY_LIMITED_INFORMATION access right and the PROCESS_SET_QUOTA access right.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
            <remarks>
                This function is exported by kernel32.dll only since Windows 7, on previous version of windows it's
                exported by Psapi.dll as "EmptyWorkingSet".
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetConsoleWindow">
            <summary>Retrieves the window handle used by the console associated with the calling process.</summary>
            <returns>
                The return value is a handle to the window used by the console associated with the calling process or
                <see cref="F:System.IntPtr.Zero" /> if there is no such associated console.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LoadLibrary(System.String)">
            <summary>
                Loads the specified module into the address space of the calling process. The specified module may cause other
                modules to be loaded.
                <para>For additional load options, use the LoadLibraryEx function.</para>
            </summary>
            <param name="lpFileName">
                The name of the module. This can be either a library module (a .dll file) or an executable module (an .exe file).
                The name specified is the file name of the module and is not related to the name stored in the library module
                itself, as specified by the LIBRARY keyword in the module-definition (.def) file.
                <para>If the string specifies a full path, the function searches only that path for the module.</para>
                <para>
                    If the string specifies a relative path or a module name without a path, the function uses a standard search
                    strategy to find the module.
                </para>
                <para>
                    If the function cannot find the module, the function fails. When specifying a path, be sure to use
                    backslashes (\), not forward slashes (/).
                </para>
                <para>
                    If the string specifies a module name without a path and the file name extension is omitted, the function
                    appends the default library extension .dll to the module name. To prevent the function from appending .dll to
                    the module name, include a trailing point character (.) in the module name string.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is a handle to the loaded module.
                <para>
                    If the function fails, the return value is an invalid handle. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LoadLibraryEx(System.String,System.IntPtr,PInvoke.Kernel32.LoadLibraryExFlags)">
            <summary>
                Loads the specified module into the address space of the calling process. The specified module may cause other
                modules to be loaded.
            </summary>
            <param name="lpFileName">
                <para>
                    A string that specifies the file name of the module to load. This name is not related to the name stored in a
                    library module itself, as specified by the LIBRARY keyword in the module-definition (.def) file.
                </para>
                <para>
                    The module can be a library module (a .dll file) or an executable module (an .exe file). If the specified
                    module is an executable module, static imports are not loaded; instead, the module is loaded as if
                    <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.DONT_RESOLVE_DLL_REFERENCES" /> was specified. See the
                    <paramref name="dwFlags" /> parameter for more information.
                </para>
                <para>
                    If the string specifies a module name without a path and the file name extension is omitted, the function
                    appends the default library extension .dll to the module name. To prevent the function from appending .dll to
                    the module name, include a trailing point character (.) in the module name string.
                </para>
                <para>
                    If the string specifies a fully qualified path, the function searches only that path for the module. When
                    specifying a path, be sure to use backslashes (\), not forward slashes (/). For more information about paths,
                    see Naming Files, Paths, and Namespaces.
                </para>
                <para>
                    If the string specifies a module name without a path and more than one loaded module has the same base name
                    and extension, the function returns a handle to the module that was loaded first.
                </para>
                <para>
                    If the string specifies a module name without a path and a module of the same name is not already loaded, or
                    if the string specifies a module name with a relative path, the function searches for the specified module. The
                    function also searches for modules if loading the specified module causes the system to load other associated
                    modules (that is, if the module has dependencies). The directories that are searched and the order in which
                    they are searched depend on the specified path and the dwFlags parameter.
                </para>
                <para>If the function cannot find the module or one of its dependencies, the function fails.</para>
            </param>
            <param name="hFile">This parameter is reserved for future use. It must be <see langword="null" />.</param>
            <param name="dwFlags">
                The action to be taken when loading the module. If <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.None" /> is
                specified, the behavior of this function is identical to that of the LoadLibrary function.
            </param>
            <returns>
                If the function succeeds, the return value is a handle to the loaded module.
                <para>
                    If the function fails, the return value is an invalid handle. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetModuleHandle(System.String)">
            <summary>
            Retrieves a module handle for the specified module. The module must have been loaded by the calling process.
            </summary>
            <param name="lpModuleName">
            The name of the loaded module (either a .dll or .exe file).
            If the file name extension is omitted, the default library extension .dll is appended.
            The file name string can include a trailing point character (.) to indicate that the module name has no extension.
            The string does not have to specify a path. When specifying a path, be sure to use backslashes (\), not forward slashes (/).
            The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process.
            If this parameter is NULL, it returns a handle to the file used to create the calling process (.exe file).
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the specified module.
            If the function fails, the return value is NULL.To get extended error information, call GetLastError.
            </returns>
            <remarks>
            This function does not retrieve handles for modules that were loaded using the <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE"/> flag.
            This function returns a handle to a mapped module without incrementing its reference count.
            However, if this handle is passed to the <see cref="M:PInvoke.Kernel32.FreeLibrary(System.IntPtr)"/> function, the reference count of the mapped module will be decremented.
            Therefore, do not pass a handle returned by this function to the <see cref="M:PInvoke.Kernel32.FreeLibrary(System.IntPtr)"/> function. Doing so can cause a DLL module to be unmapped prematurely.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetModuleHandleEx(PInvoke.Kernel32.GetModuleHandleExFlags,System.String,PInvoke.Kernel32.SafeLibraryHandle@)">
            <summary>
            Retrieves a module handle for the specified module and increments the module's reference count unless <see cref="F:PInvoke.Kernel32.GetModuleHandleExFlags.GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT"/> is specified.
            The module must have been loaded by the calling process.
            </summary>
            <param name="dwFlags">
            This parameter can be zero or one or more of the following values.
            If the module's reference count is incremented, the caller must use the <see cref="M:PInvoke.Kernel32.FreeLibrary(System.IntPtr)"/> function to decrement the reference count when the module handle is no longer needed.</param>
            <param name="lpModuleName">The name of the loaded module (either a .dll or .exe file), or an address in the module (if <paramref name="dwFlags"/> is <see cref="F:PInvoke.Kernel32.GetModuleHandleExFlags.GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS"/>).</param>
            <param name="phModule">
            A handle to the specified module. If the function fails, this parameter is NULL.
            </param>
            <returns>
            If the function succeeds, returns true. If the function fails, the returns false.
            To get extended error information, see <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            The handle returned is not global or inheritable. It cannot be duplicated or used by another process.
            This function does not retrieve handles for modules that were loaded using the <see cref="F:PInvoke.Kernel32.LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE"/> flag.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)">
            <summary>
                Creates an instance of a named pipe and returns a handle for subsequent pipe operations. A named pipe server
                process uses this function either to create the first instance of a specific named pipe and establish its basic
                attributes or to create a new instance of an existing named pipe.
            </summary>
            <param name="lpName">
                The unique pipe name. This string must have the following form:
                <para>
                    <code>\\.\pipe\pipename</code>
                </para>
                <para>
                    The pipename part of the name can include any character other than a backslash, including numbers and special
                    characters. The entire pipe name string can be up to 256 characters long. Pipe names are not case sensitive.
                </para>
            </param>
            <param name="dwOpenMode">
                The open mode. The function fails if dwOpenMode specifies anything other than 0 or the flags
                from <see cref="T:PInvoke.Kernel32.PipeAccessMode" />.
                <para>The same mode must be specified for each instance of the pipe.</para>
            </param>
            <param name="dwPipeMode">
                The pipe mode. The function fails if dwPipeMode specifies anything other than 0 or the flags from
                <see cref="T:PInvoke.Kernel32.PipeMode" />.
                <para>
                    One of the following type modes can be specified. The same type mode must be specified for each instance of
                    the pipe.
                </para>
            </param>
            <param name="nMaxInstances">
                The maximum number of instances that can be created for this pipe. The first instance of
                the pipe can specify this value; the same number must be specified for other instances of the pipe. Acceptable
                values are in the range 1 through <see cref="F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES" /> (255). If this parameter is
                <see cref="F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES" />, the number of pipe instances that can be created is limited only by the
                availability of system resources. If nMaxInstances is greater than <see cref="F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES" />, the
                return value is an invalid handle and <see cref="M:PInvoke.Kernel32.GetLastError" /> returns
                <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_PARAMETER" />.
            </param>
            <param name="nOutBufferSize">The number of bytes to reserve for the output buffer.</param>
            <param name="nInBufferSize">The number of bytes to reserve for the input buffer.</param>
            <param name="nDefaultTimeOut">
                The default time-out value, in milliseconds, if the <see cref="M:PInvoke.Kernel32.WaitNamedPipe(System.String,System.Int32)"/> function specifies
                NMPWAIT_USE_DEFAULT_WAIT. Each instance of a named pipe must specify the same value.
            </param>
            <param name="lpSecurityAttributes">
                A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES" /> structure that specifies a
                security descriptor for the new named pipe and determines whether child processes can inherit the returned handle.
                If lpSecurityAttributes is NULL, the named pipe gets a default security descriptor and the handle cannot be
                inherited. The ACLs in the default security descriptor for a named pipe grant full control to the LocalSystem
                account, administrators, and the creator owner. They also grant read access to members of the Everyone group and
                the anonymous account.
            </param>
            <returns>
                If the function succeeds, the return value is a handle to the server end of a named pipe instance. If the
                function fails, the return value is an invalid handle. To get extended error information, call
                <see cref="M:PInvoke.Kernel32.GetLastError" />.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WaitNamedPipe(System.String,System.Int32)">
            <summary>
                Waits until either a time-out interval elapses or an instance of the specified named pipe is available for
                connection (that is, the pipe's server process has a pending <see cref="M:PInvoke.Kernel32.ConnectNamedPipe(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.OVERLAPPED*)" /> operation on the
                pipe).
            </summary>
            <param name="lpNamedPipeName">
                The name of the named pipe. The string must include the name of the computer on which the server process is
                executing. A period may be used for the servername if the pipe is local. The following pipe name format is used:
                <para>
                    <code>\\servername\pipe\pipename</code>
                </para>
            </param>
            <param name="nTimeOut">
                The number of milliseconds that the function will wait for an instance of the named pipe to be
                available. You can also use either <see cref="F:PInvoke.Kernel32.NMPWAIT_USE_DEFAULT_WAIT" /> or <see cref="F:PInvoke.Kernel32.NMPWAIT_WAIT_FOREVER" />
                instead of specifying a number of milliseconds.
            </param>
            <returns>
                If an instance of the pipe is available before the time-out interval elapses, the return value is nonzero.
                <para>
                    If an instance of the pipe is not available before the time-out interval elapses, the return value is zero.
                    To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
                <para>
                    If no instances of the specified named pipe exist, the WaitNamedPipe function returns immediately, regardless
                    of the time-out value.
                </para>
                <para>
                    If the time-out interval expires, the WaitNamedPipe function will fail with the error
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_SEM_TIMEOUT" />.
                </para>
                <para>
                    If the function succeeds, the process should use the <see cref="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)" /> function to open a handle to
                    the named pipe. A return value of TRUE indicates that there is at least one instance of the pipe available. A
                    subsequent <see cref="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)" /> call to the pipe can fail, because the instance was closed by the server
                    or opened by another client.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ConnectNamedPipe(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Enables a named pipe server process to wait for a client process to connect to an instance of a named pipe. A
                client process connects by calling either the CreateFile or CallNamedPipe function.
            </summary>
            <param name="hNamedPipe">
                A handle to the server end of a named pipe instance. This handle is returned by the
                CreateNamedPipe function.
            </param>
            <param name="lpOverlapped">
                A pointer to an OVERLAPPED structure.
                <para>
                    If hNamedPipe was opened with FILE_FLAG_OVERLAPPED, the lpOverlapped parameter must not be NULL. It must
                    point to a valid OVERLAPPED structure. If hNamedPipe was opened with FILE_FLAG_OVERLAPPED and lpOverlapped is
                    NULL, the function can incorrectly report that the connect operation is complete.
                </para>
                <para>
                    If hNamedPipe was created with FILE_FLAG_OVERLAPPED and lpOverlapped is not NULL, the OVERLAPPED structure
                    should contain a handle to a manual-reset event object (which the server can create by using the CreateEvent
                    function).
                </para>
                <para>
                    If hNamedPipe was not opened with FILE_FLAG_OVERLAPPED, the function does not return until a client is
                    connected or an error occurs. Successful synchronous operations result in the function returning a nonzero
                    value if a client connects after the function is called.
                </para>
            </param>
            <returns>
                If the operation is synchronous, ConnectNamedPipe does not return until the operation has completed. If the
                function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended
                error information, call GetLastError.
                <para>
                    If the operation is asynchronous, ConnectNamedPipe returns immediately. If the operation is still pending,
                    the return value is zero and GetLastError returns ERROR_IO_PENDING. (You can use the HasOverlappedIoCompleted
                    macro to determine when the operation has finished.) If the function fails, the return value is zero and
                    GetLastError returns a value other than ERROR_IO_PENDING or ERROR_PIPE_CONNECTED.
                </para>
                <para>
                    If a client connects before the function is called, the function returns zero and GetLastError returns
                    ERROR_PIPE_CONNECTED. This can happen if a client connects in the interval between the call to CreateNamedPipe
                    and the call to ConnectNamedPipe. In this situation, there is a good connection between client and server, even
                    though the function returns zero.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CallNamedPipe(System.String,System.Void*,System.Int32,System.Void*,System.Int32,System.Int32@,System.Int32)">
            <summary>
                Connects to a message-type pipe (and waits if an instance of the pipe is not available), writes to and reads
                from the pipe, and then closes the pipe.
            </summary>
            <param name="lpNamedPipeName">The pipe name.</param>
            <param name="lpInBuffer">The data to be written to the pipe.</param>
            <param name="nInBufferSize">The size of the write buffer, in bytes.</param>
            <param name="lpOutBuffer">A pointer to the buffer that receives the data read from the pipe.</param>
            <param name="nOutBufferSize">The size of the read buffer, in bytes.</param>
            <param name="lpBytesRead">A pointer to a variable that receives the number of bytes read from the pipe.</param>
            <param name="nTimeOut">
                The number of milliseconds to wait for the named pipe to be available. In addition to numeric
                values, <see cref="F:PInvoke.Kernel32.NMPWAIT_NOWAIT" />, <see cref="F:PInvoke.Kernel32.NMPWAIT_WAIT_FOREVER" /> and
                <see cref="F:PInvoke.Kernel32.NMPWAIT_USE_DEFAULT_WAIT" /> can be specified.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
                <para>
                    If the message written to the pipe by the server process is longer than nOutBufferSize, CallNamedPipe returns
                    FALSE, and GetLastError returns ERROR_MORE_DATA. The remainder of the message is discarded, because
                    CallNamedPipe closes the handle to the pipe before returning.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeClientComputerName(PInvoke.Kernel32.SafeObjectHandle,System.Text.StringBuilder,System.Int32)">
            <summary>Retrieves the client computer name for the specified named pipe.</summary>
            <param name="Pipe">
                A handle to an instance of a named pipe. This handle must be created by the CreateNamedPipe
                function.
            </param>
            <param name="ClientComputerName">The computer name.</param>
            <param name="ClientComputerNameLength">The size of the ClientComputerName buffer, in bytes.</param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.DisconnectNamedPipe(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>Disconnects the server end of a named pipe instance from a client process.</summary>
            <param name="hNamedPipe">
                A handle to an instance of a named pipe. This handle must be created by the CreateNamedPipe
                function.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeClientComputerName(PInvoke.Kernel32.SafeObjectHandle,System.Char*,System.Int32)">
            <summary>Retrieves the client computer name for the specified named pipe.</summary>
            <param name="Pipe">
                A handle to an instance of a named pipe. This handle must be created by the CreateNamedPipe
                function.
            </param>
            <param name="ClientComputerName">The computer name.</param>
            <param name="ClientComputerNameLength">The size of the ClientComputerName buffer, in bytes.</param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeClientProcessId(PInvoke.Kernel32.SafeObjectHandle,System.Int32@)">
            <summary>Retrieves the client process identifier for the specified named pipe.</summary>
            <param name="Pipe">
                A handle to an instance of a named pipe. This handle must be created by the CreateNamedPipe
                function.
            </param>
            <param name="ClientProcessId">The process identifier.</param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeClientSessionId(PInvoke.Kernel32.SafeObjectHandle,System.Int32@)">
            <summary>
            Retrieves the client session identifier for the specified named pipe.
            </summary>
            <param name="Pipe">
                A handle to an instance of a named pipe. This handle must be created by the CreateNamedPipe
                function.
            </param>
            <param name="ClientSessionId">The session identifier.</param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeHandleState(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PipeMode@,System.Int32*,System.Int32*,System.Int32*,System.Text.StringBuilder,System.Int32)">
            <summary>
                Retrieves information about a specified named pipe. The information returned can vary during the lifetime of
                an instance of the named pipe.
            </summary>
            <param name="hNamedPipe">
                A handle to the named pipe for which information is wanted. The handle must have GENERIC_READ
                access for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a
                write-only pipe.
                <para>This parameter can also be a handle to an anonymous pipe, as returned by the CreatePipe function.</para>
            </param>
            <param name="lpState">
                A pointer to a variable that indicates the current state of the handle. Either or both of
                <see cref="F:PInvoke.Kernel32.PipeMode.PIPE_NOWAIT" /> and <see cref="F:PInvoke.Kernel32.PipeMode.PIPE_READMODE_MESSAGE" /> can be specified.
            </param>
            <param name="lpCurInstances">
                A pointer to a variable that receives the number of current pipe instances. This parameter
                can be NULL if this information is not required.
            </param>
            <param name="lpMaxCollectionCount">
                A pointer to a variable that receives the maximum number of bytes to be collected on
                the client's computer before transmission to the server. This parameter must be NULL if the specified pipe handle
                is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can
                be NULL if this information is not required.
            </param>
            <param name="lpCollectDataTimeout">
                A pointer to a variable that receives the maximum time, in milliseconds, that can
                pass before a remote named pipe transfers information over the network. This parameter must be NULL if the
                specified pipe handle is to the server end of a named pipe or if client and server processes are on the same
                computer. This parameter can be NULL if this information is not required.
            </param>
            <param name="lpUserName">
                A pointer to a buffer that receives the user name string associated with the client application. The server can
                only retrieve this information if the client opened the pipe with SECURITY_IMPERSONATION access.
                <para>
                    This parameter must be NULL if the specified pipe handle is to the client end of a named pipe. This parameter
                    can be NULL if this information is not required.
                </para>
            </param>
            <param name="nMaxUserNameSize">
                The size of the buffer specified by the lpUserName parameter, in chars. This parameter
                is ignored if lpUserName is NULL.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeHandleState(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PipeMode@,System.Int32*,System.Int32*,System.Int32*,System.Char*,System.Int32)">
            <summary>
                Retrieves information about a specified named pipe. The information returned can vary during the lifetime of
                an instance of the named pipe.
            </summary>
            <param name="hNamedPipe">
                A handle to the named pipe for which information is wanted. The handle must have GENERIC_READ
                access for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a
                write-only pipe.
                <para>This parameter can also be a handle to an anonymous pipe, as returned by the CreatePipe function.</para>
            </param>
            <param name="lpState">
                A pointer to a variable that indicates the current state of the handle. Either or both of
                <see cref="F:PInvoke.Kernel32.PipeMode.PIPE_NOWAIT" /> and <see cref="F:PInvoke.Kernel32.PipeMode.PIPE_READMODE_MESSAGE" /> can be specified.
            </param>
            <param name="lpCurInstances">
                A pointer to a variable that receives the number of current pipe instances. This parameter
                can be NULL if this information is not required.
            </param>
            <param name="lpMaxCollectionCount">
                A pointer to a variable that receives the maximum number of bytes to be collected on
                the client's computer before transmission to the server. This parameter must be NULL if the specified pipe handle
                is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can
                be NULL if this information is not required.
            </param>
            <param name="lpCollectDataTimeout">
                A pointer to a variable that receives the maximum time, in milliseconds, that can
                pass before a remote named pipe transfers information over the network. This parameter must be NULL if the
                specified pipe handle is to the server end of a named pipe or if client and server processes are on the same
                computer. This parameter can be NULL if this information is not required.
            </param>
            <param name="lpUserName">
                A pointer to a buffer that receives the user name string associated with the client application. The server can
                only retrieve this information if the client opened the pipe with SECURITY_IMPERSONATION access.
                <para>
                    This parameter must be NULL if the specified pipe handle is to the client end of a named pipe. This parameter
                    can be NULL if this information is not required.
                </para>
            </param>
            <param name="nMaxUserNameSize">
                The size of the buffer specified by the lpUserName parameter, in chars. This parameter
                is ignored if lpUserName is NULL.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeInfo(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.NamedPipeInfoFlags@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>Retrieves information about the specified named pipe.</summary>
            <param name="hNamedPipe">
                A handle to the named pipe instance. The handle must have GENERIC_READ access to the named
                pipe for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a
                write-only pipe.
                <para>
                    This parameter can also be a handle to an anonymous pipe, as returned by the <see cref="M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Int32)" />
                    function.
                </para>
            </param>
            <param name="lpFlags">Receives the type of the named pipe.</param>
            <param name="lpOutBufferSize">
                Receives the size of the buffer for outgoing data, in bytes. If the buffer size is zero,
                the buffer is allocated as needed.
            </param>
            <param name="lpInBufferSize">
                Receives the size of the buffer for incoming data, in bytes. If the buffer size is zero,
                the buffer is allocated as needed.
            </param>
            <param name="lpMaxInstances">
                Receives the maximum number of pipe instances that can be created. If the variable is set
                to <see cref="F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES" /> (255), the number of pipe instances that can be created is limited only
                by the availability of system resources.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeServerProcessId(PInvoke.Kernel32.SafeObjectHandle,System.Int32@)">
            <summary>Retrieves the server process identifier for the specified named pipe.</summary>
            <param name="Pipe">
                A handle to an instance of a named pipe. This handle must be created by the
                <see cref="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)" /> function.
            </param>
            <param name="ServerProcessId">The process identifier.</param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeServerSessionId(PInvoke.Kernel32.SafeObjectHandle,System.Int32@)">
            <summary>
            Retrieves the server session identifier for the specified named pipe.
            </summary>
            <param name="Pipe">
                A handle to an instance of a named pipe. This handle must be created by the
                <see cref="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)" /> function.
            </param>
            <param name="ServerSessionId">The session identifier.</param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.PeekNamedPipe(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
                Copies data from a named or anonymous pipe into a buffer without removing it from the pipe. It also returns
                information about data in the pipe.
            </summary>
            <param name="hNamedPipe">
                A handle to the pipe. This parameter can be a handle to a named pipe instance, as returned by
                the <see cref="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)" /> or <see cref="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)" /> function, or it can be a handle to the read end of
                an anonymous pipe, as returned by the <see cref="M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Int32)" /> function. The handle must have GENERIC_READ access
                to the pipe.
            </param>
            <param name="lpBuffer">
                A pointer to a buffer that receives data read from the pipe. This parameter can be NULL if no
                data is to be read.
            </param>
            <param name="nBufferSize">
                The size of the buffer specified by the lpBuffer parameter, in bytes. This parameter is
                ignored if lpBuffer is NULL.
            </param>
            <param name="lpBytesRead">A pointer to a variable that receives the number of bytes read from the pipe.</param>
            <param name="lpTotalBytesAvail">
                A pointer to a variable that receives the total number of bytes available to be read
                from the pipe.
            </param>
            <param name="lpBytesLeftThisMessage">
                A pointer to a variable that receives the number of bytes remaining in this
                message. This parameter will be zero for byte-type named pipes or for anonymous pipes.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SetNamedPipeHandleState(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PipeMode*,System.Int32*,System.Int32*)">
            <summary>
                Sets the read mode and the blocking mode of the specified named pipe. If the specified handle is to the client
                end of a named pipe and if the named pipe server process is on a remote computer, the function can also be used to
                control local buffering.
            </summary>
            <param name="hNamedPipe">
                A handle to the named pipe instance. This parameter can be a handle to the server end of the
                pipe, as returned by the <see cref="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)" /> function, or to the client end of the pipe, as returned by
                the <see cref="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)" /> function. The handle must have GENERIC_WRITE access to the named pipe for a
                write-only or read/write pipe, or it must have GENERIC_READ and FILE_WRITE_ATTRIBUTES access for a read-only pipe.
                <para>
                    This parameter can also be a handle to an anonymous pipe, as returned by the <see cref="M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Int32)" />
                    function.
                </para>
            </param>
            <param name="lpMode">The new pipe mode. The mode is a combination of a read-mode flag and a wait-mode flag.</param>
            <param name="lpMaxCollectionCount">
                The maximum number of bytes collected on the client computer before transmission to
                the server. This parameter must be NULL if the specified pipe handle is to the server end of a named pipe or if
                client and server processes are on the same machine. This parameter is ignored if the client process specifies the
                FILE_FLAG_WRITE_THROUGH flag in the CreateFile function when the handle was created. This parameter can be NULL if
                the collection count is not being set.
            </param>
            <param name="lpCollectDataTimeout">
                The maximum time, in milliseconds, that can pass before a remote named pipe
                transfers information over the network. This parameter must be NULL if the specified pipe handle is to the server
                end of a named pipe or if client and server processes are on the same computer. This parameter is ignored if the
                client process specified the FILE_FLAG_WRITE_THROUGH flag in the CreateFile function when the handle was created.
                This parameter can be NULL if the collection count is not being set.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.TransactNamedPipe(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Void*,System.Int32,System.Int32@,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Combines the functions that write a message to and read a message from the specified named pipe into a single
                network operation.
            </summary>
            <param name="hNamedPipe">
                A handle to the named pipe returned by the <see cref="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)" /> or
                <see cref="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)" /> function.
                <para>
                    This parameter can also be a handle to an anonymous pipe, as returned by the <see cref="M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Int32)" />
                    function.
                </para>
            </param>
            <param name="lpInBuffer">A pointer to the buffer containing the data to be written to the pipe.</param>
            <param name="nInBufferSize">The size of the input buffer, in bytes.</param>
            <param name="lpOutBuffer">A pointer to the buffer that receives the data read from the pipe.</param>
            <param name="nOutBufferSize">The size of the output buffer, in bytes.</param>
            <param name="lpBytesRead">A pointer to the variable that receives the number of bytes read from the pipe.</param>
            <param name="lpOverlapped">
                A pointer to an <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure. This structure is required if hNamedPipe was opened with
                FILE_FLAG_OVERLAPPED.
                <para>
                    If hNamedPipe was opened with FILE_FLAG_OVERLAPPED, the lpOverlapped parameter must not be NULL. It must
                    point to a valid <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure. If hNamedPipe was created with FILE_FLAG_OVERLAPPED and
                    lpOverlapped is NULL, the function can incorrectly report that the operation is complete.
                </para>
                <para>
                    If hNamedPipe was opened with FILE_FLAG_OVERLAPPED and lpOverlapped is not NULL, TransactNamedPipe is
                    executed as an overlapped operation. The <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure should contain a manual-reset
                    event object (which can be created by using the CreateEvent function). If the operation cannot be completed
                    immediately, TransactNamedPipe returns FALSE and GetLastError returns ERROR_IO_PENDING. In this situation, the
                    event object is set to the nonsignaled state before TransactNamedPipe returns, and it is set to the signaled
                    state when the transaction has finished. Also, you can be notified when an overlapped operation completes by
                    using the GetQueuedCompletionStatus or GetQueuedCompletionStatusEx functions. In this case, you do not need to
                    assign the manual-reset event in the <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure, and the completion happens against
                    <paramref name="hNamedPipe" /> in the same way as an asynchronous read or write operation.
                </para>
                <para>
                    If hNamedPipe was not opened with FILE_FLAG_OVERLAPPED, TransactNamedPipe does not return until the operation
                    is complete.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
                <para>
                    If the message to be read is longer than the buffer specified by the <paramref name="nOutBufferSize" />
                    parameter, TransactNamedPipe returns FALSE and the <see cref="M:PInvoke.Kernel32.GetLastError" /> function returns
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_MORE_DATA" />. The remainder of the message can be read by a subsequent call to
                    <see cref="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)" />, ReadFileEx, or PeekNamedPipe.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)">
            <summary>
            Allocates the specified number of bytes from the heap.
            </summary>
            <param name="uFlags">
            The memory allocation attributes. The default is the <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_FIXED"/> value.
            This parameter can be one or more of the following values, except for the incompatible combinations that are specifically noted.
            </param>
            <param name="uBytes">
            The number of bytes to allocate. If this parameter is zero and the <paramref name="uFlags"/> parameter specifies <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_MOVEABLE"/>,
            the function returns a handle to a memory object that is marked as discarded.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the newly allocated memory object.
            If the function fails, the return value is NULL. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.LocalReAllocFlags)">
            <summary>
            Changes the size or the attributes of a specified local memory object. The size can increase or decrease.
            </summary>
            <param name="hMem">
            A handle to the local memory object to be reallocated.
            This handle is returned by either the <see cref="M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)"/> or <see cref="M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.LocalReAllocFlags)"/> function.
            </param>
            <param name="uBytes">The new size of the memory block, in bytes. If uFlags specifies <see cref="F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MODIFY"/>, this parameter is ignored.</param>
            <param name="uFlags">
            The reallocation options. If <see cref="F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MODIFY"/> is specified, the function modifies the attributes of the memory object only
            (the uBytes parameter is ignored.) Otherwise, the function reallocates the memory object.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the reallocated memory object.
            If the function fails, the return value is NULL. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            If LocalReAlloc fails, the original memory is not freed, and the original handle and pointer are still valid.
            If LocalReAlloc reallocates a fixed object, the value of the handle returned is the address of the first byte of the memory block.
            To access the memory, a process can simply cast the return value to a pointer.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.LocalFree(System.Void*)">
            <summary>
            Frees the specified local memory object and invalidates its handle.
            </summary>
            <param name="hMem">
            A handle to the local memory object. This handle is returned by either the <see cref="M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)"/> or
            <see cref="M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.LocalReAllocFlags)"/> function. It is not safe to free memory allocated with <see cref="M:PInvoke.Kernel32.GlobalAlloc(PInvoke.Kernel32.GlobalAllocFlags,System.IntPtr)"/>.
            If the hMem parameter is NULL, LocalFree ignores the parameter and returns NULL.
            </param>
            <returns>
            If the function succeeds, the return value is NULL.
            If the function fails, the return value is equal to a handle to <paramref name="hMem"/>. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LocalLock(System.Void*)">
            <summary>
            Locks a local memory object and returns a pointer to the first byte of the object's memory block.
            </summary>
            <param name="hMem">A handle to the local memory object. This handle is returned by either the <see cref="M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)"/> or <see cref="M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.Int32,PInvoke.Kernel32.LocalReAllocFlags)"/> function.</param>
            <returns>
            If the function succeeds, the return value is a pointer to the first byte of the memory block.
            If the function fails, the return value is <see cref="F:System.IntPtr.Zero"/>. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LocalUnlock(System.Void*)">
            <summary>
            Decrements the lock count associated with a memory object that was allocated with <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_MOVEABLE"/>.
            This function has no effect on memory objects allocated with <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_FIXED"/>.
            </summary>
            <param name="hMem">A handle to the local  memory object. This handle is returned by either the <see cref="M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)"/> or <see cref="M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.Int32,PInvoke.Kernel32.LocalReAllocFlags)"/> function.</param>
            <returns>
            If the memory object is still locked after decrementing the lock count, the return value is true.
            If the memory object is unlocked after decrementing the lock count, the function returns false and <see cref="M:PInvoke.Kernel32.GetLastError"/> returns <see cref="F:PInvoke.Win32ErrorCode.ERROR_SUCCESS"/>.
            If the function fails, the return value is false and <see cref="M:PInvoke.Kernel32.GetLastError"/> returns a value other than <see cref="F:PInvoke.Win32ErrorCode.ERROR_SUCCESS"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GlobalAlloc(PInvoke.Kernel32.GlobalAllocFlags,System.IntPtr)">
            <summary>
            Allocates the specified number of bytes from the heap.
            </summary>
            <param name="uFlags">
            The memory allocation attributes. The default is the <see cref="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_FIXED"/> value.
            This parameter can be one or more of the following values, except for the incompatible combinations that are specifically noted.
            </param>
            <param name="uBytes">
            The number of bytes to allocate. If this parameter is zero and the uFlags parameter specifies <see cref="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_MOVEABLE"/>,
            the function returns a handle to a memory object that is marked as discarded.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the newly allocated memory object.
            If the function fails, the return value is NULL. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GlobalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.GlobalReAllocFlags)">
            <summary>
            Changes the size or attributes of a specified global memory object. The size can increase or decrease.
            </summary>
            <param name="hMem">
            A handle to the global memory object to be reallocated.
            This handle is returned by either the <see cref="M:PInvoke.Kernel32.GlobalAlloc(PInvoke.Kernel32.GlobalAllocFlags,System.IntPtr)"/> or <see cref="M:PInvoke.Kernel32.GlobalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.GlobalReAllocFlags)"/> function.
            </param>
            <param name="uBytes">The new size of the memory block, in bytes. If uFlags specifies <see cref="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_MODIFY"/>, this parameter is ignored.</param>
            <param name="uFlags">
            The reallocation options. If <see cref="F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MODIFY"/> is specified, the function modifies the attributes of the memory object only
            (the uBytes parameter is ignored.) Otherwise, the function reallocates the memory object.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the reallocated memory object.
            If the function fails, the return value is NULL. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            If GlobalReAlloc fails, the original memory is not freed, and the original handle and pointer are still valid.
            If GlobalReAlloc reallocates a fixed object, the value of the handle returned is the address of the first byte of the memory block.
            To access the memory, a process can simply cast the return value to a pointer.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GlobalFree(System.Void*)">
            <summary>
            Frees the specified global memory object and invalidates its handle.
            </summary>
            <param name="hMem">
            A handle to the global memory object. This handle is returned by either the <see cref="M:PInvoke.Kernel32.GlobalAlloc(PInvoke.Kernel32.GlobalAllocFlags,System.IntPtr)"/> or
            <see cref="M:PInvoke.Kernel32.GlobalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.GlobalReAllocFlags)"/> function. It is not safe to free memory allocated with <see cref="M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)"/>.
            </param>
            <returns>
            If the function succeeds, the return value is NULL.
            If the function fails, the return value is equal to a handle to <paramref name="hMem"/>. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GlobalLock(System.Void*)">
            <summary>
            Locks a global memory object and returns a pointer to the first byte of the object's memory block.
            </summary>
            <param name="hMem">A handle to the global memory object. This handle is returned by either the <see cref="M:PInvoke.Kernel32.GlobalAlloc(PInvoke.Kernel32.GlobalAllocFlags,System.IntPtr)"/> or <see cref="M:PInvoke.Kernel32.GlobalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.GlobalReAllocFlags)"/> function.</param>
            <returns>
            If the function succeeds, the return value is a pointer to the first byte of the memory block.
             If the function fails, the return value is <see cref="F:System.IntPtr.Zero"/>. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GlobalUnlock(System.Void*)">
            <summary>
            Decrements the lock count associated with a memory object that was allocated with <see cref="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_MOVEABLE"/>.
            This function has no effect on memory objects allocated with <see cref="F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_FIXED"/>.
            </summary>
            <param name="hMem">A handle to the global memory object. This handle is returned by either the <see cref="M:PInvoke.Kernel32.GlobalAlloc(PInvoke.Kernel32.GlobalAllocFlags,System.IntPtr)"/> or <see cref="M:PInvoke.Kernel32.GlobalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.GlobalReAllocFlags)"/> function.</param>
            <returns>
            If the memory object is still locked after decrementing the lock count, the return value is true.
            If the memory object is unlocked after decrementing the lock count, the function returns false and <see cref="M:PInvoke.Kernel32.GetLastError"/> returns <see cref="F:PInvoke.Win32ErrorCode.ERROR_SUCCESS"/>.
            If the function fails, the return value is false and <see cref="M:PInvoke.Kernel32.GetLastError"/> returns a value other than <see cref="F:PInvoke.Win32ErrorCode.ERROR_SUCCESS"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.HeapAlloc(System.IntPtr,PInvoke.Kernel32.HeapAllocFlags,System.IntPtr)">
            <summary>
            Allocates a block of memory from a heap. The allocated memory is not movable.
            </summary>
            <param name="hHeap">A handle to the heap from which the memory will be allocated. This handle is returned by the HeapCreate or  function.</param>
            <param name="uFlags">The heap allocation options. Specifying any of these values will override the corresponding value specified when the heap was created with HeapCreate.</param>
            <param name="uBytes">
            The number of bytes to be allocated. If the heap specified by the hHeap parameter is a "non-growable" heap,
            dwBytes must be less than 0x7FFF8.
            You create a non-growable heap by calling the HeapCreate function with a nonzero value.
            </param>
            <returns>
            If the function succeeds, the return value is a pointer to the allocated memory block.
            If the function fails and you have not specified <see cref="F:PInvoke.Kernel32.HeapAllocFlags.HEAP_GENERATE_EXCEPTIONS"/>, the return value is NULL.
            If the function fails and you have specified <see cref="F:PInvoke.Kernel32.HeapAllocFlags.HEAP_GENERATE_EXCEPTIONS"/>,
            the function may generate either of the exceptions listed in the following table:
            <list>
            <item>STATUS_NO_MEMORY: The allocation attempt failed because of a lack of available memory or heap corruption.</item>
            <item>STATUS_ACCESS_VIOLATION: The allocation attempt failed because of heap corruption or improper function parameters.</item>
            </list>
            The particular exception depends upon the nature of the heap corruption. For more information, see GetExceptionCode.
            </returns>
            <remarks>If the function fails, it does not call SetLastError. An application cannot call <see cref="M:PInvoke.Kernel32.GetLastError"/> for extended error information.</remarks>
        </member>
        <member name="M:PInvoke.Kernel32.HeapReAlloc(System.IntPtr,PInvoke.Kernel32.HeapReAllocFlags,System.Void*,System.IntPtr)">
            <summary>
            Reallocates a block of memory from a heap. This function enables you to resize a memory block and change other memory block properties.
            The allocated memory is not movable.
            </summary>
            <param name="hHeap">A handle to the heap from which the memory is to be reallocated. This handle is a returned by either the HeapCreate or GetProcessHeap function.</param>
            <param name="uFlags">
            The heap reallocation options. Specifying a value overrides the corresponding value specified in the flOptions parameter
            when the heap was created by using the HeapCreate function.
            </param>
            <param name="hMem">
            A pointer to the block of memory that the function reallocates.
            This pointer is returned by an earlier call to the <see cref="M:PInvoke.Kernel32.HeapAlloc(System.IntPtr,PInvoke.Kernel32.HeapAllocFlags,System.IntPtr)"/> or <see cref="M:PInvoke.Kernel32.HeapReAlloc(System.IntPtr,PInvoke.Kernel32.HeapReAllocFlags,System.Void*,System.IntPtr)"/> function.
            </param>
            <param name="uBytes">
            The new size of the memory block, in bytes. A memory block's size can be increased or decreased by using this function.
            If the heap specified by the hHeap parameter is a "non-growable" heap, dwBytes must be less than 0x7FFF8.
            You create a non-growable heap by calling the HeapCreate function with a nonzero value.
            </param>
            <returns>
            If the function succeeds, the return value is a pointer to the reallocated memory block.
            If the function fails and you have not specified <see cref="F:PInvoke.Kernel32.HeapAllocFlags.HEAP_GENERATE_EXCEPTIONS"/>, the return value is NULL.
            If the function fails and you have specified <see cref="F:PInvoke.Kernel32.HeapAllocFlags.HEAP_GENERATE_EXCEPTIONS"/>,
            the function may generate either of the exceptions listed in the following table:
            <list>
            <item>STATUS_NO_MEMORY: The allocation attempt failed because of a lack of available memory or heap corruption.</item>
            <item>STATUS_ACCESS_VIOLATION: The allocation attempt failed because of heap corruption or improper function parameters.</item>
            </list>
            The particular exception depends upon the nature of the heap corruption. For more information, see GetExceptionCode.
            </returns>
            <remarks>If the function fails, it does not call SetLastError. An application cannot call <see cref="M:PInvoke.Kernel32.GetLastError"/> for extended error information.</remarks>
        </member>
        <member name="M:PInvoke.Kernel32.HeapFree(System.IntPtr,PInvoke.Kernel32.HeapFreeFlags,System.Void*)">
            <summary>
            Frees a memory block allocated from a heap by the <see cref="M:PInvoke.Kernel32.HeapAlloc(System.IntPtr,PInvoke.Kernel32.HeapAllocFlags,System.IntPtr)"/> or <see cref="M:PInvoke.Kernel32.HeapReAlloc(System.IntPtr,PInvoke.Kernel32.HeapReAllocFlags,System.Void*,System.IntPtr)"/> function.
            </summary>
            <param name="hHeap">
            A handle to the heap whose memory block is to be freed. This handle is returned by either the HeapCreate or
            GetProcessHeap function.
            </param>
            <param name="dwFlags">The heap free options. Specifying the following value overrides the corresponding value specified in the flOptions parameter
            when the heap was created by using the HeapCreate function.</param>
            <param name="hMem">
            A pointer to the memory block to be freed. This pointer is returned by the <see cref="M:PInvoke.Kernel32.HeapAlloc(System.IntPtr,PInvoke.Kernel32.HeapAllocFlags,System.IntPtr)"/> or <see cref="M:PInvoke.Kernel32.HeapReAlloc(System.IntPtr,PInvoke.Kernel32.HeapReAllocFlags,System.Void*,System.IntPtr)"/> function.
            If this pointer is NULL, the behavior is undefined.
            </param>
            <returns>
            If the function succeeds, the return value is true. If the function fails, the return value false. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.HeapLock(System.IntPtr)">
            <summary>
            Attempts to acquire the critical section object, or lock, that is associated with a specified heap.
            </summary>
            <param name="hMem">A handle to the heap to be locked. This handle is returned by either the <see cref="M:PInvoke.Kernel32.HeapAlloc(System.IntPtr,PInvoke.Kernel32.HeapAllocFlags,System.IntPtr)"/> or <see cref="M:PInvoke.Kernel32.HeapReAlloc(System.IntPtr,PInvoke.Kernel32.HeapReAllocFlags,System.Void*,System.IntPtr)"/> function.</param>
            <returns>
            If the function succeeds, the return value is true. If the function fails, the return value is zero.
            To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.HeapUnlock(System.IntPtr)">
            <summary>
            Releases ownership of the critical section object, or lock, that is associated with a specified heap. It reverses the action of the <see cref="M:PInvoke.Kernel32.HeapLock(System.IntPtr)"/> function.
            </summary>
            <param name="hHeap">A handle to the heap to be unlocked. This handle is returned by either the HeapCreate or GetProcessHeap function.</param>
            <returns>
            If the function succeeds, the return value is true. If the function fails, the return value is zero.
            To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CopyMemory(System.Void*,System.Void*,System.IntPtr)">
            <summary>
            Copies a block of memory from one location to another.
            </summary>
            <param name="Destination">A pointer to the starting address of the copied block's destination.</param>
            <param name="Source">A pointer to the starting address of the block of memory to copy.</param>
            <param name="Length">The size of the block of memory to copy, in bytes.</param>
            <remarks>
            This function is defined as the RtlCopyMemory function.
            If the source and destination blocks overlap, the results are undefined.
            For overlapped blocks, use the <see cref="M:PInvoke.Kernel32.MoveMemory(System.Void*,System.Void*,System.IntPtr)"/> function.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.MoveMemory(System.Void*,System.Void*,System.IntPtr)">
            <summary>
            Moves a block of memory from one location to another.
            </summary>
            <param name="Destination">A pointer to the starting address of the move destination.</param>
            <param name="Source">A pointer to the starting address of the block of memory to be moved.</param>
            <param name="Length">The size of the block of memory to move, in bytes.</param>
            <remarks>
            <para>
            This function is defined as the RtlMoveMemory function.
            The source and destination blocks may overlap.
            </para>
            <para>
            The first parameter, <paramref name="Destination"/>, must be large enough to hold <paramref name="Length"/> bytes of <paramref name="Source"/>;
            otherwise, a buffer overrun may occur.
            This may lead to a denial of service attack against the application if an access violation occurs or, in the worst case,
            allow an attacker to inject executable code into your process.
            This is especially true if <paramref name="Destination"/> is a stack-based buffer.
            Be aware that the last parameter, <paramref name="Length"/>, is the number of bytes to copy into <paramref name="Destination"/>, not the size of the <paramref name="Destination"/>.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.EnumResourceNames(PInvoke.Kernel32.SafeLibraryHandle,System.Char*,PInvoke.Kernel32.EnumResNameProc,System.IntPtr)">
            <summary>
                Enumerates resources of a specified type within a binary module. For Windows Vista and later, this is
                typically a language-neutral Portable Executable (LN file), and the enumeration will also include resources from
                the corresponding language-specific resource files (.mui files) that contain localizable language resources. It is
                also possible for hModule to specify an .mui file, in which case only that file is searched for resources.
            </summary>
            <param name="hModule">
                A handle to a module to be searched. Starting with Windows Vista, if this is an LN file, then appropriate .mui
                files (if any exist) are included in the search.
                <para>
                    If this parameter is NULL, that is equivalent to passing in a handle to the module used to create the current
                    process.
                </para>
            </param>
            <param name="lpszType">
                The type of the resource for which the name is being enumerated. Alternately, rather than a
                pointer, this parameter can be <see cref="M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)" />(ID), where ID is an integer value representing a
                predefined resource type.
            </param>
            <param name="lpEnumFunc">A pointer to the callback function to be called for each enumerated resource name or ID.</param>
            <param name="lParam">
                An application-defined value passed to the callback function. This parameter can be used in error
                checking.
            </param>
            <returns>
                The return value is TRUE if the function succeeds or FALSE if the function does not find a resource of the
                type specified, or if the function fails for another reason. To get extended error information, call
                <see cref="M:PInvoke.Kernel32.GetLastError" />.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.EnumResourceLanguages(PInvoke.Kernel32.SafeLibraryHandle,System.Char*,System.Char*,PInvoke.Kernel32.EnumResLangProc,System.Void*)">
            <summary>
                Enumerates language-specific resources, of the specified type and name, associated with a binary module.
            </summary>
            <param name="hModule">
                The handle to a module to be searched. Starting with Windows Vista, if this is a language-neutral Portable
                Executable (LN file), then appropriate .mui files (if any exist) are included in the search. If this is a
                specific .mui file, only that file is searched for resources.
                <para>
                    If this parameter is NULL, that is equivalent to passing in a handle to the module used to create the current process.
                </para>
            </param>
            <param name="lpType">
                The type of resource for which the language is being enumerated. Alternately, rather than a pointer, this
                parameter can be <see cref="M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)"/>(ID), where ID is an integer value representing a predefined resource type.
            </param>
            <param name="lpName">
                The name of the resource for which the language is being enumerated. Alternately, rather than a pointer,
                this parameter can be <see cref="M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)"/>(ID), where ID is the integer identifier of the resource.
            </param>
            <param name="lpEnumFunc">
                A pointer to the callback function to be called for each enumerated resource language. For more information,
                see <see cref="T:PInvoke.Kernel32.EnumResLangProc"/>.
            </param>
            <param name="lParam">
                An application-defined value passed to the callback function. This parameter can be used in error checking.
            </param>
            <returns>Returns TRUE if successful or FALSE otherwise. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.IS_INTRESOURCE(System.Char*)">
            <summary>Determines whether a value is an integer identifier for a resource.</summary>
            <param name="p">The pointer to be tested whether it contains an integer resource identifier.</param>
            <returns>If the value is a resource identifier, the return value is TRUE. Otherwise, the return value is FALSE.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)">
            <summary>
                Converts an integer value to a resource type compatible with the resource-management functions. This macro is
                used in place of a string containing the name of the resource.
            </summary>
            <param name="wInteger">The integer value to be converted.</param>
            <returns>The return value is the specified value in the low-order word and zero in the high-order word.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.FindResource(PInvoke.Kernel32.SafeLibraryHandle,System.Char*,System.Char*)">
            <summary>
                Determines the location of a resource with the specified type and name in the specified module.
                <para>To specify a language, use the FindResourceEx function.</para>
            </summary>
            <param name="hModule">
                A handle to the module whose portable executable file or an accompanying MUI file contains the
                resource. If this parameter is <see cref="F:PInvoke.Kernel32.SafeLibraryHandle.Null" />, the function searches the module used to
                create the current process.
            </param>
            <param name="lpName">
                The name of the resource. Alternately, rather than a pointer, this parameter can be
                <see cref="M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)" />, where wInteger is the integer identifier of the resource.
            </param>
            <param name="lpType">
                The resource type. Alternately, rather than a pointer, this parameter can be
                <see cref="M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)" />, where wInteger is the integer identifier of the given resource type.
            </param>
            <returns>
                If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a
                handle to the resource, pass this handle to the <see cref="M:PInvoke.Kernel32.LoadResource(PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr)"/> function.
                <para>
                    If the function fails, the return value is NULL. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SizeofResource(PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr)">
            <summary>Retrieves the size, in bytes, of the specified resource.</summary>
            <param name="hModule">A handle to the module whose executable file contains the resource.</param>
            <param name="hResInfo">
                handle to the resource. This handle must be created by using the <see cref="M:PInvoke.Kernel32.FindResource(PInvoke.Kernel32.SafeLibraryHandle,System.Char*,System.Char*)" /> or
                FindResourceEx function.
            </param>
            <returns>
                If the function succeeds, the return value is the number of bytes in the resource.
                <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.Wow64SuspendThread(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Suspends the specified WOW64 thread.
            </summary>
            <param name="hThread">
            A handle to the thread that is to be suspended.
            The handle must have the THREAD_SUSPEND_RESUME access right. For more information, see Thread Security and Access Rights.
            </param>
            <returns>
            If the function succeeds, the return value is the thread's previous suspend count; otherwise, it is (DWORD) -1. To get extended error information, use the <see cref="M:PInvoke.Kernel32.GetLastError"/> function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.AssignProcessToJobObject(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Assigns a process to an existing job object.
            </summary>
            <param name="hJob">
            A handle to the job object to which the process will be associated.
            The <see cref="M:PInvoke.Kernel32.CreateJobObject(PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.String)" /> or OpenJobObject function returns this handle.
            The handle must have the JOB_OBJECT_ASSIGN_PROCESS access right. For more information, see Job Object Security and Access Rights.
            </param>
            <param name="hProcess">
            A handle to the process to associate with the job object. The handle must have the PROCESS_SET_QUOTA and PROCESS_TERMINATE access rights. For more information, see Process Security and Access Rights.
            If the process is already associated with a job, the job specified by hJob must be empty or it must be in the hierarchy of nested jobs to which the process already belongs, and it cannot have UI limits set(SetInformationJobObject with JobObjectBasicUIRestrictions).
            For more information, see Remarks.
            Windows 7, Windows Server 2008 R2, Windows XP with SP3, Windows Server 2008, Windows Vista, and Windows Server 2003:  The process must not already be assigned to a job; if it is, the function fails with ERROR_ACCESS_DENIED.This behavior changed starting in Windows 8 and Windows Server 2012.
            Terminal Services:  All processes within a job must run within the same session as the job.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero.To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateJobObject(PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.String)">
            <summary>
            Creates or opens a job object.
            </summary>
            <param name="lpJobAttributes">A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies the security descriptor for the job object and determines whether child processes can inherit the returned handle.
            If lpJobAttributes is NULL, the job object gets a default security descriptor and the handle cannot be inherited.
            The ACLs in the default security descriptor for a job object come from the primary or impersonation token of the creator.
            </param>
            <param name="lpName">The name of the job. The name is limited to MAX_PATH characters. Name comparison is case-sensitive.
            If lpName is NULL, the job is created without a name.
            If lpName matches the name of an existing event, semaphore, mutex, waitable timer, or file-mapping object, the function fails and the GetLastError function returns ERROR_INVALID_HANDLE.
            This occurs because these objects share the same namespace.The object can be created in a private namespace.For more information, see Object Namespaces.
            Terminal Services:  The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see Kernel Object Namespaces.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the job object. The handle has the JOB_OBJECT_ALL_ACCESS access right. If the object existed before the function call, the function returns a handle to the existing job object and GetLastError returns ERROR_ALREADY_EXISTS.
            If the function fails, the return value is NULL.To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.IsProcessInJob(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.SafeObjectHandle,System.Boolean@)">
            <summary>
            Determines whether the process is running in the specified job.
            </summary>
            <param name="hProcess">
            A handle to the process to be tested. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see Process Security and Access Rights.
            Windows Server 2003 and Windows XP:  The handle must have the PROCESS_QUERY_INFORMATION access right.
            </param>
            <param name="hJob">
            A handle to the job. If this parameter is NULL, the function tests if the process is running under any job.
            If this parameter is not NULL, the handle must have the JOB_OBJECT_QUERY access right. For more information, see Job Object Security and Access Rights.
            </param>
            <param name="result">
            A pointer to a value that receives TRUE if the process is running in the job, and FALSE otherwise.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero.To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SetInformationJobObject(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.JOBOBJECTINFOCLASS,System.Void*,System.UInt32)">
            <summary>
            Sets limits for a job object.
            </summary>
            <param name="hJob">
            A handle to the job whose limits are being set. The <see cref="M:PInvoke.Kernel32.CreateJobObject(PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.String)" /> or OpenJobObject function returns this handle. The handle must have the JOB_OBJECT_SET_ATTRIBUTES access right. For more information, see Job Object Security and Access Rights.
            </param>
            <param name="jobObjectInfoClass">
            The information class for the limits to be set.
            </param>
            <param name="lpJobObjectInfo">T
            he limits or job state to be set for the job. The format of this data depends on the value of JobObjectInfoClass.
            </param>
            <param name="cbJobObjectInfoLength">
            The size of the job information being set, in bytes.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero.To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SetConsoleCtrlHandler(PInvoke.Kernel32.HandlerRoutine,System.Boolean)">
            <summary>
            Adds or removes an application-defined HandlerRoutine function from the list of handler
            functions for the calling process. If no handler function is specified, the function sets
            an inheritable attribute that determines whether the calling process ignores CTRL+C signals.
            </summary>
            <param name="handlerRoutine">
            A pointer to the application-defined HandlerRoutine function to be added or removed. This
            parameter can be NULL.
            </param>
            <param name="add">
            <para>
            If this parameter is TRUE, the handler is added; if it is FALSE, the handler is removed.
            </para>
            <para>
            If the HandlerRoutine parameter is NULL, a TRUE value causes the calling process to
            ignore CTRL+C input, and a FALSE value restores normal processing of CTRL+C input. This
            attribute of ignoring or processing CTRL+C is inherited by child processes.
            </para>
            </param>
            <returns>
            If the function succeeds, the return value is nonzero. If the function fails, the return
            value is zero.To get extended error information, call GetLastError.
            </returns>
            <remarks>
            <para>
            This function provides a similar notification for console application and services that
            WM_QUERYENDSESSION provides for graphical applications with a message pump. You could
            also use this function from a graphical application, but there is no guarantee it would
            arrive before the notification from WM_QUERYENDSESSION.
            </para>
            <para>
            Each console process has its own list of application-defined HandlerRoutine functions
            that handle CTRL+C and CTRL+BREAK signals. The handler functions also handle signals
            generated by the system when the user closes the console, logs off, or shuts down the
            system. Initially, the handler list for each process contains only a default handler
            function that calls the ExitProcess function. A console process adds or removes
            additional handler functions by calling the SetConsoleCtrlHandler function, which does
            not affect the list of handler functions for other processes. When a console process
            receives any of the control signals, its handler functions are called on a
            last-registered, first-called basis until one of the handlers returns TRUE. If none of
            the handlers returns TRUE, the default handler is called.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.SetThreadExecutionState(PInvoke.Kernel32.EXECUTION_STATE)">
            <summary>
            Enables an application to inform the system that it is in use, thereby preventing the system from entering sleep or turning off the display while the application is running.
            </summary>
            <param name="esFlags">The thread's execution requirements.</param>
            <returns>
            If the function succeeds, the return value is the previous thread execution state.
            If the function fails, the return value is <see cref="F:PInvoke.Kernel32.EXECUTION_STATE.None"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteProcessMemory(System.IntPtr,System.Void*,System.Void*,System.IntPtr,System.IntPtr*)">
            <summary>
            Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.
            </summary>
            <param name="hProcess">A handle to the process memory to be modified. The handle must have <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_VM_WRITE"/> and <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_VM_OPERATION"/> access to the process.</param>
            <param name="lpBaseAddress">A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</param>
            <param name="lpBuffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name="nSize">The number of bytes to be written to the specified process.</param>
            <param name="lpNumberOfBytesWritten">A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If <paramref name="lpNumberOfBytesWritten"/> is NULL, the parameter is ignored.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is 0 (zero). To get extended error information, call GetLastError. The function fails if the requested write operation crosses into an area of the process that is inaccessible.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ReadProcessMemory(System.IntPtr,System.Void*,System.Void*,System.IntPtr,System.IntPtr*)">
            <summary>
            Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.
            </summary>
            <param name="hProcess">A handle to the process with memory that is being read. The handle must have <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_VM_READ"/> access to the process.</param>
            <param name="lpBaseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
            <param name="lpBuffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name="nSize">The number of bytes to be read from the specified process.</param>
            <param name="lpNumberOfBytesRead">A pointer to a variable that receives the number of bytes transferred into the specified buffer. If <paramref name="lpNumberOfBytesRead"/> is NULL, the parameter is ignored.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is 0 (zero). To get extended error information, call GetLastError.
            The function fails if the requested read operation crosses into an area of the process that is inaccessible.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetStdHandle(PInvoke.Kernel32.StdHandle)">
            <summary>
            Retrieves a handle to the specified standard device (standard input, standard output, or standard error).
            </summary>
            <param name="nStdHandle">The standard device.</param>
            <returns>
            If the function succeeds, the return value is a handle to the specified device, or a redirected handle set by a previous call to <see cref="M:PInvoke.Kernel32.SetStdHandle(PInvoke.Kernel32.StdHandle,System.IntPtr)"/>. The handle has GENERIC_READ and GENERIC_WRITE access rights, unless the application has used <see cref="M:PInvoke.Kernel32.SetStdHandle(PInvoke.Kernel32.StdHandle,System.IntPtr)"/> to set a standard handle with lesser access.
            If the function fails, the return value is <see cref="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE"/>. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            If an application does not have associated standard handles, such as a service running on an interactive desktop, and has not redirected them, the return value is NULL.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SetStdHandle(PInvoke.Kernel32.StdHandle,System.IntPtr)">
            <summary>
            Sets the handle for the specified standard device (standard input, standard output, or standard error).
            </summary>
            <param name="nStdHandle">The standard device for which the handle is to be set.</param>
            <param name="nHandle">The handle for the standard device.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LockResource(System.IntPtr)">
            <summary>Retrieves a pointer to the specified resource in memory.</summary>
            <param name="hResData">
                A handle to the resource to be accessed. The <see cref="M:PInvoke.Kernel32.LoadResource(PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr)" /> function returns this
                handle.
            </param>
            <returns>
                If the loaded resource is available, the return value is a pointer to the first byte of the resource;
                otherwise, it is NULL.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LoadResource(PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr)">
            <summary>Retrieves a handle that can be used to obtain a pointer to the first byte of the specified resource in memory.</summary>
            <param name="hModule">
                A handle to the module whose executable file contains the resource. If hModule is
                <see cref="F:PInvoke.Kernel32.SafeLibraryHandle.Null" />, the system loads the resource from the module that was used to create the
                current process.
            </param>
            <param name="hResInfo">
                A handle to the resource to be loaded. This handle is returned by the
                FindResource or FindResourceEx function.
            </param>
            <returns>
                If the function succeeds, the return value is a handle to the data associated with the resource.
                <para>
                    If the function fails, the return value is NULL. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.DeviceIoControl(PInvoke.Kernel32.SafeObjectHandle,System.Int32,System.Void*,System.Int32,System.Void*,System.Int32,System.Int32@,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Sends a control code directly to a specified device driver, causing the corresponding device to perform the
                corresponding operation.
            </summary>
            <param name="hDevice">
                A handle to the device on which the operation is to be performed. The device is typically a
                volume, directory, file, or stream. To retrieve a device handle, use the CreateFile function.
            </param>
            <param name="dwIoControlCode">
                The control code for the operation. This value identifies the specific operation to be performed and the type of
                device on which to perform it.
                <para>
                    For a list of the control codes, see Remarks. The documentation for each control code provides usage details
                    for the <paramref name="inBuffer" />, <paramref name="nInBufferSize" />, <paramref name="outBuffer" />, and
                    <paramref name="nOutBufferSize" /> parameters.
                </para>
            </param>
            <param name="inBuffer">
                A pointer to the input buffer that contains the data required to perform the operation. The format of this data
                depends on the value of the <paramref name="dwIoControlCode" /> parameter.
                <para>
                    This parameter can be NULL if <paramref name="dwIoControlCode" /> specifies an operation that does not
                    require input data.
                </para>
            </param>
            <param name="nInBufferSize">The size of the input buffer, in bytes.</param>
            <param name="outBuffer">
                A pointer to the output buffer that is to receive the data returned by the operation. The format of this data
                depends on the value of the <paramref name="dwIoControlCode" /> parameter.
                <para>
                    This parameter can be NULL if <paramref name="dwIoControlCode" /> specifies an operation that does not return
                    data.
                </para>
            </param>
            <param name="nOutBufferSize">The size of the output buffer, in bytes.</param>
            <param name="pBytesReturned">
                A pointer to a variable that receives the size of the data stored in the output buffer, in bytes.
                <para>
                    If the output buffer is too small to receive any data, the call fails, <see cref="M:PInvoke.Kernel32.GetLastError" /> returns
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_INSUFFICIENT_BUFFER" />, and lpBytesReturned is zero.
                </para>
                <para>
                    If the output buffer is too small to hold all of the data but can hold some entries, some drivers will return
                    as much data as fits. In this case, the call fails, <see cref="M:PInvoke.Kernel32.GetLastError" /> returns
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_MORE_DATA" />, and lpBytesReturned indicates the amount of data received. Your
                    application should call DeviceIoControl again with the same operation, specifying a new starting point.
                </para>
                <para>
                    If <paramref name="lpOverlapped" /> is NULL, lpBytesReturned cannot be NULL. Even when an operation returns
                    no output data and lpOutBuffer is NULL, DeviceIoControl makes use of lpBytesReturned. After such an operation,
                    the value of lpBytesReturned is meaningless.
                </para>
                <para>
                    If <paramref name="lpOverlapped" /> is not NULL, lpBytesReturned can be NULL. If this parameter is not NULL
                    and the operation returns data, lpBytesReturned is meaningless until the overlapped operation has completed. To
                    retrieve the number of bytes returned, call GetOverlappedResult. If hDevice is associated with an I/O
                    completion port, you can retrieve the number of bytes returned by calling GetQueuedCompletionStatus.
                </para>
            </param>
            <param name="lpOverlapped">
                A pointer to an OVERLAPPED structure.
                <para>
                    If hDevice was opened without specifying <see cref="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_OVERLAPPED" />, lpOverlapped is
                    ignored.
                </para>
                <para>
                    If hDevice was opened with the <see cref="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_OVERLAPPED" /> flag, the operation is
                    performed as an overlapped (asynchronous) operation. In this case, lpOverlapped must point to a valid
                    OVERLAPPED structure that contains a handle to an event object. Otherwise, the function fails in unpredictable
                    ways.
                </para>
                <para>
                    For overlapped operations, DeviceIoControl returns immediately, and the event object is signaled when the
                    operation has been completed. Otherwise, the function does not return until the operation has been completed or
                    an error occurs.
                </para>
            </param>
            <returns>
                If the operation completes successfully, the return value is nonzero.
                <para>
                    If the operation fails or is pending, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SetSystemTime(PInvoke.Kernel32.SYSTEMTIME*)">
            <summary>
            Sets the current system time and date. The system time is expressed in Coordinated Universal Time (UTC).
            </summary>
            <param name="lpSystemTime">
            A pointer to a <see cref="T:PInvoke.Kernel32.SYSTEMTIME"/> structure that contains the new system date and time.
            The wDayOfWeek member of the <see cref="T:PInvoke.Kernel32.SYSTEMTIME"/> structure is ignored.</param>
            <returns>
                If the function succeeds, the return value is a nonzero value.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.Process32First(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>Retrieves information about the first process encountered in a system snapshot.</summary>
            <param name="hSnapshot">
                A handle to the snapshot returned from a previous call to the
                <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)" /> function.
            </param>
            <returns>
                The first <see cref="T:PInvoke.Kernel32.PROCESSENTRY32" /> if there was any or <see langword="null" /> otherwise (No values in
                the snapshot).
            </returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if any error occurs.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hSnapshot" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.Process32Next(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>Retrieves information about the next process encountered in a system snapshot.</summary>
            <param name="hSnapshot">
                A handle to the snapshot returned from a previous call to the
                <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)" /> function.
            </param>
            <returns>
                The next <see cref="T:PInvoke.Kernel32.PROCESSENTRY32" /> if there was any or <see langword="null" /> otherwise (No more values
                in the snapshot).
            </returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if any error occurs.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hSnapshot" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.Process32Enumerate(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>Retrieves information about next process encountered in a system snapshot.</summary>
            <param name="hSnapshot">
                A handle to the snapshot returned from a previous call to the
                <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)" /> function.
            </param>
            <returns>
                An enumeration of all the <see cref="T:PInvoke.Kernel32.PROCESSENTRY32" /> present in the snapshot.
            </returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if any error occurs.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hSnapshot" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.Module32First(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>Retrieves information about the first module encountered in a system snapshot.</summary>
            <param name="hSnapshot">
                A handle to the snapshot returned from a previous call to the
                <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)" /> function.
            </param>
            <returns>
                The first <see cref="T:PInvoke.Kernel32.MODULEENTRY32" /> if there was any or <see langword="null" /> otherwise (No values in
                the snapshot).
            </returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if any error occurs.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hSnapshot" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.Module32Next(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>Retrieves information about the next module encountered in a system snapshot.</summary>
            <param name="hSnapshot">
                A handle to the snapshot returned from a previous call to the
                <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)" /> function.
            </param>
            <returns>
                The next <see cref="T:PInvoke.Kernel32.MODULEENTRY32" /> if there was any or <see langword="null" /> otherwise (No more values
                in the snapshot).
            </returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if any error occurs.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hSnapshot" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.Module32Enumerate(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>Retrieves information about next module encountered in a system snapshot.</summary>
            <param name="hSnapshot">
                A handle to the snapshot returned from a previous call to the
                <see cref="M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)" /> function.
            </param>
            <returns>
                An enumeration of all the <see cref="T:PInvoke.Kernel32.MODULEENTRY32" /> present in the snapshot.
            </returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if any error occurs.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hSnapshot" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.Int32)">
            <summary>
            Allocates the specified number of bytes from the heap.
            </summary>
            <param name="uFlags">
            The memory allocation attributes. The default is the <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_FIXED"/> value. This parameter can be one or more of the following values, except for the incompatible combinations that are specifically noted.
            </param>
            <param name="uBytes">The number of bytes to allocate. If this parameter is zero and the <paramref name="uFlags"/> parameter specifies <see cref="F:PInvoke.Kernel32.LocalAllocFlags.LMEM_MOVEABLE"/>, the function returns a handle to a memory object that is marked as discarded.</param>
            <returns>
            If the function succeeds, the return value is a handle to the newly allocated memory object.
            If the function fails, the return value is NULL. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.Int32,PInvoke.Kernel32.LocalReAllocFlags)">
            <summary>
            Changes the size or the attributes of a specified local memory object. The size can increase or decrease.
            </summary>
            <param name="hMem">A handle to the local memory object to be reallocated. This handle is returned by either the <see cref="M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)"/> or <see cref="M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.LocalReAllocFlags)"/> function.</param>
            <param name="uBytes">The new size of the memory block, in bytes. If uFlags specifies <see cref="F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MODIFY"/>, this parameter is ignored.</param>
            <param name="uFlags">
            The reallocation options. If <see cref="F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MODIFY"/> is specified, the function modifies the attributes of the memory object only (the uBytes parameter is ignored.) Otherwise, the function reallocates the memory object.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the reallocated memory object.
            If the function fails, the return value is NULL. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            If LocalReAlloc fails, the original memory is not freed, and the original handle and pointer are still valid.
            If LocalReAlloc reallocates a fixed object, the value of the handle returned is the address of the first byte of the memory block. To access the memory, a process can simply cast the return value to a pointer.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.FindFirstFileEx(System.String,PInvoke.Kernel32.FINDEX_INFO_LEVELS,PInvoke.Kernel32.WIN32_FIND_DATA@,PInvoke.Kernel32.FINDEX_SEARCH_OPS,System.IntPtr,PInvoke.Kernel32.FindFirstFileExFlags)">
            <summary>
            Searches a directory for a file or subdirectory with a name and attributes that match those specified.
            For the most basic version of this function, see FindFirstFile.
            To perform this operation as a transacted operation, use the FindFirstFileTransacted function.
            </summary>
            <param name = "lpFileName">
            The directory or path, and the file name, which can include wildcard characters, for example, an asterisk (*) or a question mark (?).
            This parameter should not be NULL, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\).
            If the string ends with a wildcard, period, or directory name, the user must have access to the root and all subdirectories on the path.
            In the ANSI version of this function, the name is limited to MAX_PATH characters. To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming a File.
            </param>
            <param name = "fInfoLevelId">
            The information level of the returned data.
            This parameter is one of the <see cref = "T:PInvoke.Kernel32.FINDEX_INFO_LEVELS"/> enumeration values.
            </param>
            <param name = "lpFindFileData">
            A pointer to the buffer that receives the file data.
            The pointer type is determined by the level of information that is specified in the <paramref name = "fInfoLevelId"/> parameter.
            </param>
            <param name = "fSearchOp">
            The type of filtering to perform that is different from wildcard matching.
            This parameter is one of the <see cref = "T:PInvoke.Kernel32.FINDEX_SEARCH_OPS"/> enumeration values.
            </param>
            <param name = "lpSearchFilter">
            A pointer to the search criteria if the specified <paramref name = "fSearchOp"/> needs structured search information.
            At this time, none of the supported fSearchOp values require extended search information. Therefore, this pointer must be NULL.
            </param>
            <param name = "dwAdditionalFlags">Specifies additional flags that control the search.</param>
            <returns>
            If the function succeeds, the return value is a search handle used in a subsequent call to FindNextFile or FindClose, and the lpFindFileData parameter contains information about the first file or directory found.
            If the function fails or fails to locate files from the search string in the lpFileName parameter, the return value is INVALID_HANDLE_VALUE and the contents of lpFindFileData are indeterminate.To get extended error information, call the <see cref = "M:PInvoke.Kernel32.GetLastError"/> function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.IntPtr,System.Int32,System.Int32,System.Text.StringBuilder,System.Int32,System.IntPtr[])">
            <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested.
            </summary>
            <param name = "dwFlags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
            <param name = "lpSource">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name = "dwFlags"/> parameter.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name = "dwMessageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            </param>
            <param name = "dwLanguageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name = "lpBuffer">
            A pointer to a buffer that receives the null-terminated string that specifies the formatted message. If dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/>, the function allocates a buffer using the LocalAlloc function, and places the pointer to the buffer at the address specified in lpBuffer.
            This buffer cannot be larger than 64K bytes.
            </param>
            <param name = "nSize">
            If the <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> flag is not set, this parameter specifies the size of the output buffer, in TCHARs. If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> is set,
            this parameter specifies the minimum number of TCHARs to allocate for an output buffer.
            The output buffer cannot be larger than 64K bytes.
            </param>
            <param name = "Arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <returns>
            If the function succeeds, the return value is the number of TCHARs stored in the output buffer, excluding the terminating null character.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CancelIoEx(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr)">
            <summary>
                Marks any outstanding I/O operations for the specified file handle. The function only cancels I/O operations
                in the current process, regardless of which thread created the I/O operation.
            </summary>
            <param name = "hFile">A handle to the file.</param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> data structure that contains the data used for asynchronous I/O.
                <para>If this parameter is NULL, all I/O requests for the hFile parameter are canceled.</para>
                <para>
                    If this parameter is not NULL, only those specific I/O requests that were issued for the file with the
                    specified
                    <paramref name = "lpOverlapped"/> overlapped structure are marked as canceled, meaning that you can cancel one
                    or more requests, while the CancelIo function cancels all outstanding requests on a file handle.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is nonzero. The cancel operation for all pending I/O operations issued
                by the calling process for the specified file handle was successfully requested. The application must not free or
                reuse the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure associated with the canceled I/O operations until they have
                completed. The thread can use the GetOverlappedResult function to determine when the I/O operations themselves have
                been completed.
                <para>
                    If the function fails, the return value is 0 (zero). To get extended error information, call the
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/> function.
                </para>
                <para>
                    If this function cannot find a request to cancel, the return value is 0 (zero), and
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>
                    returns <see cref = "F:PInvoke.Win32ErrorCode.ERROR_NOT_FOUND"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
                Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file
                pointer if supported by the device.
                <para>
                    This function is designed for both synchronous and asynchronous operations. For a similar function designed
                    solely for asynchronous operation, see ReadFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive,
                socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
                <para>
                    For asynchronous read operations, hFile can be any handle that is opened with the FILE_FLAG_OVERLAPPED flag
                    by the CreateFile function, or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer that receives the data read from a file or device.
                <para>
                    This buffer must remain valid for the duration of the read operation. The caller must not use this buffer
                    until the read operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <param name = "lpNumberOfBytesRead">
                A pointer to the variable that receives the number of bytes read when using a synchronous hFile parameter. ReadFile
                sets this value to zero before doing any work or error checking. Use <see langword = "null"/> for this parameter if
                this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be <see langword = "null"/> only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise it can be <see langword = "null"/>.
                <para>
                    If hFile is opened with FILE_FLAG_OVERLAPPED, the <paramref name = "lpOverlapped"/> parameter must point to a
                    valid and unique <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure, otherwise the function can incorrectly report that the
                    read operation is complete.
                </para>
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start reading from the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the read operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.Nullable{System.Int32}@,System.IntPtr)">
            <summary>
                Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file
                pointer if supported by the device.
                <para>
                    This function is designed for both synchronous and asynchronous operations. For a similar function designed
                    solely for asynchronous operation, see ReadFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive,
                socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
                <para>
                    For asynchronous read operations, hFile can be any handle that is opened with the FILE_FLAG_OVERLAPPED flag
                    by the CreateFile function, or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer that receives the data read from a file or device.
                <para>
                    This buffer must remain valid for the duration of the read operation. The caller must not use this buffer
                    until the read operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <param name = "lpNumberOfBytesRead">
                A pointer to the variable that receives the number of bytes read when using a synchronous hFile parameter. ReadFile
                sets this value to zero before doing any work or error checking. Use <see langword = "null"/> for this parameter if
                this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be <see langword = "null"/> only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise it can be <see langword = "null"/>.
                <para>
                    If hFile is opened with FILE_FLAG_OVERLAPPED, the <paramref name = "lpOverlapped"/> parameter must point to a
                    valid and unique <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure, otherwise the function can incorrectly report that the
                    read operation is complete.
                </para>
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start reading from the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the read operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Nullable{System.Int32}@,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file
                pointer if supported by the device.
                <para>
                    This function is designed for both synchronous and asynchronous operations. For a similar function designed
                    solely for asynchronous operation, see ReadFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive,
                socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
                <para>
                    For asynchronous read operations, hFile can be any handle that is opened with the FILE_FLAG_OVERLAPPED flag
                    by the CreateFile function, or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer that receives the data read from a file or device.
                <para>
                    This buffer must remain valid for the duration of the read operation. The caller must not use this buffer
                    until the read operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <param name = "lpNumberOfBytesRead">
                A pointer to the variable that receives the number of bytes read when using a synchronous hFile parameter. ReadFile
                sets this value to zero before doing any work or error checking. Use <see langword = "null"/> for this parameter if
                this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be <see langword = "null"/> only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise it can be <see langword = "null"/>.
                <para>
                    If hFile is opened with FILE_FLAG_OVERLAPPED, the <paramref name = "lpOverlapped"/> parameter must point to a
                    valid and unique <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure, otherwise the function can incorrectly report that the
                    read operation is complete.
                </para>
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start reading from the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the read operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
                Writes data to the specified file or input/output (I/O) device.
                <para>
                    This function is designed for both synchronous and asynchronous operation. For a similar function designed
                    solely for asynchronous operation, see WriteFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
                <para>
                    For asynchronous write operations, hFile can be any handle opened with the CreateFile function using the
                    FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer containing the data to be written to the file or device.
                <para>
                    This buffer must remain valid for the duration of the write operation. The caller must not use this buffer
                    until the write operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <param name = "lpNumberOfBytesWritten">
                A pointer to the variable that receives the number of bytes written when using a synchronous hFile parameter.
                WriteFile sets this value to zero before doing any work or error checking. Use <see langword = "null"/>
                for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be NULL only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise this parameter can be NULL.
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start writing to the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
                <para>
                    To write to the end of file, specify both the Offset and OffsetHigh members of the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/>
                    structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function to open
                    hFile using FILE_APPEND_DATA access.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the write operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.Nullable{System.Int32}@,System.IntPtr)">
            <summary>
                Writes data to the specified file or input/output (I/O) device.
                <para>
                    This function is designed for both synchronous and asynchronous operation. For a similar function designed
                    solely for asynchronous operation, see WriteFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
                <para>
                    For asynchronous write operations, hFile can be any handle opened with the CreateFile function using the
                    FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer containing the data to be written to the file or device.
                <para>
                    This buffer must remain valid for the duration of the write operation. The caller must not use this buffer
                    until the write operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <param name = "lpNumberOfBytesWritten">
                A pointer to the variable that receives the number of bytes written when using a synchronous hFile parameter.
                WriteFile sets this value to zero before doing any work or error checking. Use <see langword = "null"/>
                for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be NULL only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise this parameter can be NULL.
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start writing to the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
                <para>
                    To write to the end of file, specify both the Offset and OffsetHigh members of the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/>
                    structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function to open
                    hFile using FILE_APPEND_DATA access.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the write operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Nullable{System.Int32}@,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Writes data to the specified file or input/output (I/O) device.
                <para>
                    This function is designed for both synchronous and asynchronous operation. For a similar function designed
                    solely for asynchronous operation, see WriteFileEx.
                </para>
            </summary>
            <param name = "hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
                <para>
                    For asynchronous write operations, hFile can be any handle opened with the CreateFile function using the
                    FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name = "lpBuffer">
                A pointer to the buffer containing the data to be written to the file or device.
                <para>
                    This buffer must remain valid for the duration of the write operation. The caller must not use this buffer
                    until the write operation is completed.
                </para>
            </param>
            <param name = "nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <param name = "lpNumberOfBytesWritten">
                A pointer to the variable that receives the number of bytes written when using a synchronous hFile parameter.
                WriteFile sets this value to zero before doing any work or error checking. Use <see langword = "null"/>
                for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be NULL only when the <paramref name = "lpOverlapped"/> parameter is not
                    <see langword = "null"/>.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise this parameter can be NULL.
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start writing to the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
                <para>
                    To write to the end of file, specify both the Offset and OffsetHigh members of the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/>
                    structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function to open
                    hFile using FILE_APPEND_DATA access.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword = "true"/>.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword = "false"/>. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref = "M:PInvoke.Kernel32.GetLastError"/> code <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/> is not a failure;
                    it designates the write operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateMutex(System.IntPtr,System.Boolean,System.String)">
            <summary>
            Creates or opens a named or unnamed mutex object.
            </summary>
            <param name = "lpMutexAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure. If this parameter is NULL, the handle cannot be inherited by child processes.
            The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a security descriptor for the new mutex. If <paramref name = "lpMutexAttributes"/> is NULL, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see Synchronization Object Security and Access Rights.
            </param>
            <param name = "bInitialOwner">
            If this value is TRUE and the caller created the mutex, the calling thread obtains initial ownership of the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the caller created the mutex, see the Return Values section.
            </param>
            <param name = "lpName">
            The name of the mutex object. The name is limited to MAX_PATH characters. Name comparison is case sensitive.
            If lpName matches the name of an existing named mutex object, this function requests the MUTEX_ALL_ACCESS access right. In this case, the bInitialOwner parameter is ignored because it has already been set by the creating process. If the lpMutexAttributes parameter is not NULL, it determines whether the handle can be inherited, but its security-descriptor member is ignored.
            If lpName is NULL, the mutex object is created without a name.
            If lpName matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the GetLastError function returns ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace.
            The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see Kernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.
            The object can be created in a private namespace. For more information, see Object Namespaces.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the newly created mutex object.
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, GetLastError returns ERROR_ALREADY_EXISTS, bInitialOwner is ignored, and the calling thread is not granted ownership. However, if the caller has limited access rights, the function will fail with ERROR_ACCESS_DENIED and the caller should use the OpenMutex function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateMutex(System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.Boolean,System.String)">
            <summary>
            Creates or opens a named or unnamed mutex object.
            </summary>
            <param name = "lpMutexAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure. If this parameter is NULL, the handle cannot be inherited by child processes.
            The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a security descriptor for the new mutex. If <paramref name = "lpMutexAttributes"/> is NULL, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see Synchronization Object Security and Access Rights.
            </param>
            <param name = "bInitialOwner">
            If this value is TRUE and the caller created the mutex, the calling thread obtains initial ownership of the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the caller created the mutex, see the Return Values section.
            </param>
            <param name = "lpName">
            The name of the mutex object. The name is limited to MAX_PATH characters. Name comparison is case sensitive.
            If lpName matches the name of an existing named mutex object, this function requests the MUTEX_ALL_ACCESS access right. In this case, the bInitialOwner parameter is ignored because it has already been set by the creating process. If the lpMutexAttributes parameter is not NULL, it determines whether the handle can be inherited, but its security-descriptor member is ignored.
            If lpName is NULL, the mutex object is created without a name.
            If lpName matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the GetLastError function returns ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace.
            The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see Kernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.
            The object can be created in a private namespace. For more information, see Object Namespaces.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the newly created mutex object.
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, GetLastError returns ERROR_ALREADY_EXISTS, bInitialOwner is ignored, and the calling thread is not granted ownership. However, if the caller has limited access rights, the function will fail with ERROR_ACCESS_DENIED and the caller should use the OpenMutex function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetSystemTime(System.IntPtr)">
            <summary>
            Retrieves the current system date and time. The system time is expressed in Coordinated Universal Time (UTC).
            To retrieve the current system date and time in local time, use the GetLocalTime function.
            </summary>
            <param name = "lpSystemTime">
            A pointer to a SYSTEMTIME structure to receive the current system date and time.
            The lpSystemTime parameter must not be NULL. Using NULL will result in an access violation.
            </param>
        </member>
        <member name="M:PInvoke.Kernel32.GetSystemTime(PInvoke.Kernel32.SYSTEMTIME@)">
            <summary>
            Retrieves the current system date and time. The system time is expressed in Coordinated Universal Time (UTC).
            To retrieve the current system date and time in local time, use the GetLocalTime function.
            </summary>
            <param name = "lpSystemTime">
            A pointer to a SYSTEMTIME structure to receive the current system date and time.
            The lpSystemTime parameter must not be NULL. Using NULL will result in an access violation.
            </param>
        </member>
        <member name="M:PInvoke.Kernel32.VerifyVersionInfo(System.IntPtr,PInvoke.Kernel32.VER_MASK,System.Int64)">
             <summary>
             Compares a set of operating system version requirements to the corresponding values for the currently
             running version of the system.This function is subject to manifest-based behavior.
             </summary>
             <param name = "lpVersionInformation">
             A pointer to an OSVERSIONINFOEX structure containing the operating system version requirements to compare. The <paramref name = "dwTypeMask"/>
             parameter indicates the members of this structure that contain information to compare.You must set the
             <see cref = "F:PInvoke.Kernel32.OSVERSIONINFOEX.dwOSVersionInfoSize"/> member of this structure to <code>Marshal.SizeOf(typeof(OSVERSIONINFOEX))</code>. You must
             also specify valid data for the members indicated by <paramref name = "dwTypeMask"/>. The function ignores structure members for which the
             corresponding <paramref name = "dwTypeMask"/> bit is not set
             </param>
             <param name = "dwTypeMask">A mask that indicates the members of the <see cref = "T:PInvoke.Kernel32.OSVERSIONINFOEX"/> structure to be tested.</param>
             <param name = "dwlConditionMask">The type of comparison to be used for each <paramref name = "lpVersionInformation"/> member being compared. To build this value,
             call the <see cref = "M:PInvoke.Kernel32.VerSetConditionMask(System.Int64,PInvoke.Kernel32.VER_MASK,PInvoke.Kernel32.VER_CONDITION)"/> function once for each <see cref = "T:PInvoke.Kernel32.OSVERSIONINFOEX"/> member being compared.</param>
             <returns>
             <para>
             If the currently running operating system satisfies the specified requirements, the return value is a nonzero value.
             </para>
             <para>
             If the current system does not satisfy the requirements, the return value is zero and <see cref = "M:PInvoke.Kernel32.GetLastError"/> returns <see cref = "F:PInvoke.Win32ErrorCode.ERROR_OLD_WIN_VERSION"/>.
             </para>
             <para>
             If the function fails, the return value is zero and <see cref = "M:PInvoke.Kernel32.GetLastError"/> returns an error code other than <see cref = "F:PInvoke.Win32ErrorCode.ERROR_OLD_WIN_VERSION"/>.
             </para>
             </returns>
             <remarks>
             <para>
             The <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function retrieves version information about the currently running operating system and compares it to the valid
             members of the <paramref name = "lpVersionInformation"/> structure. This enables you to easily determine the presence of a required set of
             operating system version conditions. It is preferable to use <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> rather than
             calling the GetVersionEx function to perform your own comparisons.
             </para>
             <para>
             Typically, <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> returns a nonzero value only if all specified tests succeed.
             However, major, minor, and service pack versions are tested in a hierarchical manner because the operating system version is a combination of
             these values. If a condition exists for the major version, it supersedes the conditions specified for minor version and service pack version.
             (You cannot test for major version greater than 5 and minor version less than or equal to 1. If you specify such a test, the function will
             change the request to test for a minor version greater than 1 because it is performing a greater than operation on the major version.)
             </para>
             <para>
             The function tests these values in this order: major version, minor version, and service pack version.The function continues testing values while
             they are equal, and stops when one of the values does not meet the specified condition.For example, if you test for a system greater than or
             equal to version 5.1 service pack 1, the test succeeds if the current version is 6.0. (The major version is greater than the specified version,
             so the testing stops.) In the same way, if you test for a system greater than or equal to version 5.1 service pack 1, the test succeeds if the
             current version is 5.2. (The minor version is greater than the specified versions, so the testing stops.) However, if you test for a system greater
             than or equal to version 5.1 service pack 1, the test fails if the current version is 5.0 service pack 2. (The minor version is not greater than
             the specified version, so the testing stops.)
             </para>
             <para>
             To verify a range of system versions, you must call <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> twice.For example, to verify
             that the system version is greater than 5.0 but less than or equal to 5.1, first call <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> to
             test that the major version is 5 and the minor version is greater than 0, then call <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
             again to test that the major version is 5 and the minor version is less than or equal to 1.
             </para>
             <para>
             Identifying the current operating system is usually not the best way to determine whether a particular operating system feature is present.
             This is because the operating system may have had new features added in a redistributable DLL. Rather than using GetVersionEx to determine the operating
             system platform or version number, test for the presence of the feature itself.
             </para>
             <para>
             To verify whether the current operating system is either the Media Center or Tablet PC version of Windows, call GetSystemMetrics.
             </para>
             <para>
             Windows 10:
                 <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> returns false when called by applications that do not have a
                 compatibility manifest for Windows 8.1 or Windows 10 if the <paramref name = "lpVersionInformation"/> parameter is set so that it specifies
                 Windows 8.1 or Windows 10, even when the current operating system version is Windows 8.1 or Windows 10. Specifically,
                 <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> has the following behavior:
            
                 If the application has no manifest, <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> behaves as
                     if the operation system version is Windows 8 (6.2).
                 If the application has a manifest that contains the GUID that corresponds to Windows 8.1, <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
                     behaves as if the operation system version is Windows 8.1 (6.3).
                 If the application has a manifest that contains the GUID that corresponds to Windows 10, <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
                     behaves as if the operation system version is Windows 10 (10.0).
             </para>
             </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX@,PInvoke.Kernel32.VER_MASK,System.Int64)">
             <summary>
             Compares a set of operating system version requirements to the corresponding values for the currently
             running version of the system.This function is subject to manifest-based behavior.
             </summary>
             <param name = "lpVersionInformation">
             A pointer to an OSVERSIONINFOEX structure containing the operating system version requirements to compare. The <paramref name = "dwTypeMask"/>
             parameter indicates the members of this structure that contain information to compare.You must set the
             <see cref = "F:PInvoke.Kernel32.OSVERSIONINFOEX.dwOSVersionInfoSize"/> member of this structure to <code>Marshal.SizeOf(typeof(OSVERSIONINFOEX))</code>. You must
             also specify valid data for the members indicated by <paramref name = "dwTypeMask"/>. The function ignores structure members for which the
             corresponding <paramref name = "dwTypeMask"/> bit is not set
             </param>
             <param name = "dwTypeMask">A mask that indicates the members of the <see cref = "T:PInvoke.Kernel32.OSVERSIONINFOEX"/> structure to be tested.</param>
             <param name = "dwlConditionMask">The type of comparison to be used for each <paramref name = "lpVersionInformation"/> member being compared. To build this value,
             call the <see cref = "M:PInvoke.Kernel32.VerSetConditionMask(System.Int64,PInvoke.Kernel32.VER_MASK,PInvoke.Kernel32.VER_CONDITION)"/> function once for each <see cref = "T:PInvoke.Kernel32.OSVERSIONINFOEX"/> member being compared.</param>
             <returns>
             <para>
             If the currently running operating system satisfies the specified requirements, the return value is a nonzero value.
             </para>
             <para>
             If the current system does not satisfy the requirements, the return value is zero and <see cref = "M:PInvoke.Kernel32.GetLastError"/> returns <see cref = "F:PInvoke.Win32ErrorCode.ERROR_OLD_WIN_VERSION"/>.
             </para>
             <para>
             If the function fails, the return value is zero and <see cref = "M:PInvoke.Kernel32.GetLastError"/> returns an error code other than <see cref = "F:PInvoke.Win32ErrorCode.ERROR_OLD_WIN_VERSION"/>.
             </para>
             </returns>
             <remarks>
             <para>
             The <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function retrieves version information about the currently running operating system and compares it to the valid
             members of the <paramref name = "lpVersionInformation"/> structure. This enables you to easily determine the presence of a required set of
             operating system version conditions. It is preferable to use <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> rather than
             calling the GetVersionEx function to perform your own comparisons.
             </para>
             <para>
             Typically, <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> returns a nonzero value only if all specified tests succeed.
             However, major, minor, and service pack versions are tested in a hierarchical manner because the operating system version is a combination of
             these values. If a condition exists for the major version, it supersedes the conditions specified for minor version and service pack version.
             (You cannot test for major version greater than 5 and minor version less than or equal to 1. If you specify such a test, the function will
             change the request to test for a minor version greater than 1 because it is performing a greater than operation on the major version.)
             </para>
             <para>
             The function tests these values in this order: major version, minor version, and service pack version.The function continues testing values while
             they are equal, and stops when one of the values does not meet the specified condition.For example, if you test for a system greater than or
             equal to version 5.1 service pack 1, the test succeeds if the current version is 6.0. (The major version is greater than the specified version,
             so the testing stops.) In the same way, if you test for a system greater than or equal to version 5.1 service pack 1, the test succeeds if the
             current version is 5.2. (The minor version is greater than the specified versions, so the testing stops.) However, if you test for a system greater
             than or equal to version 5.1 service pack 1, the test fails if the current version is 5.0 service pack 2. (The minor version is not greater than
             the specified version, so the testing stops.)
             </para>
             <para>
             To verify a range of system versions, you must call <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> twice.For example, to verify
             that the system version is greater than 5.0 but less than or equal to 5.1, first call <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> to
             test that the major version is 5 and the minor version is greater than 0, then call <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
             again to test that the major version is 5 and the minor version is less than or equal to 1.
             </para>
             <para>
             Identifying the current operating system is usually not the best way to determine whether a particular operating system feature is present.
             This is because the operating system may have had new features added in a redistributable DLL. Rather than using GetVersionEx to determine the operating
             system platform or version number, test for the presence of the feature itself.
             </para>
             <para>
             To verify whether the current operating system is either the Media Center or Tablet PC version of Windows, call GetSystemMetrics.
             </para>
             <para>
             Windows 10:
                 <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> returns false when called by applications that do not have a
                 compatibility manifest for Windows 8.1 or Windows 10 if the <paramref name = "lpVersionInformation"/> parameter is set so that it specifies
                 Windows 8.1 or Windows 10, even when the current operating system version is Windows 8.1 or Windows 10. Specifically,
                 <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> has the following behavior:
            
                 If the application has no manifest, <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> behaves as
                     if the operation system version is Windows 8 (6.2).
                 If the application has a manifest that contains the GUID that corresponds to Windows 8.1, <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
                     behaves as if the operation system version is Windows 8.1 (6.3).
                 If the application has a manifest that contains the GUID that corresponds to Windows 10, <see cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
                     behaves as if the operation system version is Windows 10 (10.0).
             </para>
             </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.IntPtr,System.Int32,System.Int32,System.IntPtr[],System.Int32)">
            <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested.
            </summary>
            <param name = "dwFlags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            The <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ARGUMENT_ARRAY"/> flag is always added
            and the <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> flag is always suppressed by this helper method
            </param>
            <param name = "lpSource">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name = "dwFlags"/> parameter.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name = "dwMessageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            </param>
            <param name = "dwLanguageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name = "Arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <param name = "maxAllowedBufferSize">The maximum size of the returned string. If exceeded, <c>null</c> is returned.</param>
            <returns>
            If the function succeeds, the return value is the number of TCHARs stored in the output buffer, excluding the terminating null character.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32)">
            <summary>Writes data synchronously to the specified file or input/output (I/O) device.</summary>
            <param name = "hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
            </param>
            <param name = "lpBuffer">A pointer to the buffer containing the data to be written to the file or device.</param>
            <param name = "nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <returns>The number of bytes written.</returns>
            <exception cref = "T:PInvoke.Win32Exception">Thrown if the native method return false (Write failed).</exception>
            <exception cref = "T:System.ArgumentNullException">If <paramref name = "hFile"/> is <see langword = "null"/>.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32)">
            <summary>Reads data synchronously from the specified file or input/output (I/O) device.</summary>
            <param name = "hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer,
                tape drive, socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
            </param>
            <param name = "lpBuffer">A pointer to the buffer that receives the data read from a file or device.</param>
            <param name = "nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <returns>The number of bytes read.</returns>
            <exception cref = "T:PInvoke.Win32Exception">Thrown if the native method return false (Read failed).</exception>
            <exception cref = "T:System.ArgumentNullException">If <paramref name = "hFile"/> is <see langword = "null"/>.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.TryGetErrorMessage(PInvoke.Kernel32.FormatMessageFlags,System.IntPtr,System.Int32,System.Int32,System.Text.StringBuilder,System.IntPtr[],System.String@)">
            <summary>
            Tries to get the error message text using the supplied buffer.
            </summary>
            <param name = "flags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
            <param name = "source">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name = "flags"/> parameter.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name = "messageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            </param>
            <param name = "languageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref = "F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name = "sb">The buffer to use for acquiring the message.</param>
            <param name = "arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <param name = "errorMsg">Receives the resulting error message.</param>
            <returns><c>true</c> if the attempt is successful; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateProcess(System.String,System.String,System.IntPtr,System.IntPtr,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.IntPtr,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)">
            <summary>
            Creates a new process and its primary thread. The new process runs in the security context of the calling process.
            If the calling process is impersonating another user, the new process uses the token for the calling process, not the impersonation token. To run the new process in the security context of the user represented by the impersonation token, use the <see cref = "M:PInvoke.Kernel32.CreateProcessAsUser(System.IntPtr,System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)"/> or CreateProcessWithLogonW function.
            </summary>
            <param name = "lpApplicationName">
            The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.
            The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.
            The lpApplicationName parameter can be NULL. In that case, the module name must be the first white space–delimited token in the lpCommandLine string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways.
            See MSDN docs for more information.
            </param>
            <param name = "lpCommandLine">
            The command line to be executed. The maximum length of this string is 32K characters. If lpApplicationName is NULL, the module name portion of lpCommandLine is limited to MAX_PATH characters.
            The Unicode version of this function, CreateProcessAsUserW, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a const variable or a literal string). If this parameter is a constant string, the function may cause an access violation.
            The lpCommandLine parameter can be NULL. In that case, the function uses the string pointed to by lpApplicationName as the command line.
            If both lpApplicationName and lpCommandLine are non-NULL, *lpApplicationName specifies the module to execute, and *lpCommandLine specifies the command line. The new process can use GetCommandLine to retrieve the entire command line. Console processes written in C can use the argc and argv arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.
            If lpApplicationName is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the lpApplicationName parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended.
            See MSDN docs for more information.
            </param>
            <param name = "lpProcessAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If lpProcessAttributes is NULL or lpSecurityDescriptor is NULL, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.
            </param>
            <param name = "lpThreadAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If lpThreadAttributes is NULL or lpSecurityDescriptor is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller.
            </param>
            <param name = "bInheritHandles">
            If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
            Terminal Services:  You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.
            </param>
            <param name = "dwCreationFlags">
            The flags that control the priority class and the creation of the process. For a list of values, see Process Creation Flags.
            This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see GetPriorityClass. If none of the priority class flags is specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default priority class of the calling process.
            </param>
            <param name = "lpEnvironment">
            A pointer to an environment block for the new process. If this parameter is NULL, the new process uses the environment of the calling process.
            An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:
            name=value\0
            Because the equal sign is used as a separator, it must not be used in the name of an environment variable.
            An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, be sure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT. If this parameter is NULL and the environment block of the parent process contains Unicode characters, you must also ensure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT.
            The ANSI version of this function, CreateProcessAsUserA fails if the total size of the environment block for the process exceeds 32,767 characters.
            Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.
            See MSDN docs for more information.
            </param>
            <param name = "lpCurrentDirectory">
            The full path to the current directory for the process. The string can also specify a UNC path.
            If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)
            </param>
            <param name = "lpStartupInfo">
            A pointer to a <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure.
            The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the lpDesktop member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in Process Connection to a Window Station.
            To set extended attributes, use a <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure and specify <see cref = "F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT"/> in the <paramref name = "dwCreationFlags"/> parameter.
            Handles in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> must be closed with CloseHandle when they are no longer needed.
            Important  The caller is responsible for ensuring that the standard handle fields in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the dwFlags member specifies <see cref = "F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>. Incorrect values can cause the child process to misbehave or crash. Use the Application Verifier runtime verification tool to detect invalid handles.
            </param>
            <param name = "lpProcessInformation">
            A pointer to a <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> structure that receives identification information about the new process.
            Handles in <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> must be closed with CloseHandle when they are no longer needed.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateProcess(System.String,System.String,System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.IntPtr,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)">
            <summary>
            Creates a new process and its primary thread. The new process runs in the security context of the calling process.
            If the calling process is impersonating another user, the new process uses the token for the calling process, not the impersonation token. To run the new process in the security context of the user represented by the impersonation token, use the <see cref = "M:PInvoke.Kernel32.CreateProcessAsUser(System.IntPtr,System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)"/> or CreateProcessWithLogonW function.
            </summary>
            <param name = "lpApplicationName">
            The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.
            The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.
            The lpApplicationName parameter can be NULL. In that case, the module name must be the first white space–delimited token in the lpCommandLine string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways.
            See MSDN docs for more information.
            </param>
            <param name = "lpCommandLine">
            The command line to be executed. The maximum length of this string is 32K characters. If lpApplicationName is NULL, the module name portion of lpCommandLine is limited to MAX_PATH characters.
            The Unicode version of this function, CreateProcessAsUserW, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a const variable or a literal string). If this parameter is a constant string, the function may cause an access violation.
            The lpCommandLine parameter can be NULL. In that case, the function uses the string pointed to by lpApplicationName as the command line.
            If both lpApplicationName and lpCommandLine are non-NULL, *lpApplicationName specifies the module to execute, and *lpCommandLine specifies the command line. The new process can use GetCommandLine to retrieve the entire command line. Console processes written in C can use the argc and argv arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.
            If lpApplicationName is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the lpApplicationName parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended.
            See MSDN docs for more information.
            </param>
            <param name = "lpProcessAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If lpProcessAttributes is NULL or lpSecurityDescriptor is NULL, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.
            </param>
            <param name = "lpThreadAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If lpThreadAttributes is NULL or lpSecurityDescriptor is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller.
            </param>
            <param name = "bInheritHandles">
            If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
            Terminal Services:  You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.
            </param>
            <param name = "dwCreationFlags">
            The flags that control the priority class and the creation of the process. For a list of values, see Process Creation Flags.
            This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see GetPriorityClass. If none of the priority class flags is specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default priority class of the calling process.
            </param>
            <param name = "lpEnvironment">
            A pointer to an environment block for the new process. If this parameter is NULL, the new process uses the environment of the calling process.
            An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:
            name=value\0
            Because the equal sign is used as a separator, it must not be used in the name of an environment variable.
            An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, be sure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT. If this parameter is NULL and the environment block of the parent process contains Unicode characters, you must also ensure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT.
            The ANSI version of this function, CreateProcessAsUserA fails if the total size of the environment block for the process exceeds 32,767 characters.
            Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.
            See MSDN docs for more information.
            </param>
            <param name = "lpCurrentDirectory">
            The full path to the current directory for the process. The string can also specify a UNC path.
            If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)
            </param>
            <param name = "lpStartupInfo">
            A pointer to a <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure.
            The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the lpDesktop member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in Process Connection to a Window Station.
            To set extended attributes, use a <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure and specify <see cref = "F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT"/> in the <paramref name = "dwCreationFlags"/> parameter.
            Handles in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> must be closed with CloseHandle when they are no longer needed.
            Important  The caller is responsible for ensuring that the standard handle fields in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the dwFlags member specifies <see cref = "F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>. Incorrect values can cause the child process to misbehave or crash. Use the Application Verifier runtime verification tool to detect invalid handles.
            </param>
            <param name = "lpProcessInformation">
            A pointer to a <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> structure that receives identification information about the new process.
            Handles in <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> must be closed with CloseHandle when they are no longer needed.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateProcess(System.String,System.String,System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)">
            <summary>
            Creates a new process and its primary thread. The new process runs in the security context of the calling process.
            If the calling process is impersonating another user, the new process uses the token for the calling process, not the impersonation token. To run the new process in the security context of the user represented by the impersonation token, use the <see cref = "M:PInvoke.Kernel32.CreateProcessAsUser(System.IntPtr,System.String,System.String,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)"/> or CreateProcessWithLogonW function.
            </summary>
            <param name = "lpApplicationName">
            The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.
            The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.
            The lpApplicationName parameter can be NULL. In that case, the module name must be the first white space–delimited token in the lpCommandLine string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways.
            See MSDN docs for more information.
            </param>
            <param name = "lpCommandLine">
            The command line to be executed. The maximum length of this string is 32K characters. If lpApplicationName is NULL, the module name portion of lpCommandLine is limited to MAX_PATH characters.
            The Unicode version of this function, CreateProcessAsUserW, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a const variable or a literal string). If this parameter is a constant string, the function may cause an access violation.
            The lpCommandLine parameter can be NULL. In that case, the function uses the string pointed to by lpApplicationName as the command line.
            If both lpApplicationName and lpCommandLine are non-NULL, *lpApplicationName specifies the module to execute, and *lpCommandLine specifies the command line. The new process can use GetCommandLine to retrieve the entire command line. Console processes written in C can use the argc and argv arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.
            If lpApplicationName is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the lpApplicationName parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended.
            See MSDN docs for more information.
            </param>
            <param name = "lpProcessAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If lpProcessAttributes is NULL or lpSecurityDescriptor is NULL, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.
            </param>
            <param name = "lpThreadAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If lpThreadAttributes is NULL or lpSecurityDescriptor is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller.
            </param>
            <param name = "bInheritHandles">
            If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
            Terminal Services:  You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.
            </param>
            <param name = "dwCreationFlags">
            The flags that control the priority class and the creation of the process. For a list of values, see Process Creation Flags.
            This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see GetPriorityClass. If none of the priority class flags is specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default priority class of the calling process.
            </param>
            <param name = "lpEnvironment">
            A pointer to an environment block for the new process. If this parameter is NULL, the new process uses the environment of the calling process.
            An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:
            name=value\0
            Because the equal sign is used as a separator, it must not be used in the name of an environment variable.
            An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, be sure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT. If this parameter is NULL and the environment block of the parent process contains Unicode characters, you must also ensure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT.
            The ANSI version of this function, CreateProcessAsUserA fails if the total size of the environment block for the process exceeds 32,767 characters.
            Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.
            See MSDN docs for more information.
            </param>
            <param name = "lpCurrentDirectory">
            The full path to the current directory for the process. The string can also specify a UNC path.
            If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)
            </param>
            <param name = "lpStartupInfo">
            A pointer to a <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure.
            The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the lpDesktop member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in Process Connection to a Window Station.
            To set extended attributes, use a <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure and specify <see cref = "F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT"/> in the <paramref name = "dwCreationFlags"/> parameter.
            Handles in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> must be closed with CloseHandle when they are no longer needed.
            Important  The caller is responsible for ensuring that the standard handle fields in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the dwFlags member specifies <see cref = "F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>. Incorrect values can cause the child process to misbehave or crash. Use the Application Verifier runtime verification tool to detect invalid handles.
            </param>
            <param name = "lpProcessInformation">
            A pointer to a <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> structure that receives identification information about the new process.
            Handles in <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> must be closed with CloseHandle when they are no longer needed.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateProcessAsUser(System.IntPtr,System.String,System.String,System.IntPtr,System.IntPtr,System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.IntPtr,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)">
            <summary>
            Creates a new process and its primary thread. The new process runs in the security context of the user represented by the specified token.
            Typically, the process that calls the CreateProcessAsUser function must have the SE_INCREASE_QUOTA_NAME privilege and may require the SE_ASSIGNPRIMARYTOKEN_NAME privilege if the token is not assignable. If this function fails with ERROR_PRIVILEGE_NOT_HELD (1314), use the CreateProcessWithLogonW function instead. CreateProcessWithLogonW requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use CreateProcessWithLogonW to create a process with alternate credentials.
            </summary>
            <param name = "hToken">
            A handle to the primary token that represents a user. The handle must have the TOKEN_QUERY, TOKEN_DUPLICATE, and TOKEN_ASSIGN_PRIMARY access rights. For more information, see Access Rights for Access-Token Objects. The user represented by the token must have read and execute access to the application specified by the <paramref name = "lpApplicationName"/> or the <paramref name = "lpCommandLine"/> parameter.
            To get a primary token that represents the specified user, call the LogonUser function. Alternatively, you can call the DuplicateTokenEx function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.
            If hToken is a restricted version of the caller's primary token, the SE_ASSIGNPRIMARYTOKEN_NAME privilege is not required. If the necessary privileges are not already enabled, CreateProcessAsUser enables them for the duration of the call. For more information, see Running with Special Privileges.
            Terminal Services:  The process is run in the session specified in the token. By default, this is the same session that called LogonUser. To change the session, use the SetTokenInformation function.
            </param>
            <param name = "lpApplicationName">
            The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.
            The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.
            The lpApplicationName parameter can be NULL. In that case, the module name must be the first white space–delimited token in the lpCommandLine string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways.
            See MSDN docs for more information.
            </param>
            <param name = "lpCommandLine">
            The command line to be executed. The maximum length of this string is 32K characters. If lpApplicationName is NULL, the module name portion of lpCommandLine is limited to MAX_PATH characters.
            The Unicode version of this function, CreateProcessAsUserW, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a const variable or a literal string). If this parameter is a constant string, the function may cause an access violation.
            The lpCommandLine parameter can be NULL. In that case, the function uses the string pointed to by lpApplicationName as the command line.
            If both lpApplicationName and lpCommandLine are non-NULL, *lpApplicationName specifies the module to execute, and *lpCommandLine specifies the command line. The new process can use GetCommandLine to retrieve the entire command line. Console processes written in C can use the argc and argv arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.
            If lpApplicationName is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the lpApplicationName parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended.
            See MSDN docs for more information.
            </param>
            <param name = "lpProcessAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If lpProcessAttributes is NULL or lpSecurityDescriptor is NULL, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.
            </param>
            <param name = "lpThreadAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If lpThreadAttributes is NULL or lpSecurityDescriptor is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller.
            </param>
            <param name = "bInheritHandles">
            If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
            Terminal Services:  You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.
            </param>
            <param name = "dwCreationFlags">
            The flags that control the priority class and the creation of the process. For a list of values, see Process Creation Flags.
            This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see GetPriorityClass. If none of the priority class flags is specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default priority class of the calling process.
            </param>
            <param name = "lpEnvironment">
            A pointer to an environment block for the new process. If this parameter is NULL, the new process uses the environment of the calling process.
            An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:
            name=value\0
            Because the equal sign is used as a separator, it must not be used in the name of an environment variable.
            An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, be sure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT. If this parameter is NULL and the environment block of the parent process contains Unicode characters, you must also ensure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT.
            The ANSI version of this function, CreateProcessAsUserA fails if the total size of the environment block for the process exceeds 32,767 characters.
            Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.
            See MSDN docs for more information.
            </param>
            <param name = "lpCurrentDirectory">
            The full path to the current directory for the process. The string can also specify a UNC path.
            If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)
            </param>
            <param name = "lpStartupInfo">
            A pointer to a <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure.
            The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the lpDesktop member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in Process Connection to a Window Station.
            To set extended attributes, use a <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure and specify <see cref = "F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT"/> in the <paramref name = "dwCreationFlags"/> parameter.
            Handles in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> must be closed with CloseHandle when they are no longer needed.
            Important  The caller is responsible for ensuring that the standard handle fields in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the dwFlags member specifies <see cref = "F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>. Incorrect values can cause the child process to misbehave or crash. Use the Application Verifier runtime verification tool to detect invalid handles.
            </param>
            <param name = "lpProcessInformation">
            A pointer to a <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> structure that receives identification information about the new process.
            Handles in <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> must be closed with CloseHandle when they are no longer needed.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateProcessAsUser(System.IntPtr,System.String,System.String,System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.IntPtr,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)">
            <summary>
            Creates a new process and its primary thread. The new process runs in the security context of the user represented by the specified token.
            Typically, the process that calls the CreateProcessAsUser function must have the SE_INCREASE_QUOTA_NAME privilege and may require the SE_ASSIGNPRIMARYTOKEN_NAME privilege if the token is not assignable. If this function fails with ERROR_PRIVILEGE_NOT_HELD (1314), use the CreateProcessWithLogonW function instead. CreateProcessWithLogonW requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use CreateProcessWithLogonW to create a process with alternate credentials.
            </summary>
            <param name = "hToken">
            A handle to the primary token that represents a user. The handle must have the TOKEN_QUERY, TOKEN_DUPLICATE, and TOKEN_ASSIGN_PRIMARY access rights. For more information, see Access Rights for Access-Token Objects. The user represented by the token must have read and execute access to the application specified by the <paramref name = "lpApplicationName"/> or the <paramref name = "lpCommandLine"/> parameter.
            To get a primary token that represents the specified user, call the LogonUser function. Alternatively, you can call the DuplicateTokenEx function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.
            If hToken is a restricted version of the caller's primary token, the SE_ASSIGNPRIMARYTOKEN_NAME privilege is not required. If the necessary privileges are not already enabled, CreateProcessAsUser enables them for the duration of the call. For more information, see Running with Special Privileges.
            Terminal Services:  The process is run in the session specified in the token. By default, this is the same session that called LogonUser. To change the session, use the SetTokenInformation function.
            </param>
            <param name = "lpApplicationName">
            The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.
            The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.
            The lpApplicationName parameter can be NULL. In that case, the module name must be the first white space–delimited token in the lpCommandLine string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways.
            See MSDN docs for more information.
            </param>
            <param name = "lpCommandLine">
            The command line to be executed. The maximum length of this string is 32K characters. If lpApplicationName is NULL, the module name portion of lpCommandLine is limited to MAX_PATH characters.
            The Unicode version of this function, CreateProcessAsUserW, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a const variable or a literal string). If this parameter is a constant string, the function may cause an access violation.
            The lpCommandLine parameter can be NULL. In that case, the function uses the string pointed to by lpApplicationName as the command line.
            If both lpApplicationName and lpCommandLine are non-NULL, *lpApplicationName specifies the module to execute, and *lpCommandLine specifies the command line. The new process can use GetCommandLine to retrieve the entire command line. Console processes written in C can use the argc and argv arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.
            If lpApplicationName is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the lpApplicationName parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended.
            See MSDN docs for more information.
            </param>
            <param name = "lpProcessAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If lpProcessAttributes is NULL or lpSecurityDescriptor is NULL, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.
            </param>
            <param name = "lpThreadAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If lpThreadAttributes is NULL or lpSecurityDescriptor is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller.
            </param>
            <param name = "bInheritHandles">
            If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
            Terminal Services:  You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.
            </param>
            <param name = "dwCreationFlags">
            The flags that control the priority class and the creation of the process. For a list of values, see Process Creation Flags.
            This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see GetPriorityClass. If none of the priority class flags is specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default priority class of the calling process.
            </param>
            <param name = "lpEnvironment">
            A pointer to an environment block for the new process. If this parameter is NULL, the new process uses the environment of the calling process.
            An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:
            name=value\0
            Because the equal sign is used as a separator, it must not be used in the name of an environment variable.
            An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, be sure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT. If this parameter is NULL and the environment block of the parent process contains Unicode characters, you must also ensure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT.
            The ANSI version of this function, CreateProcessAsUserA fails if the total size of the environment block for the process exceeds 32,767 characters.
            Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.
            See MSDN docs for more information.
            </param>
            <param name = "lpCurrentDirectory">
            The full path to the current directory for the process. The string can also specify a UNC path.
            If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)
            </param>
            <param name = "lpStartupInfo">
            A pointer to a <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure.
            The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the lpDesktop member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in Process Connection to a Window Station.
            To set extended attributes, use a <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure and specify <see cref = "F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT"/> in the <paramref name = "dwCreationFlags"/> parameter.
            Handles in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> must be closed with CloseHandle when they are no longer needed.
            Important  The caller is responsible for ensuring that the standard handle fields in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the dwFlags member specifies <see cref = "F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>. Incorrect values can cause the child process to misbehave or crash. Use the Application Verifier runtime verification tool to detect invalid handles.
            </param>
            <param name = "lpProcessInformation">
            A pointer to a <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> structure that receives identification information about the new process.
            Handles in <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> must be closed with CloseHandle when they are no longer needed.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateProcessAsUser(System.IntPtr,System.String,System.String,System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.Boolean,PInvoke.Kernel32.CreateProcessFlags,System.Void*,System.String,PInvoke.Kernel32.STARTUPINFO@,PInvoke.Kernel32.PROCESS_INFORMATION@)">
            <summary>
            Creates a new process and its primary thread. The new process runs in the security context of the user represented by the specified token.
            Typically, the process that calls the CreateProcessAsUser function must have the SE_INCREASE_QUOTA_NAME privilege and may require the SE_ASSIGNPRIMARYTOKEN_NAME privilege if the token is not assignable. If this function fails with ERROR_PRIVILEGE_NOT_HELD (1314), use the CreateProcessWithLogonW function instead. CreateProcessWithLogonW requires no special privileges, but the specified user account must be allowed to log on interactively. Generally, it is best to use CreateProcessWithLogonW to create a process with alternate credentials.
            </summary>
            <param name = "hToken">
            A handle to the primary token that represents a user. The handle must have the TOKEN_QUERY, TOKEN_DUPLICATE, and TOKEN_ASSIGN_PRIMARY access rights. For more information, see Access Rights for Access-Token Objects. The user represented by the token must have read and execute access to the application specified by the <paramref name = "lpApplicationName"/> or the <paramref name = "lpCommandLine"/> parameter.
            To get a primary token that represents the specified user, call the LogonUser function. Alternatively, you can call the DuplicateTokenEx function to convert an impersonation token into a primary token. This allows a server application that is impersonating a client to create a process that has the security context of the client.
            If hToken is a restricted version of the caller's primary token, the SE_ASSIGNPRIMARYTOKEN_NAME privilege is not required. If the necessary privileges are not already enabled, CreateProcessAsUser enables them for the duration of the call. For more information, see Running with Special Privileges.
            Terminal Services:  The process is run in the session specified in the token. By default, this is the same session that called LogonUser. To change the session, use the SetTokenInformation function.
            </param>
            <param name = "lpApplicationName">
            The name of the module to be executed. This module can be a Windows-based application. It can be some other type of module (for example, MS-DOS or OS/2) if the appropriate subsystem is available on the local computer.
            The string can specify the full path and file name of the module to execute or it can specify a partial name. In the case of a partial name, the function uses the current drive and current directory to complete the specification. The function will not use the search path. This parameter must include the file name extension; no default extension is assumed.
            The lpApplicationName parameter can be NULL. In that case, the module name must be the first white space–delimited token in the lpCommandLine string. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin; otherwise, the file name is ambiguous. For example, consider the string "c:\program files\sub dir\program name". This string can be interpreted in a number of ways.
            See MSDN docs for more information.
            </param>
            <param name = "lpCommandLine">
            The command line to be executed. The maximum length of this string is 32K characters. If lpApplicationName is NULL, the module name portion of lpCommandLine is limited to MAX_PATH characters.
            The Unicode version of this function, CreateProcessAsUserW, can modify the contents of this string. Therefore, this parameter cannot be a pointer to read-only memory (such as a const variable or a literal string). If this parameter is a constant string, the function may cause an access violation.
            The lpCommandLine parameter can be NULL. In that case, the function uses the string pointed to by lpApplicationName as the command line.
            If both lpApplicationName and lpCommandLine are non-NULL, *lpApplicationName specifies the module to execute, and *lpCommandLine specifies the command line. The new process can use GetCommandLine to retrieve the entire command line. Console processes written in C can use the argc and argv arguments to parse the command line. Because argv[0] is the module name, C programmers generally repeat the module name as the first token in the command line.
            If lpApplicationName is NULL, the first white space–delimited token of the command line specifies the module name. If you are using a long file name that contains a space, use quoted strings to indicate where the file name ends and the arguments begin (see the explanation for the lpApplicationName parameter). If the file name does not contain an extension, .exe is appended. Therefore, if the file name extension is .com, this parameter must include the .com extension. If the file name ends in a period (.) with no extension, or if the file name contains a path, .exe is not appended.
            See MSDN docs for more information.
            </param>
            <param name = "lpProcessAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new process object and determines whether child processes can inherit the returned handle to the process. If lpProcessAttributes is NULL or lpSecurityDescriptor is NULL, the process gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller, in which case the process may not be opened again after it is run. The process handle is valid and will continue to have full access rights.
            </param>
            <param name = "lpThreadAttributes">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a security descriptor for the new thread object and determines whether child processes can inherit the returned handle to the thread. If lpThreadAttributes is NULL or lpSecurityDescriptor is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The default security descriptor is that of the user referenced in the hToken parameter. This security descriptor may not allow access for the caller.
            </param>
            <param name = "bInheritHandles">
            If this parameter is TRUE, each inheritable handle in the calling process is inherited by the new process. If the parameter is FALSE, the handles are not inherited. Note that inherited handles have the same value and access rights as the original handles.
            Terminal Services:  You cannot inherit handles across sessions. Additionally, if this parameter is TRUE, you must create the process in the same session as the caller.
            </param>
            <param name = "dwCreationFlags">
            The flags that control the priority class and the creation of the process. For a list of values, see Process Creation Flags.
            This parameter also controls the new process's priority class, which is used to determine the scheduling priorities of the process's threads. For a list of values, see GetPriorityClass. If none of the priority class flags is specified, the priority class defaults to NORMAL_PRIORITY_CLASS unless the priority class of the creating process is IDLE_PRIORITY_CLASS or BELOW_NORMAL_PRIORITY_CLASS. In this case, the child process receives the default priority class of the calling process.
            </param>
            <param name = "lpEnvironment">
            A pointer to an environment block for the new process. If this parameter is NULL, the new process uses the environment of the calling process.
            An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form:
            name=value\0
            Because the equal sign is used as a separator, it must not be used in the name of an environment variable.
            An environment block can contain either Unicode or ANSI characters. If the environment block pointed to by lpEnvironment contains Unicode characters, be sure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT. If this parameter is NULL and the environment block of the parent process contains Unicode characters, you must also ensure that dwCreationFlags includes CREATE_UNICODE_ENVIRONMENT.
            The ANSI version of this function, CreateProcessAsUserA fails if the total size of the environment block for the process exceeds 32,767 characters.
            Note that an ANSI environment block is terminated by two zero bytes: one for the last string, one more to terminate the block. A Unicode environment block is terminated by four zero bytes: two for the last string, two more to terminate the block.
            See MSDN docs for more information.
            </param>
            <param name = "lpCurrentDirectory">
            The full path to the current directory for the process. The string can also specify a UNC path.
            If this parameter is NULL, the new process will have the same current drive and directory as the calling process. (This feature is provided primarily for shells that need to start an application and specify its initial drive and working directory.)
            </param>
            <param name = "lpStartupInfo">
            A pointer to a <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure.
            The user must have full access to both the specified window station and desktop. If you want the process to be interactive, specify winsta0\default. If the lpDesktop member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, "", the new process connects to a window station using the rules described in Process Connection to a Window Station.
            To set extended attributes, use a <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure and specify <see cref = "F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT"/> in the <paramref name = "dwCreationFlags"/> parameter.
            Handles in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> or <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> must be closed with CloseHandle when they are no longer needed.
            Important  The caller is responsible for ensuring that the standard handle fields in <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> contain valid handle values. These fields are copied unchanged to the child process without validation, even when the dwFlags member specifies <see cref = "F:PInvoke.Kernel32.StartupInfoFlags.STARTF_USESTDHANDLES"/>. Incorrect values can cause the child process to misbehave or crash. Use the Application Verifier runtime verification tool to detect invalid handles.
            </param>
            <param name = "lpProcessInformation">
            A pointer to a <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> structure that receives identification information about the new process.
            Handles in <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION"/> must be closed with CloseHandle when they are no longer needed.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetStartupInfo(System.IntPtr)">
            <summary>
            Retrieves the contents of the <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> structure that was specified when the calling process was created.
            </summary>
            <param name = "lpStartupInfo">
            A pointer to a <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> structure that receives the startup information.
            </param>
            <remarks>
            This function does not return a value, and does not fail.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetStartupInfo(PInvoke.Kernel32.STARTUPINFO@)">
            <summary>
            Retrieves the contents of the <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> structure that was specified when the calling process was created.
            </summary>
            <param name = "lpStartupInfo">
            A pointer to a <see cref = "T:PInvoke.Kernel32.STARTUPINFO"/> structure that receives the startup information.
            </param>
            <remarks>
            This function does not return a value, and does not fail.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.InitializeProcThreadAttributeList(System.IntPtr,System.Int32,System.UInt32,System.IntPtr@)">
            <summary>
            Initializes the specified list of attributes for process and thread creation.
            </summary>
            <param name = "lpAttributeList">
            The attribute list. This parameter can be NULL to determine the buffer size required to support the specified number of attributes.
            </param>
            <param name = "dwAttributeCount">
            The count of attributes to be added to the list.
            </param>
            <param name = "dwFlags">
            This parameter is reserved and must be zero.
            </param>
            <param name = "lpSize">
            If lpAttributeList is not NULL, this parameter specifies the size in bytes of the lpAttributeList buffer on input. On output, this parameter receives the size in bytes of the initialized attribute list.
            If lpAttributeList is NULL, this parameter receives the required buffer size in bytes.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            First, call this function with the <paramref name = "dwAttributeCount"/> parameter set to the maximum number of attributes you will be using and the lpAttributeList to NULL. The function returns the required buffer size in bytes in the lpSize parameter. Allocate enough space for the data in the lpAttributeList buffer and call the function again to initialize the buffer.
            To add attributes to the list, call the <see cref = "M:PInvoke.Kernel32.UpdateProcThreadAttribute(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*,System.UInt32,System.UInt32@,System.Void*,System.IntPtr,System.IntPtr@,System.IntPtr@)"/> function. To specify these attributes when creating a process, specify <see cref = "F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT"/> in the dwCreationFlag parameter and a <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure in the lpStartupInfo parameter. Note that you can specify the same <see cref = "T:PInvoke.Kernel32.STARTUPINFOEX"/> structure to multiple child processes.
            When you have finished using the list, call the <see cref = "M:PInvoke.Kernel32.DeleteProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*)"/> function.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.UpdateProcThreadAttribute(System.IntPtr,System.UInt32,System.UInt32@,System.IntPtr,System.IntPtr,System.IntPtr@,System.IntPtr@)">
            <summary>
            Updates the specified attribute in a list of attributes for process and thread creation.
            </summary>
            <param name = "lpAttributeList">
            A pointer to an attribute list created by the <see cref = "M:PInvoke.Kernel32.InitializeProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*,System.Int32,System.UInt32,System.IntPtr@)"/> function.
            </param>
            <param name = "dwFlags">
            This parameter is reserved and must be zero.
            </param>
            <param name = "Attribute">
            The attribute key to update in the attribute list.
            </param>
            <param name = "lpValue">
            A pointer to the attribute value. This value should persist until the attribute is destroyed using the <see cref = "M:PInvoke.Kernel32.DeleteProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*)"/> function.
            </param>
            <param name = "cbSize">
            The size of the attribute value specified by the <paramref name = "lpValue"/> parameter.
            </param>
            <param name = "lpPreviousValue">
            This parameter is reserved and must be NULL.
            </param>
            <param name = "lpReturnSize">This parameter is reserved and must be NULL.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.DeleteProcThreadAttributeList(System.IntPtr)">
            <summary>
            Deletes the specified list of attributes for process and thread creation.
            </summary>
            <param name = "lpAttributeList">
            The attribute list. This list is created by the <see cref = "M:PInvoke.Kernel32.InitializeProcThreadAttributeList(PInvoke.Kernel32.PROC_THREAD_ATTRIBUTE_LIST*,System.Int32,System.UInt32,System.IntPtr@)"/> function.
            </param>
        </member>
        <member name="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,System.IntPtr,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Creates or opens a file or I/O device. The most commonly used I/O devices are as follows: file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe. The function returns a handle that can be used to access the file or device for various types of I/O depending on the file or device and the flags and attributes specified.
            To perform this operation as a transacted operation, which results in a handle that can be used for transacted I/O, use the CreateFileTransacted function.
            </summary>
            <param name = "filename">
            The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes (\) in this name.
            In the ANSI version of this function, the name is limited to <see cref = "F:PInvoke.Kernel32.MAX_PATH"/> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming Files, Paths, and Namespaces.
            For information on special device names, see Defining an MS-DOS Device Name.
            To create a file stream, specify the name of the file, a colon, and then the name of the stream.For more information, see File Streams.
            </param>
            <param name = "access">
            The requested access to the file or device, which can be summarized as read, write, both or neither zero).
            The most commonly used values are <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/>, <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_WRITE"/>, or both(<see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/> | <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_WRITE"/>). For more information, see Generic Access Rights, File Security and Access Rights, File Access Rights Constants, and ACCESS_MASK.
            If this parameter is zero, the application can query certain metadata such as file, directory, or device attributes without accessing that file or device, even if <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/> access would have been denied.
            You cannot request an access mode that conflicts with the sharing mode that is specified by the dwShareMode parameter in an open request that already has an open handle.
            For more information, see the Remarks section of this topic and Creating and Opening Files.
            Common specific rights are defined in <seealso cref = "T:PInvoke.Kernel32.FileAccess"/>.
            </param>
            <param name = "share">
            The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none (refer to the following table). Access requests to attributes or extended attributes are not affected by this flag.
            If this parameter is zero and <see cref = "M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> succeeds, the file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. For more information, see the Remarks section.
            You cannot request a sharing mode that conflicts with the access mode that is specified in an existing request that has an open handle. <see cref = "M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> would fail and the <see cref = "M:PInvoke.Kernel32.GetLastError"/> function would return ERROR_SHARING_VIOLATION.
            To enable a process to share a file or device while another process has the file or device open, use a compatible combination of one or more of the following values. For more information about valid combinations of this parameter with the dwDesiredAccess parameter, see Creating and Opening Files.
            </param>
            <param name = "securityAttributes">
            A pointer to a SECURITY_ATTRIBUTES structure that contains two separate but related data members: an optional security descriptor, and a Boolean value that determines whether the returned handle can be inherited by child processes.
            This parameter can be NULL.
            If this parameter is NULL, the handle returned by CreateFile cannot be inherited by any child processes the application may create and the file or device associated with the returned handle gets a default security descriptor.
            The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a <see cref = "T:PInvoke.Kernel32.SECURITY_DESCRIPTOR"/> for a file or device. If this member is NULL, the file or device associated with the returned handle is assigned a default security descriptor.
            CreateFile ignores the <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member when opening an existing file or device, but continues to use the <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.bInheritHandle"/> member.
            The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.bInheritHandle"/> member of the structure specifies whether the returned handle can be inherited.
            </param>
            <param name = "creationDisposition">
            An action to take on a file or device that exists or does not exist.
            For devices other than files, this parameter is usually set to <see cref = "F:PInvoke.Kernel32.CreationDisposition.OPEN_EXISTING"/>.
            </param>
            <param name = "flagsAndAttributes">
            The file or device attributes and flags, <see cref = "F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_NORMAL"/> being the most common default value for files.
            This parameter can include any combination of the available file attributes (CreateFileFlags.*Attribute). All other file attributes override <see cref = "F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_NORMAL"/>.
            This parameter can also contain combinations of flags (CreateFileFlags.*Flag) for control of file or device caching behavior, access modes, and other special-purpose flags. These combine with any CreateFileFlags.*Attribute values.
            This parameter can also contain Security Quality of Service (SQOS) information by specifying the SECURITY_SQOS_PRESENT flag. Additional SQOS-related flags information is presented in the table following the attributes and flags tables.
            Note When CreateFile opens an existing file, it generally combines the file flags with the file attributes of the existing file, and ignores any file attributes supplied as part of dwFlagsAndAttributes. Special cases are detailed in Creating and Opening Files.
            Some of the following file attributes and flags may only apply to files and not necessarily all other types of devices that CreateFile can open.For additional information, see the Remarks section of this topic and Creating and Opening Files.
            For more advanced access to file attributes, see SetFileAttributes. For a complete list of all file attributes with their values and descriptions, see File Attribute Constants.
            </param>
            <param name = "templateFile">
            A valid handle to a template file with the <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/> access right. The template file supplies file attributes and extended attributes for the file that is being created.
            This parameter can be NULL.
            When opening an existing file, CreateFile ignores this parameter.
            When opening a new encrypted file, the file inherits the discretionary access control list from its parent directory.For additional information, see File Encryption.
            </param>
            <returns>
            If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot.
            If the function fails, the return value is INVALID_HANDLE_VALUE.To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Creates or opens a file or I/O device. The most commonly used I/O devices are as follows: file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe. The function returns a handle that can be used to access the file or device for various types of I/O depending on the file or device and the flags and attributes specified.
            To perform this operation as a transacted operation, which results in a handle that can be used for transacted I/O, use the CreateFileTransacted function.
            </summary>
            <param name = "filename">
            The name of the file or device to be created or opened. You may use either forward slashes (/) or backslashes (\) in this name.
            In the ANSI version of this function, the name is limited to <see cref = "F:PInvoke.Kernel32.MAX_PATH"/> characters. To extend this limit to 32,767 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming Files, Paths, and Namespaces.
            For information on special device names, see Defining an MS-DOS Device Name.
            To create a file stream, specify the name of the file, a colon, and then the name of the stream.For more information, see File Streams.
            </param>
            <param name = "access">
            The requested access to the file or device, which can be summarized as read, write, both or neither zero).
            The most commonly used values are <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/>, <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_WRITE"/>, or both(<see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/> | <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_WRITE"/>). For more information, see Generic Access Rights, File Security and Access Rights, File Access Rights Constants, and ACCESS_MASK.
            If this parameter is zero, the application can query certain metadata such as file, directory, or device attributes without accessing that file or device, even if <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/> access would have been denied.
            You cannot request an access mode that conflicts with the sharing mode that is specified by the dwShareMode parameter in an open request that already has an open handle.
            For more information, see the Remarks section of this topic and Creating and Opening Files.
            Common specific rights are defined in <seealso cref = "T:PInvoke.Kernel32.FileAccess"/>.
            </param>
            <param name = "share">
            The requested sharing mode of the file or device, which can be read, write, both, delete, all of these, or none (refer to the following table). Access requests to attributes or extended attributes are not affected by this flag.
            If this parameter is zero and <see cref = "M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> succeeds, the file or device cannot be shared and cannot be opened again until the handle to the file or device is closed. For more information, see the Remarks section.
            You cannot request a sharing mode that conflicts with the access mode that is specified in an existing request that has an open handle. <see cref = "M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> would fail and the <see cref = "M:PInvoke.Kernel32.GetLastError"/> function would return ERROR_SHARING_VIOLATION.
            To enable a process to share a file or device while another process has the file or device open, use a compatible combination of one or more of the following values. For more information about valid combinations of this parameter with the dwDesiredAccess parameter, see Creating and Opening Files.
            </param>
            <param name = "securityAttributes">
            A pointer to a SECURITY_ATTRIBUTES structure that contains two separate but related data members: an optional security descriptor, and a Boolean value that determines whether the returned handle can be inherited by child processes.
            This parameter can be NULL.
            If this parameter is NULL, the handle returned by CreateFile cannot be inherited by any child processes the application may create and the file or device associated with the returned handle gets a default security descriptor.
            The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a <see cref = "T:PInvoke.Kernel32.SECURITY_DESCRIPTOR"/> for a file or device. If this member is NULL, the file or device associated with the returned handle is assigned a default security descriptor.
            CreateFile ignores the <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member when opening an existing file or device, but continues to use the <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.bInheritHandle"/> member.
            The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.bInheritHandle"/> member of the structure specifies whether the returned handle can be inherited.
            </param>
            <param name = "creationDisposition">
            An action to take on a file or device that exists or does not exist.
            For devices other than files, this parameter is usually set to <see cref = "F:PInvoke.Kernel32.CreationDisposition.OPEN_EXISTING"/>.
            </param>
            <param name = "flagsAndAttributes">
            The file or device attributes and flags, <see cref = "F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_NORMAL"/> being the most common default value for files.
            This parameter can include any combination of the available file attributes (CreateFileFlags.*Attribute). All other file attributes override <see cref = "F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_NORMAL"/>.
            This parameter can also contain combinations of flags (CreateFileFlags.*Flag) for control of file or device caching behavior, access modes, and other special-purpose flags. These combine with any CreateFileFlags.*Attribute values.
            This parameter can also contain Security Quality of Service (SQOS) information by specifying the SECURITY_SQOS_PRESENT flag. Additional SQOS-related flags information is presented in the table following the attributes and flags tables.
            Note When CreateFile opens an existing file, it generally combines the file flags with the file attributes of the existing file, and ignores any file attributes supplied as part of dwFlagsAndAttributes. Special cases are detailed in Creating and Opening Files.
            Some of the following file attributes and flags may only apply to files and not necessarily all other types of devices that CreateFile can open.For additional information, see the Remarks section of this topic and Creating and Opening Files.
            For more advanced access to file attributes, see SetFileAttributes. For a complete list of all file attributes with their values and descriptions, see File Attribute Constants.
            </param>
            <param name = "templateFile">
            A valid handle to a template file with the <see cref = "F:PInvoke.Kernel32.ACCESS_MASK.GenericRight.GENERIC_READ"/> access right. The template file supplies file attributes and extended attributes for the file that is being created.
            This parameter can be NULL.
            When opening an existing file, CreateFile ignores this parameter.
            When opening a new encrypted file, the file inherits the discretionary access control list from its parent directory.For additional information, see File Encryption.
            </param>
            <returns>
            If the function succeeds, the return value is an open handle to the specified file, device, named pipe, or mail slot.
            If the function fails, the return value is INVALID_HANDLE_VALUE.To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.Process32First(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr)">
            <summary>Retrieves information about the first process encountered in a system snapshot.</summary>
            <param name = "hSnapshot">
            A handle to the snapshot returned from a previous call to the
            <see cref = "M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)"/> function.
            </param>
            <param name = "lppe">
            Contains process information such as the name of the executable file, the process identifier, and
            the process identifier of the parent process.
            </param>
            <returns>
            Returns <see langword = "true"/> if the first entry of the process list has been copied to the buffer or
            <see langword = "false"/> otherwise. The <see cref = "F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES"/> error value is returned by
            the <see cref = "M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/> function if no processes exist or the snapshot does not contain process
            information.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.Process32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESSENTRY32@)">
            <summary>Retrieves information about the first process encountered in a system snapshot.</summary>
            <param name = "hSnapshot">
            A handle to the snapshot returned from a previous call to the
            <see cref = "M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)"/> function.
            </param>
            <param name = "lppe">
            Contains process information such as the name of the executable file, the process identifier, and
            the process identifier of the parent process.
            </param>
            <returns>
            Returns <see langword = "true"/> if the first entry of the process list has been copied to the buffer or
            <see langword = "false"/> otherwise. The <see cref = "F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES"/> error value is returned by
            the <see cref = "M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/> function if no processes exist or the snapshot does not contain process
            information.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.Process32Next(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr)">
            <summary>Retrieves information about the next process recorded in a system snapshot.</summary>
            <param name = "hSnapshot">
            A handle to the snapshot returned from a previous call to the
            <see cref = "M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)"/> function.
            </param>
            <param name = "lppe">A <see cref = "T:PInvoke.Kernel32.PROCESSENTRY32"/> structure.</param>
            <returns>
            Returns <see langword = "true"/> if the next entry of the process list has been copied to the buffer or
            <see langword = "false"/> otherwise. The <see cref = "F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES"/> error value is returned by
            the <see cref = "M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/> function if no processes exist or the snapshot does not contain process
            information.
            </returns>
            <remarks>
            To retrieve information about the first process recorded in a snapshot, use the
            <see cref = "M:PInvoke.Kernel32.Process32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESSENTRY32*)"/>
            function.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.Process32Next(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESSENTRY32@)">
            <summary>Retrieves information about the next process recorded in a system snapshot.</summary>
            <param name = "hSnapshot">
            A handle to the snapshot returned from a previous call to the
            <see cref = "M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)"/> function.
            </param>
            <param name = "lppe">A <see cref = "T:PInvoke.Kernel32.PROCESSENTRY32"/> structure.</param>
            <returns>
            Returns <see langword = "true"/> if the next entry of the process list has been copied to the buffer or
            <see langword = "false"/> otherwise. The <see cref = "F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES"/> error value is returned by
            the <see cref = "M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/> function if no processes exist or the snapshot does not contain process
            information.
            </returns>
            <remarks>
            To retrieve information about the first process recorded in a snapshot, use the
            <see cref = "M:PInvoke.Kernel32.Process32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESSENTRY32*)"/>
            function.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.Module32First(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr)">
            <summary>
            Retrieves information about the first module associated with a process.
            </summary>
            <param name = "hSnapshot">A handle to the snapshot returned from a previous call to the <see cref = "M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)"/> function.</param>
            <param name = "lpme">A <see cref = "T:PInvoke.Kernel32.MODULEENTRY32"/> structure.</param>
            <returns>
            Returns <see langword = "true"/> if the first entry of the module list has been copied to the buffer or
            <see langword = "false"/> otherwise. The <see cref = "F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES"/> error value is returned by
            the <see cref = "M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/> function if no modules exist or the snapshot does not contain module
            information.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.Module32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.MODULEENTRY32@)">
            <summary>
            Retrieves information about the first module associated with a process.
            </summary>
            <param name = "hSnapshot">A handle to the snapshot returned from a previous call to the <see cref = "M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)"/> function.</param>
            <param name = "lpme">A <see cref = "T:PInvoke.Kernel32.MODULEENTRY32"/> structure.</param>
            <returns>
            Returns <see langword = "true"/> if the first entry of the module list has been copied to the buffer or
            <see langword = "false"/> otherwise. The <see cref = "F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES"/> error value is returned by
            the <see cref = "M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/> function if no modules exist or the snapshot does not contain module
            information.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.Module32Next(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr)">
            <summary>Retrieves information about the next process recorded in a system snapshot.</summary>
            <param name = "hSnapshot">A handle to the snapshot returned from a previous call to the
            <see cref = "M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)"/> function.</param>
            <param name = "lpme">A <see cref = "T:PInvoke.Kernel32.MODULEENTRY32"/> structure.</param>
            <returns>Returns <see langword = "true"/> if the next entry of the module list has been copied to the buffer or
            <see langword = "false"/> otherwise. The <see cref = "F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES"/> error value is returned by
            the <see cref = "M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/> function if no modules exist or the snapshot does not contain module
            information.</returns>
            <remarks>
            To retrieve information about the first module recorded in a snapshot, use the
            <see cref = "M:PInvoke.Kernel32.Module32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.MODULEENTRY32*)"/>
            function.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.Module32Next(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.MODULEENTRY32@)">
            <summary>Retrieves information about the next process recorded in a system snapshot.</summary>
            <param name = "hSnapshot">A handle to the snapshot returned from a previous call to the
            <see cref = "M:PInvoke.Kernel32.CreateToolhelp32Snapshot(PInvoke.Kernel32.CreateToolhelp32SnapshotFlags,System.Int32)"/> function.</param>
            <param name = "lpme">A <see cref = "T:PInvoke.Kernel32.MODULEENTRY32"/> structure.</param>
            <returns>Returns <see langword = "true"/> if the next entry of the module list has been copied to the buffer or
            <see langword = "false"/> otherwise. The <see cref = "F:PInvoke.Win32ErrorCode.ERROR_NO_MORE_FILES"/> error value is returned by
            the <see cref = "M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/> function if no modules exist or the snapshot does not contain module
            information.</returns>
            <remarks>
            To retrieve information about the first module recorded in a snapshot, use the
            <see cref = "M:PInvoke.Kernel32.Module32First(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.MODULEENTRY32*)"/>
            function.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.QueryFullProcessImageName(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.QueryFullProcessImageNameFlags,System.IntPtr,System.Int32@)">
            <summary>Retrieves the full name of the executable image for the specified process.</summary>
            <param name = "hProcess">
            A handle to the process. This handle must be created with the
            <see cref = "F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_INFORMATION"/> or
            <see cref = "F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_LIMITED_INFORMATION"/> access right.
            </param>
            <param name = "dwFlags">One of the <see cref = "T:PInvoke.Kernel32.QueryFullProcessImageNameFlags"/> values.</param>
            <param name = "lpExeName">The path to the executable image. If the function succeeds, this string is null-terminated.</param>
            <param name = "lpdwSize">
            On input, specifies the size of the lpExeName buffer, in characters. On success, receives the
            number of characters written to the buffer, not including the null-terminating character.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            <para>If the function fails, the return value is zero.To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.</para>
            </returns>
            <remarks>Minimum OS: Windows Vista / Windows Server 2008.</remarks>
        </member>
        <member name="M:PInvoke.Kernel32.QueryFullProcessImageName(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.QueryFullProcessImageNameFlags,System.Char[],System.Int32@)">
            <summary>Retrieves the full name of the executable image for the specified process.</summary>
            <param name = "hProcess">
            A handle to the process. This handle must be created with the
            <see cref = "F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_INFORMATION"/> or
            <see cref = "F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_LIMITED_INFORMATION"/> access right.
            </param>
            <param name = "dwFlags">One of the <see cref = "T:PInvoke.Kernel32.QueryFullProcessImageNameFlags"/> values.</param>
            <param name = "lpExeName">The path to the executable image. If the function succeeds, this string is null-terminated.</param>
            <param name = "lpdwSize">
            On input, specifies the size of the lpExeName buffer, in characters. On success, receives the
            number of characters written to the buffer, not including the null-terminating character.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            <para>If the function fails, the return value is zero.To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.</para>
            </returns>
            <remarks>Minimum OS: Windows Vista / Windows Server 2008.</remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetOverlappedResult(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32@,System.Boolean)">
            <summary>
            Retrieves the results of an overlapped operation on the specified file, named pipe, or communications device.
            To specify a timeout interval or wait on an alertable thread, use GetOverlappedResultEx.
            </summary>
            <param name = "hFile">
            A handle to the file, named pipe, or communications device. This is the same handle that was
            specified when the overlapped operation was started by a call to the ReadFile, WriteFile, ConnectNamedPipe,
            TransactNamedPipe, DeviceIoControl, or WaitCommEvent function.
            </param>
            <param name = "lpOverlapped">
            A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure that was specified when the overlapped
            operation was started.
            </param>
            <param name = "lpNumberOfBytesTransferred">
            A pointer to a variable that receives the number of bytes that were actually
            transferred by a read or write operation. For a TransactNamedPipe operation, this is the number of bytes that were read
            from the pipe. For a DeviceIoControl operation, this is the number of bytes of output data returned by the device
            driver. For a ConnectNamedPipe or WaitCommEvent operation, this value is undefined.
            </param>
            <param name = "bWait">
            If this parameter is TRUE, and the Internal member of the lpOverlapped structure is STATUS_PENDING,
            the function does not return until the operation has been completed. If this parameter is FALSE and the operation is
            still pending, the function returns FALSE and the <see cref = "M:PInvoke.Kernel32.GetLastError"/> function returns
            <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_INCOMPLETE"/>.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            <para>
            If the function fails, the return value is zero.To get extended error information, call
            <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </para>
            </returns>
            <remarks>
            The results reported by the GetOverlappedResult function are those of the specified handle's last overlapped operation
            to which the specified <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure was provided, and for which the operation's results were
            pending. A pending operation is indicated when the function that started the operation returns FALSE, and the
            GetLastError function returns <see cref = "F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING"/>. When an I/O operation is pending, the
            function that started the operation resets the hEvent member of the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure to the
            nonsignaled state. Then when the pending operation has been completed, the system sets the event object to the signaled
            state.
            <para>
            If the bWait parameter is TRUE, GetOverlappedResult determines whether the pending operation has been completed
            by waiting for the event object to be in the signaled state.
            </para>
            <para>
            If the hEvent member of the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure is NULL, the system uses the state of the hFile
            handle to signal when the operation has been completed. Use of file, named pipe, or communications-device handles for
            this purpose is discouraged. It is safer to use an event object because of the confusion that can occur when multiple
            simultaneous overlapped operations are performed on the same file, named pipe, or communications device. In this
            situation, there is no way to know which operation caused the object's state to be signaled.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,System.IntPtr,System.Int32)">
            <summary>Creates an anonymous pipe, and returns handles to the read and write ends of the pipe.</summary>
            <param name = "hReadPipe">A pointer to a variable that receives the read handle for the pipe.</param>
            <param name = "hWritePipe">A pointer to a variable that receives the write handle for the pipe.</param>
            <param name = "lpPipeAttributes">
                A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that determines whether the returned handle can be
                inherited by child processes. If <paramref name = "lpPipeAttributes"/>  is NULL, the handle cannot be inherited.
                <para>
                    The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a security
                    descriptor for the new pipe. If <paramref name = "lpPipeAttributes"/>  is NULL, the pipe gets a default security descriptor. The ACLs
                    in the default security descriptor for a pipe come from the primary or impersonation token of the creator.
                </para>
            </param>
            <param name = "nSize">
                The size of the buffer for the pipe, in bytes. The size is only a suggestion; the system uses the
                value to calculate an appropriate buffering mechanism. If this parameter is zero, the system uses the default
                buffer size.
            </param>
            <returns>
                If the function succeeds, the return value is a nonzero value.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.Int32)">
            <summary>Creates an anonymous pipe, and returns handles to the read and write ends of the pipe.</summary>
            <param name = "hReadPipe">A pointer to a variable that receives the read handle for the pipe.</param>
            <param name = "hWritePipe">A pointer to a variable that receives the write handle for the pipe.</param>
            <param name = "lpPipeAttributes">
                A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that determines whether the returned handle can be
                inherited by child processes. If <paramref name = "lpPipeAttributes"/>  is NULL, the handle cannot be inherited.
                <para>
                    The <see cref = "F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a security
                    descriptor for the new pipe. If <paramref name = "lpPipeAttributes"/>  is NULL, the pipe gets a default security descriptor. The ACLs
                    in the default security descriptor for a pipe come from the primary or impersonation token of the creator.
                </para>
            </param>
            <param name = "nSize">
                The size of the buffer for the pipe, in bytes. The size is only a suggestion; the system uses the
                value to calculate an appropriate buffering mechanism. If this parameter is zero, the system uses the default
                buffer size.
            </param>
            <returns>
                If the function succeeds, the return value is a nonzero value.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr)">
            <summary>
                Creates an instance of a named pipe and returns a handle for subsequent pipe operations. A named pipe server
                process uses this function either to create the first instance of a specific named pipe and establish its basic
                attributes or to create a new instance of an existing named pipe.
            </summary>
            <param name = "lpName">
                The unique pipe name. This string must have the following form:
                <para>
                    <code>\\.\pipe\pipename</code>
                </para>
                <para>
                    The pipename part of the name can include any character other than a backslash, including numbers and special
                    characters. The entire pipe name string can be up to 256 characters long. Pipe names are not case sensitive.
                </para>
            </param>
            <param name = "dwOpenMode">
                The open mode. The function fails if dwOpenMode specifies anything other than 0 or the flags
                from <see cref = "T:PInvoke.Kernel32.PipeAccessMode"/>.
                <para>The same mode must be specified for each instance of the pipe.</para>
            </param>
            <param name = "dwPipeMode">
                The pipe mode. The function fails if dwPipeMode specifies anything other than 0 or the flags from
                <see cref = "T:PInvoke.Kernel32.PipeMode"/>.
                <para>
                    One of the following type modes can be specified. The same type mode must be specified for each instance of
                    the pipe.
                </para>
            </param>
            <param name = "nMaxInstances">
                The maximum number of instances that can be created for this pipe. The first instance of
                the pipe can specify this value; the same number must be specified for other instances of the pipe. Acceptable
                values are in the range 1 through <see cref = "F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES"/> (255). If this parameter is
                <see cref = "F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES"/>, the number of pipe instances that can be created is limited only by the
                availability of system resources. If nMaxInstances is greater than <see cref = "F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES"/>, the
                return value is an invalid handle and <see cref = "M:PInvoke.Kernel32.GetLastError"/> returns
                <see cref = "F:PInvoke.Win32ErrorCode.ERROR_INVALID_PARAMETER"/>.
            </param>
            <param name = "nOutBufferSize">The number of bytes to reserve for the output buffer.</param>
            <param name = "nInBufferSize">The number of bytes to reserve for the input buffer.</param>
            <param name = "nDefaultTimeOut">
                The default time-out value, in milliseconds, if the <see cref = "M:PInvoke.Kernel32.WaitNamedPipe(System.String,System.Int32)"/> function specifies
                NMPWAIT_USE_DEFAULT_WAIT. Each instance of a named pipe must specify the same value.
            </param>
            <param name = "lpSecurityAttributes">
                A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a
                security descriptor for the new named pipe and determines whether child processes can inherit the returned handle.
                If lpSecurityAttributes is NULL, the named pipe gets a default security descriptor and the handle cannot be
                inherited. The ACLs in the default security descriptor for a named pipe grant full control to the LocalSystem
                account, administrators, and the creator owner. They also grant read access to members of the Everyone group and
                the anonymous account.
            </param>
            <returns>
                If the function succeeds, the return value is a handle to the server end of a named pipe instance. If the
                function fails, the return value is an invalid handle. To get extended error information, call
                <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES})">
            <summary>
                Creates an instance of a named pipe and returns a handle for subsequent pipe operations. A named pipe server
                process uses this function either to create the first instance of a specific named pipe and establish its basic
                attributes or to create a new instance of an existing named pipe.
            </summary>
            <param name = "lpName">
                The unique pipe name. This string must have the following form:
                <para>
                    <code>\\.\pipe\pipename</code>
                </para>
                <para>
                    The pipename part of the name can include any character other than a backslash, including numbers and special
                    characters. The entire pipe name string can be up to 256 characters long. Pipe names are not case sensitive.
                </para>
            </param>
            <param name = "dwOpenMode">
                The open mode. The function fails if dwOpenMode specifies anything other than 0 or the flags
                from <see cref = "T:PInvoke.Kernel32.PipeAccessMode"/>.
                <para>The same mode must be specified for each instance of the pipe.</para>
            </param>
            <param name = "dwPipeMode">
                The pipe mode. The function fails if dwPipeMode specifies anything other than 0 or the flags from
                <see cref = "T:PInvoke.Kernel32.PipeMode"/>.
                <para>
                    One of the following type modes can be specified. The same type mode must be specified for each instance of
                    the pipe.
                </para>
            </param>
            <param name = "nMaxInstances">
                The maximum number of instances that can be created for this pipe. The first instance of
                the pipe can specify this value; the same number must be specified for other instances of the pipe. Acceptable
                values are in the range 1 through <see cref = "F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES"/> (255). If this parameter is
                <see cref = "F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES"/>, the number of pipe instances that can be created is limited only by the
                availability of system resources. If nMaxInstances is greater than <see cref = "F:PInvoke.Kernel32.PIPE_UNLIMITED_INSTANCES"/>, the
                return value is an invalid handle and <see cref = "M:PInvoke.Kernel32.GetLastError"/> returns
                <see cref = "F:PInvoke.Win32ErrorCode.ERROR_INVALID_PARAMETER"/>.
            </param>
            <param name = "nOutBufferSize">The number of bytes to reserve for the output buffer.</param>
            <param name = "nInBufferSize">The number of bytes to reserve for the input buffer.</param>
            <param name = "nDefaultTimeOut">
                The default time-out value, in milliseconds, if the <see cref = "M:PInvoke.Kernel32.WaitNamedPipe(System.String,System.Int32)"/> function specifies
                NMPWAIT_USE_DEFAULT_WAIT. Each instance of a named pipe must specify the same value.
            </param>
            <param name = "lpSecurityAttributes">
                A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies a
                security descriptor for the new named pipe and determines whether child processes can inherit the returned handle.
                If lpSecurityAttributes is NULL, the named pipe gets a default security descriptor and the handle cannot be
                inherited. The ACLs in the default security descriptor for a named pipe grant full control to the LocalSystem
                account, administrators, and the creator owner. They also grant read access to members of the Everyone group and
                the anonymous account.
            </param>
            <returns>
                If the function succeeds, the return value is a handle to the server end of a named pipe instance. If the
                function fails, the return value is an invalid handle. To get extended error information, call
                <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ConnectNamedPipe(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr)">
            <summary>
                Enables a named pipe server process to wait for a client process to connect to an instance of a named pipe. A
                client process connects by calling either the CreateFile or CallNamedPipe function.
            </summary>
            <param name = "hNamedPipe">
                A handle to the server end of a named pipe instance. This handle is returned by the
                CreateNamedPipe function.
            </param>
            <param name = "lpOverlapped">
                A pointer to an OVERLAPPED structure.
                <para>
                    If hNamedPipe was opened with FILE_FLAG_OVERLAPPED, the lpOverlapped parameter must not be NULL. It must
                    point to a valid OVERLAPPED structure. If hNamedPipe was opened with FILE_FLAG_OVERLAPPED and lpOverlapped is
                    NULL, the function can incorrectly report that the connect operation is complete.
                </para>
                <para>
                    If hNamedPipe was created with FILE_FLAG_OVERLAPPED and lpOverlapped is not NULL, the OVERLAPPED structure
                    should contain a handle to a manual-reset event object (which the server can create by using the CreateEvent
                    function).
                </para>
                <para>
                    If hNamedPipe was not opened with FILE_FLAG_OVERLAPPED, the function does not return until a client is
                    connected or an error occurs. Successful synchronous operations result in the function returning a nonzero
                    value if a client connects after the function is called.
                </para>
            </param>
            <returns>
                If the operation is synchronous, ConnectNamedPipe does not return until the operation has completed. If the
                function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended
                error information, call GetLastError.
                <para>
                    If the operation is asynchronous, ConnectNamedPipe returns immediately. If the operation is still pending,
                    the return value is zero and GetLastError returns ERROR_IO_PENDING. (You can use the HasOverlappedIoCompleted
                    macro to determine when the operation has finished.) If the function fails, the return value is zero and
                    GetLastError returns a value other than ERROR_IO_PENDING or ERROR_PIPE_CONNECTED.
                </para>
                <para>
                    If a client connects before the function is called, the function returns zero and GetLastError returns
                    ERROR_PIPE_CONNECTED. This can happen if a client connects in the interval between the call to CreateNamedPipe
                    and the call to ConnectNamedPipe. In this situation, there is a good connection between client and server, even
                    though the function returns zero.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CallNamedPipe(System.String,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@,System.Int32)">
            <summary>
                Connects to a message-type pipe (and waits if an instance of the pipe is not available), writes to and reads
                from the pipe, and then closes the pipe.
            </summary>
            <param name = "lpNamedPipeName">The pipe name.</param>
            <param name = "lpInBuffer">The data to be written to the pipe.</param>
            <param name = "nInBufferSize">The size of the write buffer, in bytes.</param>
            <param name = "lpOutBuffer">A pointer to the buffer that receives the data read from the pipe.</param>
            <param name = "nOutBufferSize">The size of the read buffer, in bytes.</param>
            <param name = "lpBytesRead">A pointer to a variable that receives the number of bytes read from the pipe.</param>
            <param name = "nTimeOut">
                The number of milliseconds to wait for the named pipe to be available. In addition to numeric
                values, <see cref = "F:PInvoke.Kernel32.NMPWAIT_NOWAIT"/>, <see cref = "F:PInvoke.Kernel32.NMPWAIT_WAIT_FOREVER"/> and
                <see cref = "F:PInvoke.Kernel32.NMPWAIT_USE_DEFAULT_WAIT"/> can be specified.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
                <para>
                    If the message written to the pipe by the server process is longer than nOutBufferSize, CallNamedPipe returns
                    FALSE, and GetLastError returns ERROR_MORE_DATA. The remainder of the message is discarded, because
                    CallNamedPipe closes the handle to the pipe before returning.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeClientComputerName(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32)">
            <summary>Retrieves the client computer name for the specified named pipe.</summary>
            <param name = "Pipe">
                A handle to an instance of a named pipe. This handle must be created by the CreateNamedPipe
                function.
            </param>
            <param name = "ClientComputerName">The computer name.</param>
            <param name = "ClientComputerNameLength">The size of the ClientComputerName buffer, in bytes.</param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeClientComputerName(PInvoke.Kernel32.SafeObjectHandle,System.Char[],System.Int32)">
            <summary>Retrieves the client computer name for the specified named pipe.</summary>
            <param name = "Pipe">
                A handle to an instance of a named pipe. This handle must be created by the CreateNamedPipe
                function.
            </param>
            <param name = "ClientComputerName">The computer name.</param>
            <param name = "ClientComputerNameLength">The size of the ClientComputerName buffer, in bytes.</param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeHandleState(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PipeMode@,System.IntPtr,System.IntPtr,System.IntPtr,System.Text.StringBuilder,System.Int32)">
            <summary>
                Retrieves information about a specified named pipe. The information returned can vary during the lifetime of
                an instance of the named pipe.
            </summary>
            <param name = "hNamedPipe">
                A handle to the named pipe for which information is wanted. The handle must have GENERIC_READ
                access for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a
                write-only pipe.
                <para>This parameter can also be a handle to an anonymous pipe, as returned by the CreatePipe function.</para>
            </param>
            <param name = "lpState">
                A pointer to a variable that indicates the current state of the handle. Either or both of
                <see cref = "F:PInvoke.Kernel32.PipeMode.PIPE_NOWAIT"/> and <see cref = "F:PInvoke.Kernel32.PipeMode.PIPE_READMODE_MESSAGE"/> can be specified.
            </param>
            <param name = "lpCurInstances">
                A pointer to a variable that receives the number of current pipe instances. This parameter
                can be NULL if this information is not required.
            </param>
            <param name = "lpMaxCollectionCount">
                A pointer to a variable that receives the maximum number of bytes to be collected on
                the client's computer before transmission to the server. This parameter must be NULL if the specified pipe handle
                is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can
                be NULL if this information is not required.
            </param>
            <param name = "lpCollectDataTimeout">
                A pointer to a variable that receives the maximum time, in milliseconds, that can
                pass before a remote named pipe transfers information over the network. This parameter must be NULL if the
                specified pipe handle is to the server end of a named pipe or if client and server processes are on the same
                computer. This parameter can be NULL if this information is not required.
            </param>
            <param name = "lpUserName">
                A pointer to a buffer that receives the user name string associated with the client application. The server can
                only retrieve this information if the client opened the pipe with SECURITY_IMPERSONATION access.
                <para>
                    This parameter must be NULL if the specified pipe handle is to the client end of a named pipe. This parameter
                    can be NULL if this information is not required.
                </para>
            </param>
            <param name = "nMaxUserNameSize">
                The size of the buffer specified by the lpUserName parameter, in chars. This parameter
                is ignored if lpUserName is NULL.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeHandleState(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PipeMode@,System.Nullable{System.Int32}@,System.Nullable{System.Int32}@,System.Nullable{System.Int32}@,System.Text.StringBuilder,System.Int32)">
            <summary>
                Retrieves information about a specified named pipe. The information returned can vary during the lifetime of
                an instance of the named pipe.
            </summary>
            <param name = "hNamedPipe">
                A handle to the named pipe for which information is wanted. The handle must have GENERIC_READ
                access for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a
                write-only pipe.
                <para>This parameter can also be a handle to an anonymous pipe, as returned by the CreatePipe function.</para>
            </param>
            <param name = "lpState">
                A pointer to a variable that indicates the current state of the handle. Either or both of
                <see cref = "F:PInvoke.Kernel32.PipeMode.PIPE_NOWAIT"/> and <see cref = "F:PInvoke.Kernel32.PipeMode.PIPE_READMODE_MESSAGE"/> can be specified.
            </param>
            <param name = "lpCurInstances">
                A pointer to a variable that receives the number of current pipe instances. This parameter
                can be NULL if this information is not required.
            </param>
            <param name = "lpMaxCollectionCount">
                A pointer to a variable that receives the maximum number of bytes to be collected on
                the client's computer before transmission to the server. This parameter must be NULL if the specified pipe handle
                is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can
                be NULL if this information is not required.
            </param>
            <param name = "lpCollectDataTimeout">
                A pointer to a variable that receives the maximum time, in milliseconds, that can
                pass before a remote named pipe transfers information over the network. This parameter must be NULL if the
                specified pipe handle is to the server end of a named pipe or if client and server processes are on the same
                computer. This parameter can be NULL if this information is not required.
            </param>
            <param name = "lpUserName">
                A pointer to a buffer that receives the user name string associated with the client application. The server can
                only retrieve this information if the client opened the pipe with SECURITY_IMPERSONATION access.
                <para>
                    This parameter must be NULL if the specified pipe handle is to the client end of a named pipe. This parameter
                    can be NULL if this information is not required.
                </para>
            </param>
            <param name = "nMaxUserNameSize">
                The size of the buffer specified by the lpUserName parameter, in chars. This parameter
                is ignored if lpUserName is NULL.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeHandleState(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PipeMode@,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
                Retrieves information about a specified named pipe. The information returned can vary during the lifetime of
                an instance of the named pipe.
            </summary>
            <param name = "hNamedPipe">
                A handle to the named pipe for which information is wanted. The handle must have GENERIC_READ
                access for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a
                write-only pipe.
                <para>This parameter can also be a handle to an anonymous pipe, as returned by the CreatePipe function.</para>
            </param>
            <param name = "lpState">
                A pointer to a variable that indicates the current state of the handle. Either or both of
                <see cref = "F:PInvoke.Kernel32.PipeMode.PIPE_NOWAIT"/> and <see cref = "F:PInvoke.Kernel32.PipeMode.PIPE_READMODE_MESSAGE"/> can be specified.
            </param>
            <param name = "lpCurInstances">
                A pointer to a variable that receives the number of current pipe instances. This parameter
                can be NULL if this information is not required.
            </param>
            <param name = "lpMaxCollectionCount">
                A pointer to a variable that receives the maximum number of bytes to be collected on
                the client's computer before transmission to the server. This parameter must be NULL if the specified pipe handle
                is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can
                be NULL if this information is not required.
            </param>
            <param name = "lpCollectDataTimeout">
                A pointer to a variable that receives the maximum time, in milliseconds, that can
                pass before a remote named pipe transfers information over the network. This parameter must be NULL if the
                specified pipe handle is to the server end of a named pipe or if client and server processes are on the same
                computer. This parameter can be NULL if this information is not required.
            </param>
            <param name = "lpUserName">
                A pointer to a buffer that receives the user name string associated with the client application. The server can
                only retrieve this information if the client opened the pipe with SECURITY_IMPERSONATION access.
                <para>
                    This parameter must be NULL if the specified pipe handle is to the client end of a named pipe. This parameter
                    can be NULL if this information is not required.
                </para>
            </param>
            <param name = "nMaxUserNameSize">
                The size of the buffer specified by the lpUserName parameter, in chars. This parameter
                is ignored if lpUserName is NULL.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetNamedPipeHandleState(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PipeMode@,System.Nullable{System.Int32}@,System.Nullable{System.Int32}@,System.Nullable{System.Int32}@,System.Char[],System.Int32)">
            <summary>
                Retrieves information about a specified named pipe. The information returned can vary during the lifetime of
                an instance of the named pipe.
            </summary>
            <param name = "hNamedPipe">
                A handle to the named pipe for which information is wanted. The handle must have GENERIC_READ
                access for a read-only or read/write pipe, or it must have GENERIC_WRITE and FILE_READ_ATTRIBUTES access for a
                write-only pipe.
                <para>This parameter can also be a handle to an anonymous pipe, as returned by the CreatePipe function.</para>
            </param>
            <param name = "lpState">
                A pointer to a variable that indicates the current state of the handle. Either or both of
                <see cref = "F:PInvoke.Kernel32.PipeMode.PIPE_NOWAIT"/> and <see cref = "F:PInvoke.Kernel32.PipeMode.PIPE_READMODE_MESSAGE"/> can be specified.
            </param>
            <param name = "lpCurInstances">
                A pointer to a variable that receives the number of current pipe instances. This parameter
                can be NULL if this information is not required.
            </param>
            <param name = "lpMaxCollectionCount">
                A pointer to a variable that receives the maximum number of bytes to be collected on
                the client's computer before transmission to the server. This parameter must be NULL if the specified pipe handle
                is to the server end of a named pipe or if client and server processes are on the same computer. This parameter can
                be NULL if this information is not required.
            </param>
            <param name = "lpCollectDataTimeout">
                A pointer to a variable that receives the maximum time, in milliseconds, that can
                pass before a remote named pipe transfers information over the network. This parameter must be NULL if the
                specified pipe handle is to the server end of a named pipe or if client and server processes are on the same
                computer. This parameter can be NULL if this information is not required.
            </param>
            <param name = "lpUserName">
                A pointer to a buffer that receives the user name string associated with the client application. The server can
                only retrieve this information if the client opened the pipe with SECURITY_IMPERSONATION access.
                <para>
                    This parameter must be NULL if the specified pipe handle is to the client end of a named pipe. This parameter
                    can be NULL if this information is not required.
                </para>
            </param>
            <param name = "nMaxUserNameSize">
                The size of the buffer specified by the lpUserName parameter, in chars. This parameter
                is ignored if lpUserName is NULL.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.PeekNamedPipe(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
                Copies data from a named or anonymous pipe into a buffer without removing it from the pipe. It also returns
                information about data in the pipe.
            </summary>
            <param name = "hNamedPipe">
                A handle to the pipe. This parameter can be a handle to a named pipe instance, as returned by
                the <see cref = "M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/> or <see cref = "M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> function, or it can be a handle to the read end of
                an anonymous pipe, as returned by the <see cref = "M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Int32)"/> function. The handle must have GENERIC_READ access
                to the pipe.
            </param>
            <param name = "lpBuffer">
                A pointer to a buffer that receives data read from the pipe. This parameter can be NULL if no
                data is to be read.
            </param>
            <param name = "nBufferSize">
                The size of the buffer specified by the lpBuffer parameter, in bytes. This parameter is
                ignored if lpBuffer is NULL.
            </param>
            <param name = "lpBytesRead">A pointer to a variable that receives the number of bytes read from the pipe.</param>
            <param name = "lpTotalBytesAvail">
                A pointer to a variable that receives the total number of bytes available to be read
                from the pipe.
            </param>
            <param name = "lpBytesLeftThisMessage">
                A pointer to a variable that receives the number of bytes remaining in this
                message. This parameter will be zero for byte-type named pipes or for anonymous pipes.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SetNamedPipeHandleState(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
                Sets the read mode and the blocking mode of the specified named pipe. If the specified handle is to the client
                end of a named pipe and if the named pipe server process is on a remote computer, the function can also be used to
                control local buffering.
            </summary>
            <param name = "hNamedPipe">
                A handle to the named pipe instance. This parameter can be a handle to the server end of the
                pipe, as returned by the <see cref = "M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/> function, or to the client end of the pipe, as returned by
                the <see cref = "M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> function. The handle must have GENERIC_WRITE access to the named pipe for a
                write-only or read/write pipe, or it must have GENERIC_READ and FILE_WRITE_ATTRIBUTES access for a read-only pipe.
                <para>
                    This parameter can also be a handle to an anonymous pipe, as returned by the <see cref = "M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Int32)"/>
                    function.
                </para>
            </param>
            <param name = "lpMode">The new pipe mode. The mode is a combination of a read-mode flag and a wait-mode flag.</param>
            <param name = "lpMaxCollectionCount">
                The maximum number of bytes collected on the client computer before transmission to
                the server. This parameter must be NULL if the specified pipe handle is to the server end of a named pipe or if
                client and server processes are on the same machine. This parameter is ignored if the client process specifies the
                FILE_FLAG_WRITE_THROUGH flag in the CreateFile function when the handle was created. This parameter can be NULL if
                the collection count is not being set.
            </param>
            <param name = "lpCollectDataTimeout">
                The maximum time, in milliseconds, that can pass before a remote named pipe
                transfers information over the network. This parameter must be NULL if the specified pipe handle is to the server
                end of a named pipe or if client and server processes are on the same computer. This parameter is ignored if the
                client process specified the FILE_FLAG_WRITE_THROUGH flag in the CreateFile function when the handle was created.
                This parameter can be NULL if the collection count is not being set.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SetNamedPipeHandleState(PInvoke.Kernel32.SafeObjectHandle,System.Nullable{PInvoke.Kernel32.PipeMode},System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
                Sets the read mode and the blocking mode of the specified named pipe. If the specified handle is to the client
                end of a named pipe and if the named pipe server process is on a remote computer, the function can also be used to
                control local buffering.
            </summary>
            <param name = "hNamedPipe">
                A handle to the named pipe instance. This parameter can be a handle to the server end of the
                pipe, as returned by the <see cref = "M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/> function, or to the client end of the pipe, as returned by
                the <see cref = "M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> function. The handle must have GENERIC_WRITE access to the named pipe for a
                write-only or read/write pipe, or it must have GENERIC_READ and FILE_WRITE_ATTRIBUTES access for a read-only pipe.
                <para>
                    This parameter can also be a handle to an anonymous pipe, as returned by the <see cref = "M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Int32)"/>
                    function.
                </para>
            </param>
            <param name = "lpMode">The new pipe mode. The mode is a combination of a read-mode flag and a wait-mode flag.</param>
            <param name = "lpMaxCollectionCount">
                The maximum number of bytes collected on the client computer before transmission to
                the server. This parameter must be NULL if the specified pipe handle is to the server end of a named pipe or if
                client and server processes are on the same machine. This parameter is ignored if the client process specifies the
                FILE_FLAG_WRITE_THROUGH flag in the CreateFile function when the handle was created. This parameter can be NULL if
                the collection count is not being set.
            </param>
            <param name = "lpCollectDataTimeout">
                The maximum time, in milliseconds, that can pass before a remote named pipe
                transfers information over the network. This parameter must be NULL if the specified pipe handle is to the server
                end of a named pipe or if client and server processes are on the same computer. This parameter is ignored if the
                client process specified the FILE_FLAG_WRITE_THROUGH flag in the CreateFile function when the handle was created.
                This parameter can be NULL if the collection count is not being set.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.TransactNamedPipe(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@,System.IntPtr)">
            <summary>
                Combines the functions that write a message to and read a message from the specified named pipe into a single
                network operation.
            </summary>
            <param name = "hNamedPipe">
                A handle to the named pipe returned by the <see cref = "M:PInvoke.Kernel32.CreateNamedPipe(System.String,PInvoke.Kernel32.PipeAccessMode,PInvoke.Kernel32.PipeMode,System.Int32,System.Int32,System.Int32,System.Int32,PInvoke.Kernel32.SECURITY_ATTRIBUTES*)"/> or
                <see cref = "M:PInvoke.Kernel32.CreateFile(System.String,PInvoke.Kernel32.ACCESS_MASK,PInvoke.Kernel32.FileShare,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,PInvoke.Kernel32.CreationDisposition,PInvoke.Kernel32.CreateFileFlags,PInvoke.Kernel32.SafeObjectHandle)"/> function.
                <para>
                    This parameter can also be a handle to an anonymous pipe, as returned by the <see cref = "M:PInvoke.Kernel32.CreatePipe(PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SafeObjectHandle@,PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Int32)"/>
                    function.
                </para>
            </param>
            <param name = "lpInBuffer">A pointer to the buffer containing the data to be written to the pipe.</param>
            <param name = "nInBufferSize">The size of the input buffer, in bytes.</param>
            <param name = "lpOutBuffer">A pointer to the buffer that receives the data read from the pipe.</param>
            <param name = "nOutBufferSize">The size of the output buffer, in bytes.</param>
            <param name = "lpBytesRead">A pointer to the variable that receives the number of bytes read from the pipe.</param>
            <param name = "lpOverlapped">
                A pointer to an <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. This structure is required if hNamedPipe was opened with
                FILE_FLAG_OVERLAPPED.
                <para>
                    If hNamedPipe was opened with FILE_FLAG_OVERLAPPED, the lpOverlapped parameter must not be NULL. It must
                    point to a valid <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure. If hNamedPipe was created with FILE_FLAG_OVERLAPPED and
                    lpOverlapped is NULL, the function can incorrectly report that the operation is complete.
                </para>
                <para>
                    If hNamedPipe was opened with FILE_FLAG_OVERLAPPED and lpOverlapped is not NULL, TransactNamedPipe is
                    executed as an overlapped operation. The <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure should contain a manual-reset
                    event object (which can be created by using the CreateEvent function). If the operation cannot be completed
                    immediately, TransactNamedPipe returns FALSE and GetLastError returns ERROR_IO_PENDING. In this situation, the
                    event object is set to the nonsignaled state before TransactNamedPipe returns, and it is set to the signaled
                    state when the transaction has finished. Also, you can be notified when an overlapped operation completes by
                    using the GetQueuedCompletionStatus or GetQueuedCompletionStatusEx functions. In this case, you do not need to
                    assign the manual-reset event in the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> structure, and the completion happens against
                    <paramref name = "hNamedPipe"/> in the same way as an asynchronous read or write operation.
                </para>
                <para>
                    If hNamedPipe was not opened with FILE_FLAG_OVERLAPPED, TransactNamedPipe does not return until the operation
                    is complete.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
                <para>
                    If the message to be read is longer than the buffer specified by the <paramref name = "nOutBufferSize"/>
                    parameter, TransactNamedPipe returns FALSE and the <see cref = "M:PInvoke.Kernel32.GetLastError"/> function returns
                    <see cref = "F:PInvoke.Win32ErrorCode.ERROR_MORE_DATA"/>. The remainder of the message can be read by a subsequent call to
                    <see cref = "M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)"/>, ReadFileEx, or PeekNamedPipe.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LocalAlloc_IntPtr(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)">
            <summary>
            Allocates the specified number of bytes from the heap.
            </summary>
            <param name = "uFlags">
            The memory allocation attributes. The default is the <see cref = "F:PInvoke.Kernel32.LocalAllocFlags.LMEM_FIXED"/> value.
            This parameter can be one or more of the following values, except for the incompatible combinations that are specifically noted.
            </param>
            <param name = "uBytes">
            The number of bytes to allocate. If this parameter is zero and the <paramref name = "uFlags"/> parameter specifies <see cref = "F:PInvoke.Kernel32.LocalAllocFlags.LMEM_MOVEABLE"/>,
            the function returns a handle to a memory object that is marked as discarded.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the newly allocated memory object.
            If the function fails, the return value is NULL. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LocalReAlloc(System.IntPtr,System.IntPtr,PInvoke.Kernel32.LocalReAllocFlags)">
            <summary>
            Changes the size or the attributes of a specified local memory object. The size can increase or decrease.
            </summary>
            <param name = "hMem">
            A handle to the local memory object to be reallocated.
            This handle is returned by either the <see cref = "M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)"/> or <see cref = "M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.LocalReAllocFlags)"/> function.
            </param>
            <param name = "uBytes">The new size of the memory block, in bytes. If uFlags specifies <see cref = "F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MODIFY"/>, this parameter is ignored.</param>
            <param name = "uFlags">
            The reallocation options. If <see cref = "F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MODIFY"/> is specified, the function modifies the attributes of the memory object only
            (the uBytes parameter is ignored.) Otherwise, the function reallocates the memory object.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the reallocated memory object.
            If the function fails, the return value is NULL. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            If LocalReAlloc fails, the original memory is not freed, and the original handle and pointer are still valid.
            If LocalReAlloc reallocates a fixed object, the value of the handle returned is the address of the first byte of the memory block.
            To access the memory, a process can simply cast the return value to a pointer.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.LocalFree(System.IntPtr)">
            <summary>
            Frees the specified local memory object and invalidates its handle.
            </summary>
            <param name = "hMem">
            A handle to the local memory object. This handle is returned by either the <see cref = "M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)"/> or
            <see cref = "M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.LocalReAllocFlags)"/> function. It is not safe to free memory allocated with <see cref = "M:PInvoke.Kernel32.GlobalAlloc(PInvoke.Kernel32.GlobalAllocFlags,System.IntPtr)"/>.
            If the hMem parameter is NULL, LocalFree ignores the parameter and returns NULL.
            </param>
            <returns>
            If the function succeeds, the return value is NULL.
            If the function fails, the return value is equal to a handle to <paramref name = "hMem"/>. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LocalLock(System.IntPtr)">
            <summary>
            Locks a local memory object and returns a pointer to the first byte of the object's memory block.
            </summary>
            <param name = "hMem">A handle to the local memory object. This handle is returned by either the <see cref = "M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)"/> or <see cref = "M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.Int32,PInvoke.Kernel32.LocalReAllocFlags)"/> function.</param>
            <returns>
            If the function succeeds, the return value is a pointer to the first byte of the memory block.
            If the function fails, the return value is <see cref = "F:System.IntPtr.Zero"/>. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LocalUnlock(System.IntPtr)">
            <summary>
            Decrements the lock count associated with a memory object that was allocated with <see cref = "F:PInvoke.Kernel32.LocalAllocFlags.LMEM_MOVEABLE"/>.
            This function has no effect on memory objects allocated with <see cref = "F:PInvoke.Kernel32.LocalAllocFlags.LMEM_FIXED"/>.
            </summary>
            <param name = "hMem">A handle to the local  memory object. This handle is returned by either the <see cref = "M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)"/> or <see cref = "M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.Int32,PInvoke.Kernel32.LocalReAllocFlags)"/> function.</param>
            <returns>
            If the memory object is still locked after decrementing the lock count, the return value is true.
            If the memory object is unlocked after decrementing the lock count, the function returns false and <see cref = "M:PInvoke.Kernel32.GetLastError"/> returns <see cref = "F:PInvoke.Win32ErrorCode.ERROR_SUCCESS"/>.
            If the function fails, the return value is false and <see cref = "M:PInvoke.Kernel32.GetLastError"/> returns a value other than <see cref = "F:PInvoke.Win32ErrorCode.ERROR_SUCCESS"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GlobalAlloc_IntPtr(PInvoke.Kernel32.GlobalAllocFlags,System.IntPtr)">
            <summary>
            Allocates the specified number of bytes from the heap.
            </summary>
            <param name = "uFlags">
            The memory allocation attributes. The default is the <see cref = "F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_FIXED"/> value.
            This parameter can be one or more of the following values, except for the incompatible combinations that are specifically noted.
            </param>
            <param name = "uBytes">
            The number of bytes to allocate. If this parameter is zero and the uFlags parameter specifies <see cref = "F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_MOVEABLE"/>,
            the function returns a handle to a memory object that is marked as discarded.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the newly allocated memory object.
            If the function fails, the return value is NULL. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GlobalReAlloc(System.IntPtr,System.IntPtr,PInvoke.Kernel32.GlobalReAllocFlags)">
            <summary>
            Changes the size or attributes of a specified global memory object. The size can increase or decrease.
            </summary>
            <param name = "hMem">
            A handle to the global memory object to be reallocated.
            This handle is returned by either the <see cref = "M:PInvoke.Kernel32.GlobalAlloc(PInvoke.Kernel32.GlobalAllocFlags,System.IntPtr)"/> or <see cref = "M:PInvoke.Kernel32.GlobalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.GlobalReAllocFlags)"/> function.
            </param>
            <param name = "uBytes">The new size of the memory block, in bytes. If uFlags specifies <see cref = "F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_MODIFY"/>, this parameter is ignored.</param>
            <param name = "uFlags">
            The reallocation options. If <see cref = "F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MODIFY"/> is specified, the function modifies the attributes of the memory object only
            (the uBytes parameter is ignored.) Otherwise, the function reallocates the memory object.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the reallocated memory object.
            If the function fails, the return value is NULL. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            If GlobalReAlloc fails, the original memory is not freed, and the original handle and pointer are still valid.
            If GlobalReAlloc reallocates a fixed object, the value of the handle returned is the address of the first byte of the memory block.
            To access the memory, a process can simply cast the return value to a pointer.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GlobalFree(System.IntPtr)">
            <summary>
            Frees the specified global memory object and invalidates its handle.
            </summary>
            <param name = "hMem">
            A handle to the global memory object. This handle is returned by either the <see cref = "M:PInvoke.Kernel32.GlobalAlloc(PInvoke.Kernel32.GlobalAllocFlags,System.IntPtr)"/> or
            <see cref = "M:PInvoke.Kernel32.GlobalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.GlobalReAllocFlags)"/> function. It is not safe to free memory allocated with <see cref = "M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)"/>.
            </param>
            <returns>
            If the function succeeds, the return value is NULL.
            If the function fails, the return value is equal to a handle to <paramref name = "hMem"/>. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GlobalLock(System.IntPtr)">
            <summary>
            Locks a global memory object and returns a pointer to the first byte of the object's memory block.
            </summary>
            <param name = "hMem">A handle to the global memory object. This handle is returned by either the <see cref = "M:PInvoke.Kernel32.GlobalAlloc(PInvoke.Kernel32.GlobalAllocFlags,System.IntPtr)"/> or <see cref = "M:PInvoke.Kernel32.GlobalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.GlobalReAllocFlags)"/> function.</param>
            <returns>
            If the function succeeds, the return value is a pointer to the first byte of the memory block.
             If the function fails, the return value is <see cref = "F:System.IntPtr.Zero"/>. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GlobalUnlock(System.IntPtr)">
            <summary>
            Decrements the lock count associated with a memory object that was allocated with <see cref = "F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_MOVEABLE"/>.
            This function has no effect on memory objects allocated with <see cref = "F:PInvoke.Kernel32.GlobalAllocFlags.GMEM_FIXED"/>.
            </summary>
            <param name = "hMem">A handle to the global memory object. This handle is returned by either the <see cref = "M:PInvoke.Kernel32.GlobalAlloc(PInvoke.Kernel32.GlobalAllocFlags,System.IntPtr)"/> or <see cref = "M:PInvoke.Kernel32.GlobalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.GlobalReAllocFlags)"/> function.</param>
            <returns>
            If the memory object is still locked after decrementing the lock count, the return value is true.
            If the memory object is unlocked after decrementing the lock count, the function returns false and <see cref = "M:PInvoke.Kernel32.GetLastError"/> returns <see cref = "F:PInvoke.Win32ErrorCode.ERROR_SUCCESS"/>.
            If the function fails, the return value is false and <see cref = "M:PInvoke.Kernel32.GetLastError"/> returns a value other than <see cref = "F:PInvoke.Win32ErrorCode.ERROR_SUCCESS"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.HeapAlloc_IntPtr(System.IntPtr,PInvoke.Kernel32.HeapAllocFlags,System.IntPtr)">
            <summary>
            Allocates a block of memory from a heap. The allocated memory is not movable.
            </summary>
            <param name = "hHeap">A handle to the heap from which the memory will be allocated. This handle is returned by the HeapCreate or  function.</param>
            <param name = "uFlags">The heap allocation options. Specifying any of these values will override the corresponding value specified when the heap was created with HeapCreate.</param>
            <param name = "uBytes">
            The number of bytes to be allocated. If the heap specified by the hHeap parameter is a "non-growable" heap,
            dwBytes must be less than 0x7FFF8.
            You create a non-growable heap by calling the HeapCreate function with a nonzero value.
            </param>
            <returns>
            If the function succeeds, the return value is a pointer to the allocated memory block.
            If the function fails and you have not specified <see cref = "F:PInvoke.Kernel32.HeapAllocFlags.HEAP_GENERATE_EXCEPTIONS"/>, the return value is NULL.
            If the function fails and you have specified <see cref = "F:PInvoke.Kernel32.HeapAllocFlags.HEAP_GENERATE_EXCEPTIONS"/>,
            the function may generate either of the exceptions listed in the following table:
            <list>
            <item>STATUS_NO_MEMORY: The allocation attempt failed because of a lack of available memory or heap corruption.</item>
            <item>STATUS_ACCESS_VIOLATION: The allocation attempt failed because of heap corruption or improper function parameters.</item>
            </list>
            The particular exception depends upon the nature of the heap corruption. For more information, see GetExceptionCode.
            </returns>
            <remarks>If the function fails, it does not call SetLastError. An application cannot call <see cref = "M:PInvoke.Kernel32.GetLastError"/> for extended error information.</remarks>
        </member>
        <member name="M:PInvoke.Kernel32.HeapReAlloc(System.IntPtr,PInvoke.Kernel32.HeapReAllocFlags,System.IntPtr,System.IntPtr)">
            <summary>
            Reallocates a block of memory from a heap. This function enables you to resize a memory block and change other memory block properties.
            The allocated memory is not movable.
            </summary>
            <param name = "hHeap">A handle to the heap from which the memory is to be reallocated. This handle is a returned by either the HeapCreate or GetProcessHeap function.</param>
            <param name = "uFlags">
            The heap reallocation options. Specifying a value overrides the corresponding value specified in the flOptions parameter
            when the heap was created by using the HeapCreate function.
            </param>
            <param name = "hMem">
            A pointer to the block of memory that the function reallocates.
            This pointer is returned by an earlier call to the <see cref = "M:PInvoke.Kernel32.HeapAlloc(System.IntPtr,PInvoke.Kernel32.HeapAllocFlags,System.IntPtr)"/> or <see cref = "M:PInvoke.Kernel32.HeapReAlloc(System.IntPtr,PInvoke.Kernel32.HeapReAllocFlags,System.Void*,System.IntPtr)"/> function.
            </param>
            <param name = "uBytes">
            The new size of the memory block, in bytes. A memory block's size can be increased or decreased by using this function.
            If the heap specified by the hHeap parameter is a "non-growable" heap, dwBytes must be less than 0x7FFF8.
            You create a non-growable heap by calling the HeapCreate function with a nonzero value.
            </param>
            <returns>
            If the function succeeds, the return value is a pointer to the reallocated memory block.
            If the function fails and you have not specified <see cref = "F:PInvoke.Kernel32.HeapAllocFlags.HEAP_GENERATE_EXCEPTIONS"/>, the return value is NULL.
            If the function fails and you have specified <see cref = "F:PInvoke.Kernel32.HeapAllocFlags.HEAP_GENERATE_EXCEPTIONS"/>,
            the function may generate either of the exceptions listed in the following table:
            <list>
            <item>STATUS_NO_MEMORY: The allocation attempt failed because of a lack of available memory or heap corruption.</item>
            <item>STATUS_ACCESS_VIOLATION: The allocation attempt failed because of heap corruption or improper function parameters.</item>
            </list>
            The particular exception depends upon the nature of the heap corruption. For more information, see GetExceptionCode.
            </returns>
            <remarks>If the function fails, it does not call SetLastError. An application cannot call <see cref = "M:PInvoke.Kernel32.GetLastError"/> for extended error information.</remarks>
        </member>
        <member name="M:PInvoke.Kernel32.HeapFree(System.IntPtr,PInvoke.Kernel32.HeapFreeFlags,System.IntPtr)">
            <summary>
            Frees a memory block allocated from a heap by the <see cref = "M:PInvoke.Kernel32.HeapAlloc(System.IntPtr,PInvoke.Kernel32.HeapAllocFlags,System.IntPtr)"/> or <see cref = "M:PInvoke.Kernel32.HeapReAlloc(System.IntPtr,PInvoke.Kernel32.HeapReAllocFlags,System.Void*,System.IntPtr)"/> function.
            </summary>
            <param name = "hHeap">
            A handle to the heap whose memory block is to be freed. This handle is returned by either the HeapCreate or
            GetProcessHeap function.
            </param>
            <param name = "dwFlags">The heap free options. Specifying the following value overrides the corresponding value specified in the flOptions parameter
            when the heap was created by using the HeapCreate function.</param>
            <param name = "hMem">
            A pointer to the memory block to be freed. This pointer is returned by the <see cref = "M:PInvoke.Kernel32.HeapAlloc(System.IntPtr,PInvoke.Kernel32.HeapAllocFlags,System.IntPtr)"/> or <see cref = "M:PInvoke.Kernel32.HeapReAlloc(System.IntPtr,PInvoke.Kernel32.HeapReAllocFlags,System.Void*,System.IntPtr)"/> function.
            If this pointer is NULL, the behavior is undefined.
            </param>
            <returns>
            If the function succeeds, the return value is true. If the function fails, the return value false. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CopyMemory(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Copies a block of memory from one location to another.
            </summary>
            <param name = "Destination">A pointer to the starting address of the copied block's destination.</param>
            <param name = "Source">A pointer to the starting address of the block of memory to copy.</param>
            <param name = "Length">The size of the block of memory to copy, in bytes.</param>
            <remarks>
            This function is defined as the RtlCopyMemory function.
            If the source and destination blocks overlap, the results are undefined.
            For overlapped blocks, use the <see cref = "M:PInvoke.Kernel32.MoveMemory(System.Void*,System.Void*,System.IntPtr)"/> function.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.MoveMemory(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Moves a block of memory from one location to another.
            </summary>
            <param name = "Destination">A pointer to the starting address of the move destination.</param>
            <param name = "Source">A pointer to the starting address of the block of memory to be moved.</param>
            <param name = "Length">The size of the block of memory to move, in bytes.</param>
            <remarks>
            <para>
            This function is defined as the RtlMoveMemory function.
            The source and destination blocks may overlap.
            </para>
            <para>
            The first parameter, <paramref name = "Destination"/>, must be large enough to hold <paramref name = "Length"/> bytes of <paramref name = "Source"/>;
            otherwise, a buffer overrun may occur.
            This may lead to a denial of service attack against the application if an access violation occurs or, in the worst case,
            allow an attacker to inject executable code into your process.
            This is especially true if <paramref name = "Destination"/> is a stack-based buffer.
            Be aware that the last parameter, <paramref name = "Length"/>, is the number of bytes to copy into <paramref name = "Destination"/>, not the size of the <paramref name = "Destination"/>.
            </para>
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.EnumResourceNames(PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr,PInvoke.Kernel32.EnumResNameProc,System.IntPtr)">
            <summary>
                Enumerates resources of a specified type within a binary module. For Windows Vista and later, this is
                typically a language-neutral Portable Executable (LN file), and the enumeration will also include resources from
                the corresponding language-specific resource files (.mui files) that contain localizable language resources. It is
                also possible for hModule to specify an .mui file, in which case only that file is searched for resources.
            </summary>
            <param name = "hModule">
                A handle to a module to be searched. Starting with Windows Vista, if this is an LN file, then appropriate .mui
                files (if any exist) are included in the search.
                <para>
                    If this parameter is NULL, that is equivalent to passing in a handle to the module used to create the current
                    process.
                </para>
            </param>
            <param name = "lpszType">
                The type of the resource for which the name is being enumerated. Alternately, rather than a
                pointer, this parameter can be <see cref = "M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)"/>(ID), where ID is an integer value representing a
                predefined resource type.
            </param>
            <param name = "lpEnumFunc">A pointer to the callback function to be called for each enumerated resource name or ID.</param>
            <param name = "lParam">
                An application-defined value passed to the callback function. This parameter can be used in error
                checking.
            </param>
            <returns>
                The return value is TRUE if the function succeeds or FALSE if the function does not find a resource of the
                type specified, or if the function fails for another reason. To get extended error information, call
                <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.EnumResourceLanguages(PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr,System.IntPtr,PInvoke.Kernel32.EnumResLangProc,System.IntPtr)">
            <summary>
                Enumerates language-specific resources, of the specified type and name, associated with a binary module.
            </summary>
            <param name = "hModule">
                The handle to a module to be searched. Starting with Windows Vista, if this is a language-neutral Portable
                Executable (LN file), then appropriate .mui files (if any exist) are included in the search. If this is a
                specific .mui file, only that file is searched for resources.
                <para>
                    If this parameter is NULL, that is equivalent to passing in a handle to the module used to create the current process.
                </para>
            </param>
            <param name = "lpType">
                The type of resource for which the language is being enumerated. Alternately, rather than a pointer, this
                parameter can be <see cref = "M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)"/>(ID), where ID is an integer value representing a predefined resource type.
            </param>
            <param name = "lpName">
                The name of the resource for which the language is being enumerated. Alternately, rather than a pointer,
                this parameter can be <see cref = "M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)"/>(ID), where ID is the integer identifier of the resource.
            </param>
            <param name = "lpEnumFunc">
                A pointer to the callback function to be called for each enumerated resource language. For more information,
                see <see cref = "T:PInvoke.Kernel32.EnumResLangProc"/>.
            </param>
            <param name = "lParam">
                An application-defined value passed to the callback function. This parameter can be used in error checking.
            </param>
            <returns>Returns TRUE if successful or FALSE otherwise. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.IS_INTRESOURCE(System.IntPtr)">
            <summary>Determines whether a value is an integer identifier for a resource.</summary>
            <param name = "p">The pointer to be tested whether it contains an integer resource identifier.</param>
            <returns>If the value is a resource identifier, the return value is TRUE. Otherwise, the return value is FALSE.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.MAKEINTRESOURCE_IntPtr(System.Int32)">
            <summary>
                Converts an integer value to a resource type compatible with the resource-management functions. This macro is
                used in place of a string containing the name of the resource.
            </summary>
            <param name = "wInteger">The integer value to be converted.</param>
            <returns>The return value is the specified value in the low-order word and zero in the high-order word.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.FindResource(PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr,System.IntPtr)">
            <summary>
                Determines the location of a resource with the specified type and name in the specified module.
                <para>To specify a language, use the FindResourceEx function.</para>
            </summary>
            <param name = "hModule">
                A handle to the module whose portable executable file or an accompanying MUI file contains the
                resource. If this parameter is <see cref = "F:PInvoke.Kernel32.SafeLibraryHandle.Null"/>, the function searches the module used to
                create the current process.
            </param>
            <param name = "lpName">
                The name of the resource. Alternately, rather than a pointer, this parameter can be
                <see cref = "M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)"/>, where wInteger is the integer identifier of the resource.
            </param>
            <param name = "lpType">
                The resource type. Alternately, rather than a pointer, this parameter can be
                <see cref = "M:PInvoke.Kernel32.MAKEINTRESOURCE(System.Int32)"/>, where wInteger is the integer identifier of the given resource type.
            </param>
            <returns>
                If the function succeeds, the return value is a handle to the specified resource's information block. To obtain a
                handle to the resource, pass this handle to the <see cref = "M:PInvoke.Kernel32.LoadResource(PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr)"/> function.
                <para>
                    If the function fails, the return value is NULL. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateJobObject(System.IntPtr,System.String)">
            <summary>
            Creates or opens a job object.
            </summary>
            <param name = "lpJobAttributes">A pointer to a <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure that specifies the security descriptor for the job object and determines whether child processes can inherit the returned handle.
            If lpJobAttributes is NULL, the job object gets a default security descriptor and the handle cannot be inherited.
            The ACLs in the default security descriptor for a job object come from the primary or impersonation token of the creator.
            </param>
            <param name = "lpName">The name of the job. The name is limited to MAX_PATH characters. Name comparison is case-sensitive.
            If lpName is NULL, the job is created without a name.
            If lpName matches the name of an existing event, semaphore, mutex, waitable timer, or file-mapping object, the function fails and the GetLastError function returns ERROR_INVALID_HANDLE.
            This occurs because these objects share the same namespace.The object can be created in a private namespace.For more information, see Object Namespaces.
            Terminal Services:  The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see Kernel Object Namespaces.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the job object. The handle has the JOB_OBJECT_ALL_ACCESS access right. If the object existed before the function call, the function returns a handle to the existing job object and GetLastError returns ERROR_ALREADY_EXISTS.
            If the function fails, the return value is NULL.To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SetInformationJobObject(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.JOBOBJECTINFOCLASS,System.IntPtr,System.UInt32)">
            <summary>
            Sets limits for a job object.
            </summary>
            <param name = "hJob">
            A handle to the job whose limits are being set. The <see cref = "M:PInvoke.Kernel32.CreateJobObject(PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.String)"/> or OpenJobObject function returns this handle. The handle must have the JOB_OBJECT_SET_ATTRIBUTES access right. For more information, see Job Object Security and Access Rights.
            </param>
            <param name = "jobObjectInfoClass">
            The information class for the limits to be set.
            </param>
            <param name = "lpJobObjectInfo">T
            he limits or job state to be set for the job. The format of this data depends on the value of JobObjectInfoClass.
            </param>
            <param name = "cbJobObjectInfoLength">
            The size of the job information being set, in bytes.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero.To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteProcessMemory(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.
            </summary>
            <param name = "hProcess">A handle to the process memory to be modified. The handle must have <see cref = "F:PInvoke.Kernel32.ProcessAccess.PROCESS_VM_WRITE"/> and <see cref = "F:PInvoke.Kernel32.ProcessAccess.PROCESS_VM_OPERATION"/> access to the process.</param>
            <param name = "lpBaseAddress">A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</param>
            <param name = "lpBuffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name = "nSize">The number of bytes to be written to the specified process.</param>
            <param name = "lpNumberOfBytesWritten">A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If <paramref name = "lpNumberOfBytesWritten"/> is NULL, the parameter is ignored.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is 0 (zero). To get extended error information, call GetLastError. The function fails if the requested write operation crosses into an area of the process that is inaccessible.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteProcessMemory(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Nullable{System.IntPtr}@)">
            <summary>
            Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.
            </summary>
            <param name = "hProcess">A handle to the process memory to be modified. The handle must have <see cref = "F:PInvoke.Kernel32.ProcessAccess.PROCESS_VM_WRITE"/> and <see cref = "F:PInvoke.Kernel32.ProcessAccess.PROCESS_VM_OPERATION"/> access to the process.</param>
            <param name = "lpBaseAddress">A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</param>
            <param name = "lpBuffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name = "nSize">The number of bytes to be written to the specified process.</param>
            <param name = "lpNumberOfBytesWritten">A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If <paramref name = "lpNumberOfBytesWritten"/> is NULL, the parameter is ignored.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is 0 (zero). To get extended error information, call GetLastError. The function fails if the requested write operation crosses into an area of the process that is inaccessible.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteProcessMemory(System.IntPtr,System.Void*,System.Void*,System.IntPtr,System.Nullable{System.IntPtr}@)">
            <summary>
            Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the operation fails.
            </summary>
            <param name = "hProcess">A handle to the process memory to be modified. The handle must have <see cref = "F:PInvoke.Kernel32.ProcessAccess.PROCESS_VM_WRITE"/> and <see cref = "F:PInvoke.Kernel32.ProcessAccess.PROCESS_VM_OPERATION"/> access to the process.</param>
            <param name = "lpBaseAddress">A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for write access, and if it is not accessible, the function fails.</param>
            <param name = "lpBuffer">A pointer to the buffer that contains data to be written in the address space of the specified process.</param>
            <param name = "nSize">The number of bytes to be written to the specified process.</param>
            <param name = "lpNumberOfBytesWritten">A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is optional. If <paramref name = "lpNumberOfBytesWritten"/> is NULL, the parameter is ignored.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is 0 (zero). To get extended error information, call GetLastError. The function fails if the requested write operation crosses into an area of the process that is inaccessible.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ReadProcessMemory(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.
            </summary>
            <param name = "hProcess">A handle to the process with memory that is being read. The handle must have <see cref = "F:PInvoke.Kernel32.ProcessAccess.PROCESS_VM_READ"/> access to the process.</param>
            <param name = "lpBaseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
            <param name = "lpBuffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name = "nSize">The number of bytes to be read from the specified process.</param>
            <param name = "lpNumberOfBytesRead">A pointer to a variable that receives the number of bytes transferred into the specified buffer. If <paramref name = "lpNumberOfBytesRead"/> is NULL, the parameter is ignored.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is 0 (zero). To get extended error information, call GetLastError.
            The function fails if the requested read operation crosses into an area of the process that is inaccessible.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ReadProcessMemory(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Nullable{System.IntPtr}@)">
            <summary>
            Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.
            </summary>
            <param name = "hProcess">A handle to the process with memory that is being read. The handle must have <see cref = "F:PInvoke.Kernel32.ProcessAccess.PROCESS_VM_READ"/> access to the process.</param>
            <param name = "lpBaseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
            <param name = "lpBuffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name = "nSize">The number of bytes to be read from the specified process.</param>
            <param name = "lpNumberOfBytesRead">A pointer to a variable that receives the number of bytes transferred into the specified buffer. If <paramref name = "lpNumberOfBytesRead"/> is NULL, the parameter is ignored.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is 0 (zero). To get extended error information, call GetLastError.
            The function fails if the requested read operation crosses into an area of the process that is inaccessible.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ReadProcessMemory(System.IntPtr,System.Void*,System.Void*,System.IntPtr,System.Nullable{System.IntPtr}@)">
            <summary>
            Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the operation fails.
            </summary>
            <param name = "hProcess">A handle to the process with memory that is being read. The handle must have <see cref = "F:PInvoke.Kernel32.ProcessAccess.PROCESS_VM_READ"/> access to the process.</param>
            <param name = "lpBaseAddress">A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the system verifies that all data in the base address and memory of the specified size is accessible for read access, and if it is not accessible the function fails.</param>
            <param name = "lpBuffer">A pointer to a buffer that receives the contents from the address space of the specified process.</param>
            <param name = "nSize">The number of bytes to be read from the specified process.</param>
            <param name = "lpNumberOfBytesRead">A pointer to a variable that receives the number of bytes transferred into the specified buffer. If <paramref name = "lpNumberOfBytesRead"/> is NULL, the parameter is ignored.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is 0 (zero). To get extended error information, call GetLastError.
            The function fails if the requested read operation crosses into an area of the process that is inaccessible.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LockResource_IntPtr(System.IntPtr)">
            <summary>Retrieves a pointer to the specified resource in memory.</summary>
            <param name = "hResData">
                A handle to the resource to be accessed. The <see cref = "M:PInvoke.Kernel32.LoadResource(PInvoke.Kernel32.SafeLibraryHandle,System.IntPtr)"/> function returns this
                handle.
            </param>
            <returns>
                If the loaded resource is available, the return value is a pointer to the first byte of the resource;
                otherwise, it is NULL.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.DeviceIoControl(PInvoke.Kernel32.SafeObjectHandle,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@,System.IntPtr)">
            <summary>
                Sends a control code directly to a specified device driver, causing the corresponding device to perform the
                corresponding operation.
            </summary>
            <param name = "hDevice">
                A handle to the device on which the operation is to be performed. The device is typically a
                volume, directory, file, or stream. To retrieve a device handle, use the CreateFile function.
            </param>
            <param name = "dwIoControlCode">
                The control code for the operation. This value identifies the specific operation to be performed and the type of
                device on which to perform it.
                <para>
                    For a list of the control codes, see Remarks. The documentation for each control code provides usage details
                    for the <paramref name = "inBuffer"/>, <paramref name = "nInBufferSize"/>, <paramref name = "outBuffer"/>, and
                    <paramref name = "nOutBufferSize"/> parameters.
                </para>
            </param>
            <param name = "inBuffer">
                A pointer to the input buffer that contains the data required to perform the operation. The format of this data
                depends on the value of the <paramref name = "dwIoControlCode"/> parameter.
                <para>
                    This parameter can be NULL if <paramref name = "dwIoControlCode"/> specifies an operation that does not
                    require input data.
                </para>
            </param>
            <param name = "nInBufferSize">The size of the input buffer, in bytes.</param>
            <param name = "outBuffer">
                A pointer to the output buffer that is to receive the data returned by the operation. The format of this data
                depends on the value of the <paramref name = "dwIoControlCode"/> parameter.
                <para>
                    This parameter can be NULL if <paramref name = "dwIoControlCode"/> specifies an operation that does not return
                    data.
                </para>
            </param>
            <param name = "nOutBufferSize">The size of the output buffer, in bytes.</param>
            <param name = "pBytesReturned">
                A pointer to a variable that receives the size of the data stored in the output buffer, in bytes.
                <para>
                    If the output buffer is too small to receive any data, the call fails, <see cref = "M:PInvoke.Kernel32.GetLastError"/> returns
                    <see cref = "F:PInvoke.Win32ErrorCode.ERROR_INSUFFICIENT_BUFFER"/>, and lpBytesReturned is zero.
                </para>
                <para>
                    If the output buffer is too small to hold all of the data but can hold some entries, some drivers will return
                    as much data as fits. In this case, the call fails, <see cref = "M:PInvoke.Kernel32.GetLastError"/> returns
                    <see cref = "F:PInvoke.Win32ErrorCode.ERROR_MORE_DATA"/>, and lpBytesReturned indicates the amount of data received. Your
                    application should call DeviceIoControl again with the same operation, specifying a new starting point.
                </para>
                <para>
                    If <paramref name = "lpOverlapped"/> is NULL, lpBytesReturned cannot be NULL. Even when an operation returns
                    no output data and lpOutBuffer is NULL, DeviceIoControl makes use of lpBytesReturned. After such an operation,
                    the value of lpBytesReturned is meaningless.
                </para>
                <para>
                    If <paramref name = "lpOverlapped"/> is not NULL, lpBytesReturned can be NULL. If this parameter is not NULL
                    and the operation returns data, lpBytesReturned is meaningless until the overlapped operation has completed. To
                    retrieve the number of bytes returned, call GetOverlappedResult. If hDevice is associated with an I/O
                    completion port, you can retrieve the number of bytes returned by calling GetQueuedCompletionStatus.
                </para>
            </param>
            <param name = "lpOverlapped">
                A pointer to an OVERLAPPED structure.
                <para>
                    If hDevice was opened without specifying <see cref = "F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_OVERLAPPED"/>, lpOverlapped is
                    ignored.
                </para>
                <para>
                    If hDevice was opened with the <see cref = "F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_OVERLAPPED"/> flag, the operation is
                    performed as an overlapped (asynchronous) operation. In this case, lpOverlapped must point to a valid
                    OVERLAPPED structure that contains a handle to an event object. Otherwise, the function fails in unpredictable
                    ways.
                </para>
                <para>
                    For overlapped operations, DeviceIoControl returns immediately, and the event object is signaled when the
                    operation has been completed. Otherwise, the function does not return until the operation has been completed or
                    an error occurs.
                </para>
            </param>
            <returns>
                If the operation completes successfully, the return value is nonzero.
                <para>
                    If the operation fails or is pending, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SetSystemTime(System.IntPtr)">
            <summary>
            Sets the current system time and date. The system time is expressed in Coordinated Universal Time (UTC).
            </summary>
            <param name = "lpSystemTime">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SYSTEMTIME"/> structure that contains the new system date and time.
            The wDayOfWeek member of the <see cref = "T:PInvoke.Kernel32.SYSTEMTIME"/> structure is ignored.</param>
            <returns>
                If the function succeeds, the return value is a nonzero value.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SetSystemTime(PInvoke.Kernel32.SYSTEMTIME)">
            <summary>
            Sets the current system time and date. The system time is expressed in Coordinated Universal Time (UTC).
            </summary>
            <param name = "lpSystemTime">
            A pointer to a <see cref = "T:PInvoke.Kernel32.SYSTEMTIME"/> structure that contains the new system date and time.
            The wDayOfWeek member of the <see cref = "T:PInvoke.Kernel32.SYSTEMTIME"/> structure is ignored.</param>
            <returns>
                If the function succeeds, the return value is a nonzero value.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LocalAlloc_IntPtr(PInvoke.Kernel32.LocalAllocFlags,System.Int32)">
            <summary>
            Allocates the specified number of bytes from the heap.
            </summary>
            <param name = "uFlags">
            The memory allocation attributes. The default is the <see cref = "F:PInvoke.Kernel32.LocalAllocFlags.LMEM_FIXED"/> value. This parameter can be one or more of the following values, except for the incompatible combinations that are specifically noted.
            </param>
            <param name = "uBytes">The number of bytes to allocate. If this parameter is zero and the <paramref name = "uFlags"/> parameter specifies <see cref = "F:PInvoke.Kernel32.LocalAllocFlags.LMEM_MOVEABLE"/>, the function returns a handle to a memory object that is marked as discarded.</param>
            <returns>
            If the function succeeds, the return value is a handle to the newly allocated memory object.
            If the function fails, the return value is NULL. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.LocalReAlloc(System.IntPtr,System.Int32,PInvoke.Kernel32.LocalReAllocFlags)">
            <summary>
            Changes the size or the attributes of a specified local memory object. The size can increase or decrease.
            </summary>
            <param name = "hMem">A handle to the local memory object to be reallocated. This handle is returned by either the <see cref = "M:PInvoke.Kernel32.LocalAlloc(PInvoke.Kernel32.LocalAllocFlags,System.IntPtr)"/> or <see cref = "M:PInvoke.Kernel32.LocalReAlloc(System.Void*,System.IntPtr,PInvoke.Kernel32.LocalReAllocFlags)"/> function.</param>
            <param name = "uBytes">The new size of the memory block, in bytes. If uFlags specifies <see cref = "F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MODIFY"/>, this parameter is ignored.</param>
            <param name = "uFlags">
            The reallocation options. If <see cref = "F:PInvoke.Kernel32.LocalReAllocFlags.LMEM_MODIFY"/> is specified, the function modifies the attributes of the memory object only (the uBytes parameter is ignored.) Otherwise, the function reallocates the memory object.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the reallocated memory object.
            If the function fails, the return value is NULL. To get extended error information, call <see cref = "M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>
            If LocalReAlloc fails, the original memory is not freed, and the original handle and pointer are still valid.
            If LocalReAlloc reallocates a fixed object, the value of the handle returned is the address of the first byte of the memory block. To access the memory, a process can simply cast the return value to a pointer.
            </remarks>
        </member>
        <member name="T:PInvoke.Kernel32Extensions">
            <summary>
            Extension methods available for and from the Kernel32 library.
            </summary>
            <content>
            Desktop-only extension methods for Kernel32.
            </content>
        </member>
        <member name="F:PInvoke.Kernel32Extensions.MaxAllowedBufferSize">
            <summary>
            The maximum memory we are willing to allocate for the exception message.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32Extensions.GetMessage(PInvoke.Win32ErrorCode)">
            <summary>
            Gets the text associated with a <see cref="T:PInvoke.Win32ErrorCode"/>.
            </summary>
            <param name="error">The error code.</param>
            <returns>The error message. Or <c>null</c> if no message could be found.</returns>
        </member>
        <member name="M:PInvoke.Kernel32Extensions.ThrowOnError(PInvoke.Win32ErrorCode)">
            <summary>
            Throws an exception when an error occurs.
            </summary>
            <param name="errorCode">The result of the P/Invoke call.</param>
            <exception cref="T:PInvoke.Win32Exception">If <paramref name="errorCode"/> is not <see cref="F:PInvoke.Win32ErrorCode.ERROR_SUCCESS"/></exception>
        </member>
        <member name="M:PInvoke.Kernel32Extensions.ThrowOnError(PInvoke.NTSTATUS)">
            <summary>
            Throws an exception if a P/Invoke failed.
            </summary>
            <param name="status">The result of the P/Invoke call.</param>
        </member>
        <member name="M:PInvoke.Kernel32Extensions.GetMessage(PInvoke.NTSTATUS)">
            <summary>
            Gets the text associated with an <see cref="T:PInvoke.NTSTATUS"/>.
            </summary>
            <param name="status">The error code.</param>
            <returns>The error message. Or <c>null</c> if no message could be found.</returns>
        </member>
        <member name="T:PInvoke.NTStatusException">
            <summary>
            An exception thrown for a failure described by a <see cref="T:PInvoke.NTSTATUS"/>.
            </summary>
        </member>
        <member name="M:PInvoke.NTStatusException.#ctor(PInvoke.NTSTATUS)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.NTStatusException"/> class.
            </summary>
            <param name="statusCode">The status code identifying the error.</param>
        </member>
        <member name="M:PInvoke.NTStatusException.#ctor(PInvoke.NTSTATUS,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.NTStatusException"/> class.
            </summary>
            <param name="statusCode">The status code identifying the error.</param>
            <param name="message">The exception message (which may be null to use the default).</param>
        </member>
        <member name="M:PInvoke.NTStatusException.#ctor(PInvoke.NTSTATUS,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.NTStatusException"/> class.
            </summary>
            <param name="statusCode">The status code identifying the error.</param>
            <param name="message">The exception message (which may be null to use the default).</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="M:PInvoke.NTStatusException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.NTStatusException"/> class
            for deserialization.
            </summary>
            <param name="info">Serialization information.</param>
            <param name="context">Streaming context.</param>
        </member>
        <member name="P:PInvoke.NTStatusException.NativeErrorCode">
            <summary>
            Gets the <see cref="T:PInvoke.NTSTATUS"/> code that identifies the error condition.
            </summary>
        </member>
        <member name="M:PInvoke.NTStatusException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.NTStatusException.GetMessage(PInvoke.NTSTATUS)">
            <summary>
            Gets the message associated with the given <see cref="T:PInvoke.NTSTATUS"/>.
            </summary>
            <param name="status">The <see cref="T:PInvoke.NTSTATUS"/> for the error.</param>
            <returns>The description of the error.</returns>
        </member>
        <member name="T:PInvoke.Win32Exception">
            <summary>
            An exception thrown for a failure described by a <see cref="T:PInvoke.Win32ErrorCode"/>.
            </summary>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor(PInvoke.Win32ErrorCode)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class.
            </summary>
            <param name="error">The Win32 error code associated with this exception.</param>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class.
            </summary>
            <param name="error">The Win32 error code associated with this exception.</param>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor(PInvoke.Win32ErrorCode,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class.
            </summary>
            <param name="error">The Win32 error code associated with this exception.</param>
            <param name="message">The message for this exception.</param>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class
            for deserialization.
            </summary>
            <param name="info">Serialization information.</param>
            <param name="context">Streaming context.</param>
        </member>
        <member name="P:PInvoke.Win32Exception.NativeErrorCode">
            <summary>
            Gets the Win32 error code associated with this exception.
            </summary>
            <devremarks>
            We must define this so that our own assembly on desktop is not a subset
            of what portable offers (lest runtime errors in our users occur).
            </devremarks>
        </member>
    </members>
</doc>
